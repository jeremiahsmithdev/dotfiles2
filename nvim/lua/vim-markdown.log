SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/markdown.vim
Sourced 1 time
Total time:   0.062815
 Self time:   0.004390

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:    *.markdown
                            " Last Change:  2020 Jan 14
                            
    1              0.000007 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000002 if !exists('main_syntax')
    1              0.000004   let main_syntax = 'markdown'
    1              0.000001 endif
                            
    1   0.061754   0.003329 runtime! syntax/html.vim
    1              0.000004 unlet! b:current_syntax
                            
    1              0.000005 if !exists('g:markdown_fenced_languages')
    1              0.000003   let g:markdown_fenced_languages = []
    1              0.000001 endif
    1              0.000002 let s:done_include = {}
    1              0.000007 for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000001 endfor
    1              0.000001 unlet! s:type
    1              0.000001 unlet! s:done_include
                            
    1              0.000002 if !exists('g:markdown_minlines')
    1              0.000003   let g:markdown_minlines = 50
    1              0.000001 endif
    1              0.000008 execute 'syn sync minlines=' . g:markdown_minlines
    1              0.000001 syn case ignore
                            
    1              0.000023 syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
    1              0.000005 syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
                            
    1              0.000014 syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
    1              0.000102 syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
    1              0.000049 syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
                            
    1              0.000022 syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
    1              0.000010 syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
    1              0.000004 syn match markdownHeadingRule "^[=-]\+$" contained
                            
    1              0.000021 syn region markdownH1 matchgroup=markdownH1Delimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000018 syn region markdownH2 matchgroup=markdownH2Delimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000013 syn region markdownH3 matchgroup=markdownH3Delimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000012 syn region markdownH4 matchgroup=markdownH4Delimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000012 syn region markdownH5 matchgroup=markdownH5Delimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000012 syn region markdownH6 matchgroup=markdownH6Delimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
    1              0.000004 syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
    1              0.000009 syn region markdownCodeBlock start="    \|\t" end="$" contained
                            
                            " TODO: real nesting
    1              0.000007 syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
    1              0.000005 syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
    1              0.000004 syn match markdownRule "\* *\* *\*[ *]*$" contained
    1              0.000003 syn match markdownRule "- *- *-[ -]*$" contained
                            
    1              0.000003 syn match markdownLineBreak " \{2,\}$"
                            
    1              0.000025 syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
    1              0.000009 syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
    1              0.000011 syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
    1              0.000010 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
    1              0.000003 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
    1              0.000037 syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\%(\_[^][]\|\[\_[^][]*\]\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
    1              0.000005 syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
    1              0.000010 syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
    1              0.000007 syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
    1              0.000003 let s:concealends = ''
    1              0.000006 if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
    1              0.000002   let s:concealends = ' concealends'
    1              0.000001 endif
    1              0.000023 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000013 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000022 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000013 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000026 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000012 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
                            
    1              0.000017 syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
    1              0.000030 syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
    1              0.000011 syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend
                            
    1              0.000012 syn match markdownFootnote "\[^[^\]]\+\]"
    1              0.000010 syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
    1              0.000002 if main_syntax ==# 'markdown'
    1              0.000003   let s:done_include = {}
    1              0.000002   for s:type in g:markdown_fenced_languages
                                if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                  continue
                                endif
                                exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*````*\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*````*\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g') . s:concealends
                                let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000001   endfor
    1              0.000001   unlet! s:type
    1              0.000001   unlet! s:done_include
    1              0.000001 endif
                            
    1              0.000004 syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
    1              0.000003 syn match markdownError "\w\@<=_\w\@="
                            
    1              0.000014 hi def link markdownH1                    htmlH1
    1              0.000012 hi def link markdownH2                    htmlH2
    1              0.000003 hi def link markdownH3                    htmlH3
    1              0.000002 hi def link markdownH4                    htmlH4
    1              0.000002 hi def link markdownH5                    htmlH5
    1              0.000002 hi def link markdownH6                    htmlH6
    1              0.000002 hi def link markdownHeadingRule           markdownRule
    1              0.000007 hi def link markdownH1Delimiter           markdownHeadingDelimiter
    1              0.000006 hi def link markdownH2Delimiter           markdownHeadingDelimiter
    1              0.000006 hi def link markdownH3Delimiter           markdownHeadingDelimiter
    1              0.000006 hi def link markdownH4Delimiter           markdownHeadingDelimiter
    1              0.000006 hi def link markdownH5Delimiter           markdownHeadingDelimiter
    1              0.000006 hi def link markdownH6Delimiter           markdownHeadingDelimiter
    1              0.000012 hi def link markdownHeadingDelimiter      Delimiter
    1              0.000002 hi def link markdownOrderedListMarker     markdownListMarker
    1              0.000003 hi def link markdownListMarker            htmlTagName
    1              0.000007 hi def link markdownBlockquote            Comment
    1              0.000006 hi def link markdownRule                  PreProc
                            
    1              0.000006 hi def link markdownFootnote              Typedef
    1              0.000006 hi def link markdownFootnoteDefinition    Typedef
                            
    1              0.000007 hi def link markdownLinkText              htmlLink
    1              0.000006 hi def link markdownIdDeclaration         Typedef
    1              0.000006 hi def link markdownId                    Type
    1              0.000001 hi def link markdownAutomaticLink         markdownUrl
    1              0.000006 hi def link markdownUrl                   Float
    1              0.000006 hi def link markdownUrlTitle              String
    1              0.000001 hi def link markdownIdDelimiter           markdownLinkDelimiter
    1              0.000003 hi def link markdownUrlDelimiter          htmlTag
    1              0.000007 hi def link markdownUrlTitleDelimiter     Delimiter
                            
    1              0.000003 hi def link markdownItalic                htmlItalic
    1              0.000001 hi def link markdownItalicDelimiter       markdownItalic
    1              0.000002 hi def link markdownBold                  htmlBold
    1              0.000001 hi def link markdownBoldDelimiter         markdownBold
    1              0.000002 hi def link markdownBoldItalic            htmlBoldItalic
    1              0.000001 hi def link markdownBoldItalicDelimiter   markdownBoldItalic
    1              0.000006 hi def link markdownCodeDelimiter         Delimiter
                            
    1              0.000006 hi def link markdownEscape                Special
    1              0.000006 hi def link markdownError                 Error
                            
    1              0.000002 let b:current_syntax = "markdown"
    1              0.000002 if main_syntax ==# 'markdown'
    1              0.000001   unlet main_syntax
    1              0.000001 endif
                            
                            " vim:set sw=2:

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/html.vim
Sourced 1 time
Total time:   0.058406
 Self time:   0.021509

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Previous Maintainer:  Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2021 Mar 02
                            "			Included patch #7900 to fix comments
                            "			Included patch #7916 to fix a few more things
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000008 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
    1              0.000001 endif
                            
    1              0.000012 let s:cpo_save = &cpo
    1              0.000013 set cpo&vim
                            
    1              0.000002 syntax spell toplevel
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000036 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000031 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000008 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000015 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000024 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    1              0.000034 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000022 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000006 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000003 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000004 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000003 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000004 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000002 syn keyword htmlTagName contained form hr html img
    1              0.000003 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000004 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000004 syn keyword htmlTagName contained select small sub sup
    1              0.000009 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000007 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000003 syn keyword htmlTagName contained abbr acronym bdo button col label
    1              0.000003 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    1              0.000003 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000003 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000003 syn keyword htmlTagName contained datalist details dialog embed figcaption
    1              0.000003 syn keyword htmlTagName contained figure footer header hgroup keygen main
    1              0.000003 syn keyword htmlTagName contained mark menuitem meter nav output picture
    1              0.000003 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000003 syn keyword htmlTagName contained slot source summary template time track
    1              0.000002 syn keyword htmlTagName contained video wbr
                            
                            " legal arg names
    1              0.000002 syn keyword htmlArg contained action
    1              0.000003 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000002 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000004 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000003 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000003 syn keyword htmlArg contained gutter height hspace id
    1              0.000003 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000003 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000003 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000004 syn keyword htmlArg contained size src start target text type url
    1              0.000003 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000005 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000071 exe 'syn match htmlArg contained "\<aria-\%(' . join([
                                \ 'activedescendant', 'atomic', 'autocomplete', 'busy', 'checked', 'colcount',
                                \ 'colindex', 'colspan', 'controls', 'current', 'describedby', 'details',
                                \ 'disabled', 'dropeffect', 'errormessage', 'expanded', 'flowto', 'grabbed',
                                \ 'haspopup', 'hidden', 'invalid', 'keyshortcuts', 'label', 'labelledby', 'level',
                                \ 'live', 'modal', 'multiline', 'multiselectable', 'orientation', 'owns',
                                \ 'placeholder', 'posinset', 'pressed', 'readonly', 'relevant', 'required',
                                \ 'roledescription', 'rowcount', 'rowindex', 'rowspan', 'selected', 'setsize',
                                \ 'sort', 'valuemax', 'valuemin', 'valuenow', 'valuetext'
                                \ ], '\|') . '\)\>"'
    1              0.000002 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000003 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000015 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000014 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    1              0.000011 syn keyword htmlArg     contained left top visibility clip id noshade
    1              0.000003 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000003 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000004 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    1              0.000012 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000009 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000008 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000009 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000003 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000002 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000002 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000002 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    1              0.000002 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    1              0.000003 syn keyword htmlArg contained controls crossorigin default dirname download
    1              0.000003 syn keyword htmlArg contained draggable dropzone form formaction formenctype
    1              0.000002 syn keyword htmlArg contained formmethod formnovalidate formtarget hidden
    1              0.000003 syn keyword htmlArg contained high icon inputmode keytype kind list loop low
    1              0.000003 syn keyword htmlArg contained max min minlength muted nonce novalidate open
    1              0.000003 syn keyword htmlArg contained optimum pattern placeholder poster preload
    1              0.000002 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    1              0.000003 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    1              0.000001 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    1              0.000008 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000004 if exists("html_wrong_comments")
                              syn region htmlComment        start=+<!--+    end=+--\s*>+    contains=@Spell
    1              0.000001 else
                              " The HTML 5.2 syntax 8.2.4.41: bogus comment is parser error; browser skips until next &gt
    1              0.000021   syn region htmlComment        start=+<!+      end=+>+         contains=htmlCommentError keepend
                              " Idem 8.2.4.42,51: Comment starts with <!-- and ends with -->
                              " Idem 8.2.4.43,44: Except <!--> and <!---> are parser errors
                              " Idem 8.2.4.52: dash-dash-bang (--!>) is error ignored by parser, also closes comment
    1              0.000015   syn region htmlComment matchgroup=htmlComment start=+<!--\%(-\?>\)\@!+        end=+--!\?>+    contains=htmlCommentNested,@htmlPreProc,@Spell keepend
                              " Idem 8.2.4.49: nested comment is parser error, except <!--> is all right
    1              0.000004   syn match htmlCommentNested contained "<!-->\@!"
    1              0.000003   syn match htmlCommentError  contained "[^><!]"
    1              0.000001 endif
    1              0.000005 syn region htmlComment  start=+<!DOCTYPE+       end=+>+ keepend
                            
                            " server-parsed commands
    1              0.000025 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000011 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000003 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000034 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000008 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000003 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000011 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000003 if !exists("html_no_rendering")
                              " rendering
    1              0.000018   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000011   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000022   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000008   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000012   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000010   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000006   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000005   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000005   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000005   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000019   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000010   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000007   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000013   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000006   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000005   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000005   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000005   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000024   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000007   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000013   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000008   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000006   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    1              0.000014   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000005   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000005   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000012   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000014   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000015   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    1              0.000010   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    1              0.000012   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    1              0.000012   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    1              0.000009   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    1              0.000009   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    1              0.000032   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000011   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000002 syn keyword htmlTagName         contained noscript
    1              0.000002 syn keyword htmlSpecialTagName  contained script style
    1              0.000004 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    1   0.004654   0.002181   syn include @htmlJavaScript syntax/javascript.vim
    1              0.000004   unlet b:current_syntax
    1              0.000034   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000023   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    1              0.000002   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    1              0.000004   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
    1              0.000001   else
    1              0.000007     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    1              0.000007     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    1              0.000001   endif
    1              0.000008   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    1              0.000006   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    1              0.000002   hi def link htmlEventSQ htmlEvent
    1              0.000001   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    1              0.000008   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000004 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    1   0.004358   0.001796   syn include @htmlVbScript syntax/vb.vim
    1              0.000004   unlet b:current_syntax
    1              0.000025   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000004 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    1              0.000005 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    1              0.000003   syn keyword htmlArg           contained media
    1   0.033727   0.001866   syn include @htmlCss syntax/css.vim
    1              0.000003   unlet b:current_syntax
    1              0.000040   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    1              0.000006   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    1              0.001342   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    1              0.000010   hi def link htmlStyleArg htmlString
    1              0.000001 endif
                            
    1              0.000004 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
    1              0.000001 endif
                            
                            " The default highlighting.
    1              0.000007 hi def link htmlTag                     Function
    1              0.000007 hi def link htmlEndTag                  Identifier
    1              0.000007 hi def link htmlArg                     Type
    1              0.000007 hi def link htmlTagName                 htmlStatement
    1              0.000006 hi def link htmlSpecialTagName          Exception
    1              0.000006 hi def link htmlValue                   String
    1              0.000006 hi def link htmlSpecialChar             Special
                            
    1              0.000004 if !exists("html_no_rendering")
    1              0.000010   hi def link htmlH1                      Title
    1              0.000009   hi def link htmlH2                      htmlH1
    1              0.000006   hi def link htmlH3                      htmlH2
    1              0.000002   hi def link htmlH4                      htmlH3
    1              0.000002   hi def link htmlH5                      htmlH4
    1              0.000002   hi def link htmlH6                      htmlH5
    1              0.000006   hi def link htmlHead                    PreProc
    1              0.000007   hi def link htmlTitle                   Title
    1              0.000003   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlUnderlineBold           htmlBoldUnderline
    1              0.000003   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlItalicUnderline         htmlUnderlineItalic
    1              0.000003   hi def link htmlItalicBold              htmlBoldItalic
    1              0.000003   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    1              0.000003   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    1              0.000006   hi def link htmlLink                    Underlined
    1              0.000007   hi def link htmlLeadingSpace            None
    1              0.000002   if !exists("html_my_rendering")
    1              0.000007     hi def htmlBold                term=bold cterm=bold gui=bold
    1              0.000020     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000005     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000005     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000003     hi def htmlUnderline           term=underline cterm=underline gui=underline
    1              0.000015     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000003     hi def htmlItalic              term=italic cterm=italic gui=italic
    1              0.000008     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000004         hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                                    hi def htmlStrike              term=underline cterm=underline gui=underline
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000006 hi def link htmlPreStmt            PreProc
    1              0.000007 hi def link htmlPreError           Error
    1              0.000006 hi def link htmlPreProc            PreProc
    1              0.000006 hi def link htmlPreAttr            String
    1              0.000006 hi def link htmlPreProcAttrName    PreProc
    1              0.000006 hi def link htmlPreProcAttrError   Error
    1              0.000006 hi def link htmlString             String
    1              0.000005 hi def link htmlStatement          Statement
    1              0.000006 hi def link htmlComment            Comment
    1              0.000003 hi def link htmlCommentNested      htmlError
    1              0.000003 hi def link htmlCommentError       htmlError
    1              0.000003 hi def link htmlTagError           htmlError
    1              0.000003 hi def link htmlEvent              javaScript
    1              0.000006 hi def link htmlError              Error
                            
    1              0.000048 hi def link javaScript             Special
    1              0.000004 hi def link javaScriptExpression   javaScript
    1              0.000006 hi def link htmlCssStyleComment    Comment
    1              0.000006 hi def link htmlCssDefinition      Special
                            
    1              0.000003 let b:current_syntax = "html"
                            
    1              0.000002 if main_syntax == 'html'
                              unlet main_syntax
    1              0.000001 endif
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/javascript.vim
Sourced 1 time
Total time:   0.002453
 Self time:   0.002453

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2021 Mar 30
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000007 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    1              0.000003 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
    1              0.000001 endif
                            
    1              0.000010 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
                            
    1              0.000030 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    1              0.000012 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    1              0.000011 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    1              0.000012 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    1              0.000008 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    1              0.000013 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000014 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000020 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    1              0.000007 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
    1              0.000009 syn match   javaScriptSpecialCharacter "'\\.'"
    1              0.000010 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    1              0.000005 syn match   javaScriptNumber	       "-\=\<\d\+\%(_\d\+\)*\>"
    1              0.000026 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    1              0.000007 syn keyword javaScriptConditional	if else switch
    1              0.000007 syn keyword javaScriptRepeat		while for do in
    1              0.000006 syn keyword javaScriptBranch		break continue
    1              0.000007 syn keyword javaScriptOperator		new delete instanceof typeof
    1              0.000008 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    1              0.000006 syn keyword javaScriptStatement		return with await
    1              0.000006 syn keyword javaScriptBoolean		true false
    1              0.000009 syn keyword javaScriptNull		null undefined
    1              0.000007 syn keyword javaScriptIdentifier	arguments this var let
    1              0.000006 syn keyword javaScriptLabel		case default
    1              0.000007 syn keyword javaScriptException		try catch finally throw
    1              0.000007 syn keyword javaScriptMessage		alert confirm prompt status
    1              0.000007 syn keyword javaScriptGlobal		self window top parent
    1              0.000007 syn keyword javaScriptMember		document event location 
    1              0.000007 syn keyword javaScriptDeprecated	escape unescape
    1              0.000016 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
    1              0.000006 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    1              0.000003 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
    1              0.000001 else
    1              0.000007     syn keyword javaScriptFunction	function
    1              0.000008     syn match	javaScriptBraces	   "[{}\[\]]"
    1              0.000007     syn match	javaScriptParens	   "[()]"
    1              0.000001 endif
                            
    1              0.000002 if main_syntax == "javascript"
                              syn sync fromstart
                              syn sync maxlines=100
                            
                              syn sync ccomment javaScriptComment
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    1              0.000005 hi def link javaScriptComment		Comment
    1              0.000004 hi def link javaScriptLineComment		Comment
    1              0.000006 hi def link javaScriptCommentTodo		Todo
    1              0.000005 hi def link javaScriptSpecial		Special
    1              0.000005 hi def link javaScriptStringS		String
    1              0.000004 hi def link javaScriptStringD		String
    1              0.000004 hi def link javaScriptStringT		String
    1              0.000008 hi def link javaScriptCharacter		Character
    1              0.000001 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    1              0.000005 hi def link javaScriptNumber		javaScriptValue
    1              0.000004 hi def link javaScriptConditional		Conditional
    1              0.000004 hi def link javaScriptRepeat		Repeat
    1              0.000004 hi def link javaScriptBranch		Conditional
    1              0.000005 hi def link javaScriptOperator		Operator
    1              0.000004 hi def link javaScriptType			Type
    1              0.000004 hi def link javaScriptStatement		Statement
    1              0.000004 hi def link javaScriptFunction		Function
    1              0.000004 hi def link javaScriptBraces		Function
    1              0.000008 hi def link javaScriptError		Error
    1              0.000005 hi def link javaScrParenError		javaScriptError
    1              0.000004 hi def link javaScriptNull			Keyword
    1              0.000004 hi def link javaScriptBoolean		Boolean
    1              0.000004 hi def link javaScriptRegexpString		String
                            
    1              0.000004 hi def link javaScriptIdentifier		Identifier
    1              0.000004 hi def link javaScriptLabel		Label
    1              0.000004 hi def link javaScriptException		Exception
    1              0.000004 hi def link javaScriptMessage		Keyword
    1              0.000004 hi def link javaScriptGlobal		Keyword
    1              0.000004 hi def link javaScriptMember		Keyword
    1              0.000004 hi def link javaScriptDeprecated		Exception 
    1              0.000004 hi def link javaScriptReserved		Keyword
    1              0.000008 hi def link javaScriptDebug		Debug
    1              0.000008 hi def link javaScriptConstant		Label
    1              0.000004 hi def link javaScriptEmbed		Special
                            
                            
                            
    1              0.000003 let b:current_syntax = "javascript"
    1              0.000002 if main_syntax == 'javascript'
                              unlet main_syntax
    1              0.000001 endif
    1              0.000012 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/vb.vim
Sourced 1 time
Total time:   0.002540
 Self time:   0.002540

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000007 if exists("b:current_syntax")
                            	finish
    1              0.000001 endif
                            
                            " VB is case insensitive
    1              0.000002 syn case ignore
                            
    1              0.000027 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    1              0.000009 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    1              0.000003 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    1              0.000006 syn match vbOperator "[()+.,\-/*=&]"
    1              0.000003 syn match vbOperator "[<>]=\="
    1              0.000003 syn match vbOperator "<>"
    1              0.000005 syn match vbOperator "\s\+_$"
                            
    1              0.000009 syn keyword vbBoolean  True False
    1              0.000006 syn keyword vbConst Null Nothing
                            
    1              0.000007 syn keyword vbRepeat Do For ForEach Loop Next
    1              0.000003 syn keyword vbRepeat Step To Until Wend While
                            
    1              0.000007 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    1              0.000003 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    1              0.000002 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    1              0.000002 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    1              0.000002 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    1              0.000002 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    1              0.000003 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    1              0.000002 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    1              0.000002 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    1              0.000002 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    1              0.000002 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    1              0.000002 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    1              0.000002 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    1              0.000002 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    1              0.000002 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    1              0.000003 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    1              0.000003 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    1              0.000003 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    1              0.000002 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    1              0.000002 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    1              0.000002 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    1              0.000002 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    1              0.000002 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    1              0.000002 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    1              0.000002 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    1              0.000002 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    1              0.000002 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    1              0.000002 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    1              0.000002 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    1              0.000002 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    1              0.000002 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    1              0.000003 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    1              0.000003 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    1              0.000003 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    1              0.000002 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    1              0.000002 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    1              0.000002 syn keyword vbEvents IniProperties InitProperties Initialize
    1              0.000002 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    1              0.000002 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    1              0.000003 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    1              0.000002 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    1              0.000002 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    1              0.000002 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    1              0.000002 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    1              0.000003 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    1              0.000002 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    1              0.000002 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    1              0.000002 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    1              0.000002 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    1              0.000002 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    1              0.000002 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    1              0.000002 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    1              0.000002 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    1              0.000002 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    1              0.000005 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    1              0.000002 syn keyword vbEvents RepeatedControlUnloaded Reposition
    1              0.000002 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    1              0.000002 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    1              0.000002 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    1              0.000003 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    1              0.000002 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    1              0.000002 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    1              0.000002 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    1              0.000003 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    1              0.000002 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    1              0.000002 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    1              0.000002 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    1              0.000002 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    1              0.000002 syn keyword vbEvents UserEvent Validate ValidationError
    1              0.000002 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    1              0.000002 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    1              0.000001 syn keyword vbEvents WriteProperties
                            
                            
    1              0.000008 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    1              0.000004 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    1              0.000003 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    1              0.000003 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    1              0.000003 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    1              0.000003 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    1              0.000003 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    1              0.000002 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    1              0.000002 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    1              0.000002 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    1              0.000003 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    1              0.000003 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    1              0.000003 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    1              0.000113 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    1              0.000046 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    1              0.000047 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    1              0.000069 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    1              0.000068 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    1              0.000076 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    1              0.000050 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    1              0.000029 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    1              0.000038 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    1              0.000042 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    1              0.000008 syn keyword vbFunction Year
                            
    1              0.000036 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    1              0.000025 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    1              0.000030 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    1              0.000022 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    1              0.000037 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    1              0.000024 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    1              0.000024 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    1              0.000032 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    1              0.000032 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    1              0.000032 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    1              0.000025 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    1              0.000035 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    1              0.000024 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    1              0.000024 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    1              0.000030 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    1              0.000024 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    1              0.000023 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    1              0.000025 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    1              0.000036 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    1              0.000025 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    1              0.000017 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    1              0.000003 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    1              0.000003 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    1              0.000003 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    1              0.000003 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    1              0.000003 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    1              0.000003 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    1              0.000002 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    1              0.000003 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    1              0.000003 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    1              0.000002 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    1              0.000002 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    1              0.000002 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    1              0.000002 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    1              0.000004 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    1              0.000003 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    1              0.000003 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    1              0.000003 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    1              0.000003 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    1              0.000002 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    1              0.000002 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    1              0.000002 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    1              0.000002 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    1              0.000002 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    1              0.000002 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    1              0.000003 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    1              0.000002 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    1              0.000002 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    1              0.000002 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    1              0.000002 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    1              0.000002 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    1              0.000002 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    1              0.000002 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    1              0.000002 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    1              0.000002 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    1              0.000002 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    1              0.000003 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    1              0.000003 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    1              0.000002 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    1              0.000002 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    1              0.000002 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    1              0.000002 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    1              0.000003 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    1              0.000003 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    1              0.000003 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    1              0.000003 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    1              0.000002 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    1              0.000003 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    1              0.000002 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    1              0.000003 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    1              0.000002 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    1              0.000002 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    1              0.000003 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    1              0.000002 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    1              0.000002 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    1              0.000002 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    1              0.000009 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    1              0.000004 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    1              0.000003 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    1              0.000003 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    1              0.000003 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    1              0.000003 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    1              0.000003 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    1              0.000003 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    1              0.000003 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    1              0.000002 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    1              0.000003 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    1              0.000003 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    1              0.000003 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    1              0.000001 syn keyword vbStatement Write
                            
    1              0.000007 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    1              0.000003 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    1              0.000019 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    1              0.000003 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    1              0.000003 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    1              0.000003 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    1              0.000006 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    1              0.000011 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    1              0.000003 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    1              0.000007 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    1              0.000003 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    1              0.000003 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    1              0.000003 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    1              0.000001 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    1              0.000002 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    1              0.000002 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    1              0.000002 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    1              0.000002 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    1              0.000002 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    1              0.000002 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    1              0.000002 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    1              0.000002 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    1              0.000002 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    1              0.000002 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    1              0.000002 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    1              0.000002 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    1              0.000002 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    1              0.000002 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    1              0.000002 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    1              0.000003 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    1              0.000002 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    1              0.000002 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    1              0.000002 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    1              0.000002 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    1              0.000002 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    1              0.000002 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    1              0.000002 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    1              0.000002 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    1              0.000002 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    1              0.000002 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    1              0.000002 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    1              0.000002 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    1              0.000002 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    1              0.000002 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    1              0.000002 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    1              0.000002 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    1              0.000003 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    1              0.000003 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    1              0.000002 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    1              0.000002 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    1              0.000002 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    1              0.000002 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    1              0.000002 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    1              0.000002 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    1              0.000002 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    1              0.000002 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    1              0.000002 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    1              0.000002 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    1              0.000002 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    1              0.000002 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    1              0.000002 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    1              0.000003 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    1              0.000002 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    1              0.000002 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    1              0.000002 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    1              0.000002 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    1              0.000003 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    1              0.000002 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    1              0.000002 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    1              0.000002 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    1              0.000003 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    1              0.000002 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    1              0.000002 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    1              0.000002 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    1              0.000002 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    1              0.000002 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    1              0.000002 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    1              0.000002 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    1              0.000009 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    1              0.000004 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    1              0.000003 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    1              0.000009 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    1              0.000005 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    1              0.000004 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    1              0.000010 syn region  vbString		start=+"+  end=+"\|$+
    1              0.000012 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    1              0.000006 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    1              0.000008 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    1              0.000009 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    1              0.000003 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000005 hi def link vbBoolean		Boolean
    1              0.000004 hi def link vbLineNumber		Comment
    1              0.000004 hi def link vbComment		Comment
    1              0.000004 hi def link vbConditional	Conditional
    1              0.000004 hi def link vbConst			Constant
    1              0.000004 hi def link vbDefine			Constant
    1              0.000008 hi def link vbError			Error
    1              0.000005 hi def link vbFunction		Identifier
    1              0.000008 hi def link vbIdentifier		Identifier
    1              0.000004 hi def link vbNumber			Number
    1              0.000004 hi def link vbFloat			Float
    1              0.000004 hi def link vbMethods		PreProc
    1              0.000005 hi def link vbOperator		Operator
    1              0.000004 hi def link vbRepeat			Repeat
    1              0.000004 hi def link vbString			String
    1              0.000004 hi def link vbStatement		Statement
    1              0.000004 hi def link vbKeyword		Statement
    1              0.000004 hi def link vbEvents			Special
    1              0.000004 hi def link vbTodo			Todo
    1              0.000004 hi def link vbTypes			Type
    1              0.000004 hi def link vbTypeSpecifier	Type
                            
                            
    1              0.000004 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/css.vim
Sourced 1 time
Total time:   0.031833
 Self time:   0.031833

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Jules Wang      <w.jq0722@gmail.com>
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/jsit/css.vim
                            " Maintainer:   Jay Sitter <jay@jaysitter.com>
                            " Last Change:  2019 Jul. 29
                            
                            " quit when a syntax file was already loaded
    1              0.000010 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    1              0.000004 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    1              0.000001 endif
                            
    1              0.000015 let s:cpo_save = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000002 syn case ignore
                            
                            " HTML4 tags
    1              0.000028 syn keyword cssTagName abbr address area a b base
    1              0.000005 syn keyword cssTagName bdo blockquote body br button
    1              0.000005 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000003 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000003 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000004 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000004 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000004 syn keyword cssTagName option p param pre q s samp script small
    1              0.000003 syn keyword cssTagName span strong sub sup tbody td
    1              0.000004 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000002 syn keyword cssTagName object svg
    1              0.000012 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000004 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000004 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000004 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000003 syn keyword cssTagName output progress rt rp ruby section
    1              0.000003 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000003 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000008 syn match cssSelectorOp "[,>+~]"
    1              0.000008 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000027 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000016 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000003 syn match cssClassNameDot contained '\.'
                            
    1              0.000001 try
    1              0.000010 syn match cssIdentifier "#[A-Za-zÀ-ÿ_@][A-Za-zÀ-ÿ0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    1              0.000002 endtry
                            
                            " digits
    1              0.000013 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000009 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000015 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\|ch\)\>" contains=cssUnitDecorators
    1              0.000004 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    1              0.000011 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000008 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000008 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    1              0.000012 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000003 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000003 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000004 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000008 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000008 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000004 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000004 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000012 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000003 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000003 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000003 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000002 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000007 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000005 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000004 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000008 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000009 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000003 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000003 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000005 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000003 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000019 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    1              0.000003 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    1              0.000004 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000003 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000002 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000001 syn case match
    1              0.000008 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000001 syn case ignore
                            
    1              0.000008 syn match cssImportant contained "!\s*important\>"
    1              0.000011 syn match cssCustomProp contained "--[a-zA-Z0-9-_]*"
                            
    1              0.000003 syn match cssColor contained "\<transparent\>"
    1              0.000003 syn match cssColor contained "\<currentColor\>"
    1              0.000002 syn match cssColor contained "\<white\>"
    1              0.000004 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    1              0.000004 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    1              0.000003 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    1              0.000020 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.000369 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.000017 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000011 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000016 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000015 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000013 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000005 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000002 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000008 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000003 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
    1              0.000004 syn match cssCommonAttr contained "\<\(max-\|min-\|fit-\)content\>"
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000044 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000007 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000004 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000002 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000002 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000001 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000014 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000007 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000002 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000003 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000005 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    1              0.000002 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000010 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000005 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000005 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000003 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000005 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000007 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    1              0.000004 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000002 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000002 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000010 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000004 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000004 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000003 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000007 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000003 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000006 syn keyword cssCascadeProp contained all
    1              0.000006 syn keyword cssCascadeAttr contained initial unset revert
                            
    1              0.000006 syn keyword cssColorProp contained opacity
    1              0.000005 syn match cssColorProp contained "\<color-profile\>"
    1              0.000003 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000009 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000001 syn keyword cssDimensionProp contained height
    1              0.000001 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    1              0.000011 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    1              0.000001 syn keyword cssFlexibleBoxProp contained order
                            
    1              0.000010 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    1              0.000002 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000023 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000006 syn keyword cssFontAttr contained icon menu caption
    1              0.000003 syn match cssFontAttr contained "\<message-box\>"
    1              0.000003 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000002 syn keyword cssFontAttr contained larger smaller
    1              0.000004 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    1              0.000004 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    1              0.000006 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    1              0.000032 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    1              0.000002 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000002 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000008 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000002 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000002 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000002 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000003 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000005 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000008 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000007 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000001 syn keyword cssMultiColumnProp contained columns
    1              0.000006 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000003 syn keyword cssMultiColumnAttr contained always left right page column
    1              0.000004 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000004 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    1              0.000009 syn match cssInteractProp contained "\<pointer-events\>"
    1              0.000009 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000006 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000004 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000002 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000005 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000010 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    1              0.000007 syn match cssGridProp contained "\<grid\>"
    1              0.000006 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    1              0.000005 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    1              0.000003 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    1              0.000006 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    1              0.000008 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000008 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000010 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000004 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000014 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000003 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000002 syn keyword cssListAttr contained inside outside
                            
    1              0.000008 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000003 syn keyword cssPositioningProp contained position right top visibility
    1              0.000003 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000007 syn keyword cssPositioningAttr contained block compact grid
    1              0.000011 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000002 syn keyword cssPositioningAttr contained left right both
    1              0.000003 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000017 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    1              0.000003 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    1              0.000003 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    1              0.000007 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    1              0.000011 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000008 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000007 syn keyword cssTextProp contained color direction hyphens
    1              0.000014 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000007 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000005 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    1              0.000005 syn match cssTextProp contained "\<white-space\>"
    1              0.000003 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000002 syn match cssTextProp contained "\<tab-size\>"
    1              0.000003 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000007 syn match cssTextAttr contained "\<line-through\>"
    1              0.000005 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000002 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000003 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000002 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000002 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000003 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    1              0.000003 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000003 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000002 syn keyword cssTextAttr contained start end adjacent
    1              0.000004 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000002 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000002 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000004 syn match cssTextAttr contained "\<break-all\>"
    1              0.000002 syn match cssTextAttr contained "\<break-word\>"
    1              0.000001 syn keyword cssTextAttr contained manual
    1              0.000003 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000008 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000005 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000003 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000012 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000010 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000004 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000003 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000007 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000010 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000001 syn keyword cssUIProp contained cursor
    1              0.000006 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000003 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000003 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000003 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000002 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000003 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000002 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000007 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000003 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000002 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000002 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000035 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000005 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000012 syn keyword cssUIAttr contained invert
                            
    1              0.000002 syn keyword cssUIProp contained icon resize
    1              0.000002 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000003 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000002 syn keyword cssUIAttr contained clip ellipsis
                            
    1              0.000003 syn match cssUIProp contained "\<image-rendering\>"
    1              0.000001 syn keyword cssUIAttr contained pixellated
    1              0.000002 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000002 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    1              0.000007 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    1              0.000005 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    1              0.000008 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000001 syn keyword cssUIProp contained appearance
    1              0.000003 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000014 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000009 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000003 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000008 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000001 syn keyword cssAuralAttr contained silent
    1              0.000003 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000002 syn keyword cssAuralAttr contained non mix
    1              0.000003 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000004 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000002 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000002 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000004 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000002 syn keyword cssAuralAttr contained faster slower
    1              0.000004 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000007 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    1              0.000007 syn keyword cssMediaProp contained width height orientation scan
    1              0.000005 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    1              0.000004 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    1              0.000006 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    1              0.000009 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    1              0.000007 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    1              0.000015 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    1              0.000012 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    1              0.000006 syn keyword cssPageProp contained content size
    1              0.000002 syn keyword cssPageProp contained orphans widows
    1              0.000006 syn keyword cssFontDescriptorProp contained src
    1              0.000003 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    1              0.000008 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000003 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    1              0.000008 syn match cssBraces contained "[{}]"
    1              0.000008 syn match cssError contained "{@<>"
    1              0.000866 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000008 syn match cssBraceError "}"
    1              0.000007 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    1              0.000021 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000004 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000004 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    1              0.000004 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000005 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000011 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000003 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000003 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    1              0.000004 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000012 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000003 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000008 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000005 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000007 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000007 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000008 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000009 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000009 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000002 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    1              0.001159 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.001694 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    1              0.000016 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    1              0.000008 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000022 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    1              0.000006 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000014 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    1              0.000005 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000010 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    1              0.000015 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    1              0.000010 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    1              0.000009 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    1              0.000837 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    1              0.000005 if main_syntax == "css"
                              syn sync minlines=10
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000006 hi def link cssComment Comment
    1              0.000005 hi def link cssVendor Comment
    1              0.000005 hi def link cssHacks Comment
    1              0.000005 hi def link cssTagName Statement
    1              0.000009 hi def link cssDeprecated Error
    1              0.000005 hi def link cssSelectorOp Special
    1              0.000005 hi def link cssSelectorOp2 Special
    1              0.000004 hi def link cssAttrComma Special
                            
    1              0.000006 hi def link cssAnimationProp cssProp
    1              0.000001 hi def link cssBackgroundProp cssProp
    1              0.000001 hi def link cssBorderProp cssProp
    1              0.000001 hi def link cssBoxProp cssProp
    1              0.000001 hi def link cssCascadeProp cssProp
    1              0.000001 hi def link cssColorProp cssProp
    1              0.000006 hi def link cssContentForPagedMediaProp cssProp
    1              0.000001 hi def link cssDimensionProp cssProp
    1              0.000001 hi def link cssFlexibleBoxProp cssProp
    1              0.000001 hi def link cssFontProp cssProp
    1              0.000001 hi def link cssGeneratedContentProp cssProp
    1              0.000001 hi def link cssGridProp cssProp
    1              0.000001 hi def link cssHyerlinkProp cssProp
    1              0.000001 hi def link cssInteractProp cssProp
    1              0.000005 hi def link cssLineboxProp cssProp
    1              0.000001 hi def link cssListProp cssProp
    1              0.000005 hi def link cssMarqueeProp cssProp
    1              0.000001 hi def link cssMultiColumnProp cssProp
    1              0.000006 hi def link cssPagedMediaProp cssProp
    1              0.000001 hi def link cssPositioningProp cssProp
    1              0.000005 hi def link cssPrintProp cssProp
    1              0.000005 hi def link cssRubyProp cssProp
    1              0.000005 hi def link cssSpeechProp cssProp
    1              0.000001 hi def link cssTableProp cssProp
    1              0.000001 hi def link cssTextProp cssProp
    1              0.000001 hi def link cssTransformProp cssProp
    1              0.000001 hi def link cssTransitionProp cssProp
    1              0.000001 hi def link cssUIProp cssProp
    1              0.000001 hi def link cssIEUIProp cssProp
    1              0.000001 hi def link cssAuralProp cssProp
    1              0.000005 hi def link cssRenderProp cssProp
    1              0.000001 hi def link cssMobileTextProp cssProp
                            
    1              0.000006 hi def link cssAnimationAttr cssAttr
    1              0.000002 hi def link cssBackgroundAttr cssAttr
    1              0.000001 hi def link cssBorderAttr cssAttr
    1              0.000001 hi def link cssBoxAttr cssAttr
    1              0.000006 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000007 hi def link cssDimensionAttr cssAttr
    1              0.000001 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000001 hi def link cssFontAttr cssAttr
    1              0.000001 hi def link cssGeneratedContentAttr cssAttr
    1              0.000005 hi def link cssGridAttr cssAttr
    1              0.000005 hi def link cssHyerlinkAttr cssAttr
    1              0.000001 hi def link cssInteractAttr cssAttr
    1              0.000005 hi def link cssLineboxAttr cssAttr
    1              0.000001 hi def link cssListAttr cssAttr
    1              0.000005 hi def link cssMarginAttr cssAttr
    1              0.000005 hi def link cssMarqueeAttr cssAttr
    1              0.000001 hi def link cssMultiColumnAttr cssAttr
    1              0.000005 hi def link cssPaddingAttr cssAttr
    1              0.000005 hi def link cssPagedMediaAttr cssAttr
    1              0.000001 hi def link cssPositioningAttr cssAttr
    1              0.000001 hi def link cssGradientAttr cssAttr
    1              0.000001 hi def link cssPrintAttr cssAttr
    1              0.000005 hi def link cssRubyAttr cssAttr
    1              0.000005 hi def link cssSpeechAttr cssAttr
    1              0.000001 hi def link cssTableAttr cssAttr
    1              0.000001 hi def link cssTextAttr cssAttr
    1              0.000005 hi def link cssTransformAttr cssAttr
    1              0.000001 hi def link cssTransitionAttr cssAttr
    1              0.000001 hi def link cssUIAttr cssAttr
    1              0.000001 hi def link cssIEUIAttr cssAttr
    1              0.000001 hi def link cssAuralAttr cssAttr
    1              0.000005 hi def link cssRenderAttr cssAttr
    1              0.000001 hi def link cssCascadeAttr cssAttr
    1              0.000001 hi def link cssCommonAttr cssAttr
                            
    1              0.000005 hi def link cssPseudoClassId PreProc
    1              0.000009 hi def link cssPseudoClassLang Constant
    1              0.000005 hi def link cssValueLength Number
    1              0.000005 hi def link cssValueInteger Number
    1              0.000005 hi def link cssValueNumber Number
    1              0.000005 hi def link cssValueAngle Number
    1              0.000005 hi def link cssValueTime Number
    1              0.000005 hi def link cssValueFrequency Number
    1              0.000005 hi def link cssFunction Constant
    1              0.000005 hi def link cssURL String
    1              0.000005 hi def link cssFunctionName Function
    1              0.000005 hi def link cssFunctionComma Function
    1              0.000005 hi def link cssColor Constant
    1              0.000005 hi def link cssIdentifier Function
    1              0.000005 hi def link cssAtRule Include
    1              0.000005 hi def link cssAtKeyword PreProc
    1              0.000005 hi def link cssImportant Special
    1              0.000005 hi def link cssCustomProp Special
    1              0.000005 hi def link cssBraces Function
    1              0.000005 hi def link cssBraceError Error
    1              0.000005 hi def link cssError Error
    1              0.000005 hi def link cssUnicodeEscape Special
    1              0.000005 hi def link cssStringQQ String
    1              0.000005 hi def link cssStringQ String
    1              0.000005 hi def link cssAttributeSelector String
    1              0.000005 hi def link cssMediaType Special
    1              0.000009 hi def link cssMediaComma Normal
    1              0.000005 hi def link cssAtRuleLogical Statement
    1              0.000001 hi def link cssMediaProp cssProp
    1              0.000001 hi def link cssMediaAttr cssAttr
    1              0.000004 hi def link cssPagePseudo PreProc
    1              0.000001 hi def link cssPageMarginProp cssAtKeyword
    1              0.000001 hi def link cssPageProp cssProp
    1              0.000005 hi def link cssKeyFrameProp Constant
    1              0.000009 hi def link cssFontDescriptor Special
    1              0.000001 hi def link cssFontDescriptorProp cssProp
    1              0.000001 hi def link cssFontDescriptorAttr cssAttr
    1              0.000009 hi def link cssUnicodeRange Constant
    1              0.000005 hi def link cssClassName Function
    1              0.000005 hi def link cssClassNameDot Function
    1              0.000005 hi def link cssProp StorageClass
    1              0.000005 hi def link cssAttr Constant
    1              0.000034 hi def link cssUnitDecorators Number
    1              0.000108 hi def link cssNoise Noise
                            
    1              0.000004 let b:current_syntax = "css"
                            
    1              0.000003 if main_syntax == 'css'
                              unlet main_syntax
    1              0.000001 endif
                            
    1              0.000016 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/ftplugin/markdown.vim
Sourced 1 time
Total time:   0.019588
 Self time:   0.008193

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Markdown
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:		2019 Dec 05
                            
    1              0.000006 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
    1   0.018967   0.007572 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                            
    1              0.000009 setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=<!--%s-->
    1              0.000007 setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
    1              0.000003 setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:
                            
    1              0.000006 if exists('b:undo_ftplugin')
    1              0.000004   let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
                            else
                              let b:undo_ftplugin = "setl cms< com< fo< flp<"
    1              0.000001 endif
                            
    1              0.000004 function! s:NotCodeBlock(lnum) abort
                              return synIDattr(synID(v:lnum, 1, 1), 'name') !=# 'markdownCode'
                            endfunction
                            
    1              0.000001 function! MarkdownFold() abort
                              let line = getline(v:lnum)
                            
                              if line =~# '^#\+ ' && s:NotCodeBlock(v:lnum)
                                return ">" . match(line, ' ')
                              endif
                            
                              let nextline = getline(v:lnum + 1)
                              if (line =~ '^.\+$') && (nextline =~ '^=\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">1"
                              endif
                            
                              if (line =~ '^.\+$') && (nextline =~ '^-\+$') && s:NotCodeBlock(v:lnum + 1)
                                return ">2"
                              endif
                            
                              return "="
                            endfunction
                            
    1              0.000002 function! s:HashIndent(lnum) abort
                              let hash_header = matchstr(getline(a:lnum), '^#\{1,6}')
                              if len(hash_header)
                                return hash_header
                              else
                                let nextline = getline(a:lnum + 1)
                                if nextline =~# '^=\+\s*$'
                                  return '#'
                                elseif nextline =~# '^-\+\s*$'
                                  return '##'
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! MarkdownFoldText() abort
                              let hash_indent = s:HashIndent(v:foldstart)
                              let title = substitute(getline(v:foldstart), '^#\+\s*', '', '')
                              let foldsize = (v:foldend - v:foldstart + 1)
                              let linecount = '['.foldsize.' lines]'
                              return hash_indent.' '.title.' '.linecount
                            endfunction
                            
    1              0.000005 if has("folding") && exists("g:markdown_folding")
                              setlocal foldexpr=MarkdownFold()
                              setlocal foldmethod=expr
                              setlocal foldtext=MarkdownFoldText()
                              let b:undo_ftplugin .= " foldexpr< foldmethod< foldtext<"
    1              0.000001 endif
                            
                            " vim:set sw=2:

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/ftplugin/html.vim
Sourced 1 time
Total time:   0.011380
 Self time:   0.010293

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    1              0.000007 if exists("b:did_ftplugin") | finish | endif
    1              0.000003 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    1              0.000010 let s:save_cpo = &cpo
    1              0.000012 set cpo-=C
                            
    1              0.000006 setlocal matchpairs+=<:>
    1              0.000003 setlocal commentstring=<!--%s-->
    1              0.000003 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    1              0.000004 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
    1              0.000001 endif
                            
    1              0.000002 if exists('&omnifunc')
    1              0.000003   setlocal omnifunc=htmlcomplete#CompleteTags
    1   0.011247   0.010160   call htmlcomplete#DetectOmniFlavor()
    1              0.000001 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    1              0.000003 if exists("loaded_matchit")
    1              0.000002     let b:match_ignorecase = 1
    1              0.000006     let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    1              0.000001 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    1              0.000004 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
    1              0.000001 endif
                            
                            " Undo the stuff we changed.
    1              0.000004 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    1              0.000009 let &cpo = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/autoload/htmlcomplete.vim
Sourced 1 time
Total time:   0.001023
 Self time:   0.001023

count  total (s)   self (s)
                            " Vim completion script
                            " Language:	HTML and XHTML
                            " Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
                            " Last Change:	2019 Sep 27
                            
                            " Distinguish between HTML versions.
                            " To use with other HTML versions add another "elseif" condition to match
                            " proper DOCTYPE.
    1              0.000005 function! htmlcomplete#DetectOmniFlavor()
                              if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
                                let b:html_omni_flavor = 'html401t'
                              endif
                              let i = 1
                              let line = ""
                              while i < 10 && i < line("$")
                                let line = getline(i)
                                if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
                                let i += 1
                              endwhile
                              if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! htmlcomplete#CompleteTags(findstart, base)
                              if a:findstart
                                " locate the start of the word
                                let line = getline('.')
                                let start = col('.') - 1
                            	let curline = line('.')
                            	let compl_begin = col('.') - 2
                                while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
                            		let start -= 1
                                endwhile
                            	" Handling of entities {{{
                            	if start >= 0 && line[start - 1] =~ '&'
                            		let b:entitiescompl = 1
                            		let b:compl_context = ''
                            		return start
                            	endif
                            	" }}}
                            	" Handling of <style> tag {{{
                            	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
                            	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
                            	if stylestart != 0 && styleend != 0
                            		if stylestart <= curline && styleend >= curline
                            			let start = col('.') - 1
                            			let b:csscompl = 1
                            			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
                            				let start -= 1
                            			endwhile
                            		endif
                            	endif
                            	" }}}
                            	" Handling of <script> tag {{{
                            	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
                            	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
                            	if scriptstart != 0 && scriptend != 0
                            		if scriptstart <= curline && scriptend >= curline
                            			let start = col('.') - 1
                            			let b:jscompl = 1
                            			let b:jsrange = [scriptstart, scriptend]
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            			" We are inside of <script> tag. But we should also get contents
                            			" of all linked external files and (secondary, less probably) other <script> tags
                            			" This logic could possible be done in separate function - may be
                            			" reused in events scripting (also with option could be reused for
                            			" CSS
                            			let b:js_extfiles = []
                            			let l = line('.')
                            			let c = col('.')
                            			call cursor(1,1)
                            			while search('<\@<=script\>', 'W') && line('.') <= l
                            				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            					if filereadable(sname)
                            						let b:js_extfiles += readfile(sname)
                            					endif
                            				endif
                            			endwhile
                            			call cursor(1,1)
                            			let js_scripttags = []
                            			while search('<script\>', 'W') && line('.') < l
                            				if matchstr(getline('.'), '<script[^>]*src') == ''
                            					let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            					let js_scripttags += js_scripttag
                            				endif
                            			endwhile
                            			let b:js_extfiles += js_scripttags
                            			call cursor(l,c)
                            			unlet! l c
                            		endif
                            	endif
                            	" }}}
                            	if !exists("b:csscompl") && !exists("b:jscompl")
                            		let b:compl_context = getline('.')[0:(compl_begin)]
                            		if b:compl_context !~ '<[^>]*$'
                            			" Look like we may have broken tag. Check previous lines.
                            			let i = 1
                            			while 1
                            				let context_line = getline(curline-i)
                            				if context_line =~ '<[^>]*$'
                            					" Yep, this is this line
                            					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
                            					let b:compl_context = join(context_lines, ' ')
                            					break
                            				elseif context_line =~ '>[^<]*$' || i == curline
                            					" We are in normal tag line, no need for completion at all
                            					" OR reached first line without tag at all
                            					let b:compl_context = ''
                            					break
                            				endif
                            				let i += 1
                            			endwhile
                            			" Make sure we don't have counter
                            			unlet! i
                            		endif
                            		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')
                            
                            		" Return proper start for on-events. Without that beginning of
                            		" completion will be badly reported
                            		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            		endif
                            		" If b:compl_context begins with <? we are inside of PHP code. It
                            		" wasn't closed so PHP completion passed it to HTML
                            		if &filetype =~? 'php' && b:compl_context =~ '^<?'
                            			let b:phpcompl = 1
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
                            				let start -= 1
                            			endwhile
                            		endif
                            	else
                            		let b:compl_context = getline('.')[0:compl_begin]
                            	endif
                                return start
                              else
                            	" Initialize base return lists
                                let res = []
                                let res2 = []
                            	" a:base is very short - we need context
                            	let context = b:compl_context
                            	" Check if we should do CSS completion inside of <style> tag
                            	" or JS completion inside of <script> tag or PHP completion in case of <?
                            	" tag AND &ft==php
                            	if exists("b:csscompl")
                            		unlet! b:csscompl
                            		let context = b:compl_context
                            		unlet! b:compl_context
                            		return csscomplete#CompleteCSS(0, context)
                            	elseif exists("b:jscompl")
                            		unlet! b:jscompl
                            		return javascriptcomplete#CompleteJS(0, a:base)
                            	elseif exists("b:phpcompl")
                            		unlet! b:phpcompl
                            		let context = b:compl_context
                            		return phpcomplete#CompletePHP(0, a:base)
                            	else
                            		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
                            			return []
                            		endif
                            		let context = matchstr(b:compl_context, '.\zs.*')
                            	endif
                            	unlet! b:compl_context
                            	" Entities completion {{{
                            	if exists("b:entitiescompl")
                            		unlet! b:entitiescompl
                            
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			"runtime! autoload/xml/xhtml10s.vim
                            			call htmlcomplete#LoadData()
                            		endif
                            
                            	    let entities =  b:html_omni['vimxmlentities']
                            
                            		if len(a:base) == 1
                            			for m in entities
                            				if m =~ '^'.a:base
                            					call add(res, m.';')
                            				endif
                            			endfor
                            			return res
                            		else
                            			for m in entities
                            				if m =~? '^'.a:base
                            					call add(res, m.';')
                            				elseif m =~? a:base
                            					call add(res2, m.';')
                            				endif
                            			endfor
                            
                            			return res + res2
                            		endif
                            
                            
                            	endif
                            	" }}}
                            	if context =~ '>'
                            		" Generally if context contains > it means we are outside of tag and
                            		" should abandon action - with one exception: <style> span { bo
                            		if context =~ 'style[^>]\{-}>[^<]\{-}$'
                            			return csscomplete#CompleteCSS(0, context)
                            		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
                            			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
                            			return javascriptcomplete#CompleteJS(0, context)
                            		else
                            			return []
                            		endif
                            	endif
                            
                            	" If context contains > it means we are already outside of tag and we
                            	" should abandon action
                            	" If context contains white space it is attribute.
                            	" It can be also value of attribute.
                            	" We have to get first word to offer proper completions
                            	if context =~ '^\s*$'
                            		" empty or whitespace line
                            		let tag = ''
                            	else
                            		let tag = split(context)[0]
                            		" Detect if tag is uppercase to return in proper case,
                            		" we need to make it lowercase for processing
                            		if tag =~ '^[A-Z]*$'
                            			let uppercase_tag = 1
                            			let tag = tolower(tag)
                            		else
                            			let uppercase_tag = 0
                            		endif
                            	endif
                            	" Get last word, it should be attr name
                            	let attr = matchstr(context, '.*\s\zs.*')
                            	" Possible situations where any prediction would be difficult:
                            	" 1. Events attributes
                            	if context =~ '\s'
                            		" Sort out style, class, and on* cases
                            		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
                            			" Id, class completion {{{
                            			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "class"
                            				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "id"
                            				endif
                            				" Handle class name completion
                            				" 1. Find lines of <link stylesheet>
                            				" 1a. Check file for @import
                            				" 2. Extract filename(s?) of stylesheet,
                            				call cursor(1,1)
                            				let head = getline(search('<head\>'), search('<\/head>'))
                            				let headjoined = join(copy(head), ' ')
                            				if headjoined =~ '<style'
                            					" Remove possibly confusing CSS operators
                            					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
                            					if search_for == 'class'
                            						let styleheadlines = split(stylehead)
                            						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            					else
                            						let stylesheet = split(headjoined, '[{}]')
                            						" Get all lines which fit id syntax
                            						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            						" Filter out possible color definitions
                            						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            						" Filter out complex border definitions
                            						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            						let templines = join(classlines, ' ')
                            						let headclasslines = split(templines)
                            						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            					endif
                            					let internal = 1
                            				else
                            					let internal = 0
                            				endif
                            				let styletable = []
                            				let secimportfiles = []
                            				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
                            				for line in filestable
                            					if line =~ "@import"
                            						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
                            					elseif line =~ "<link"
                            						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
                            					endif
                            				endfor
                            				for file in styletable
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
                            						if len(secimport) > 0
                            							for line in secimport
                            								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
                            								let secfile = fnamemodify(file, ":p:h").'/'.secfile
                            								let secimportfiles += [secfile]
                            							endfor
                            						endif
                            					endif
                            				endfor
                            				let cssfiles = styletable + secimportfiles
                            				let classes = []
                            				for file in cssfiles
                            				  	let classlines = []
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let stylefile = join(stylesheet, ' ')
                            						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
                            						if search_for == 'class'
                            							let stylesheet = split(stylefile)
                            							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            						else
                            							let stylesheet = split(stylefile, '[{}]')
                            							" Get all lines which fit id syntax
                            							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            							" Filter out possible color definitions
                            							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            							" Filter out complex border definitions
                            							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            							let templines = join(classlines, ' ')
                            							let stylelines = split(templines)
                            							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            
                            						endif
                            					endif
                            					" We gathered classes definitions from all external files
                            					let classes += classlines
                            				endfor
                            				if internal == 1
                            					let classes += headclasslines
                            				endif
                            
                            				if search_for == 'class'
                            					let elements = {}
                            					for element in classes
                            						if element =~ '^\.'
                            							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let class = substitute(class, ':.*', '', '')
                            							if has_key(elements, 'common')
                            								let elements['common'] .= ' '.class
                            							else
                            								let elements['common'] = class
                            							endif
                            						else
                            							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
                            							if tagname != ''
                            								if has_key(elements, tagname)
                            									let elements[tagname] .= ' '.class
                            								else
                            									let elements[tagname] = class
                            								endif
                            							endif
                            						endif
                            					endfor
                            
                            					if has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements[tag]." ".elements['common'])
                            					elseif has_key(elements, tag) && !has_key(elements, 'common')
                            						let values = split(elements[tag])
                            					elseif !has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements['common'])
                            					else
                            						return []
                            					endif
                            
                            				elseif search_for == 'id'
                            					" Find used IDs
                            					" 1. Catch whole file
                            					let filelines = getline(1, line('$'))
                            					" 2. Find lines with possible id
                            					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
                            					" 3a. Join all filtered lines
                            					let id_string = join(used_id_lines, ' ')
                            					" 3b. And split them to be sure each id is in separate item
                            					let id_list = split(id_string, 'id\s*=\s*')
                            					" 4. Extract id values
                            					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
                            					let joined_used_id = ','.join(used_id, ',').','
                            
                            					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')
                            
                            					let values = []
                            
                            					for element in classes
                            						if joined_used_id !~ ','.element.','
                            							let values += [element]
                            						endif
                            
                            					endfor
                            
                            				endif
                            
                            				" We need special version of sbase
                            				let classbase = matchstr(context, ".*[\"']")
                            				let classquote = matchstr(classbase, '.$')
                            
                            				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")
                            
                            				for m in sort(values)
                            					if m =~? '^'.entered_class
                            						call add(res, m . classquote)
                            					elseif m =~? entered_class
                            						call add(res2, m . classquote)
                            					endif
                            				endfor
                            
                            				return res + res2
                            
                            			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
                            				return csscomplete#CompleteCSS(0, context)
                            
                            			endif
                            			" }}}
                            			" Complete on-events {{{
                            			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            				" We have to:
                            				" 1. Find external files
                            				let b:js_extfiles = []
                            				let l = line('.')
                            				let c = col('.')
                            				call cursor(1,1)
                            				while search('<\@<=script\>', 'W') && line('.') <= l
                            					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            						if filereadable(sname)
                            							let b:js_extfiles += readfile(sname)
                            						endif
                            					endif
                            				endwhile
                            				" 2. Find at least one <script> tag
                            				call cursor(1,1)
                            				let js_scripttags = []
                            				while search('<script\>', 'W') && line('.') < l
                            					if matchstr(getline('.'), '<script[^>]*src') == ''
                            						let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            						let js_scripttags += js_scripttag
                            					endif
                            				endwhile
                            				let b:js_extfiles += js_scripttags
                            
                            				" 3. Proper call for javascriptcomplete#CompleteJS
                            				call cursor(l,c)
                            				let js_context = matchstr(a:base, '\k\+$')
                            				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
                            				let b:compl_context = context
                            				let b:jsrange = [l, l]
                            				unlet! l c
                            				return javascriptcomplete#CompleteJS(0, js_context)
                            
                            			endif
                            
                            			" }}}
                            			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
                            			" Now we have context stripped from all chars up to style/class.
                            			" It may fail with some strange style value combinations.
                            			if stripbase !~ "[\"']"
                            				return []
                            			endif
                            		endif
                            		" Value of attribute completion {{{
                            		" If attr contains =\s*[\"'] we catched value of attribute
                            		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
                            			" Let do attribute specific completion
                            			let attrname = matchstr(attr, '.*\ze\s*=')
                            			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
                            			let values = []
                            			" Load data {{{
                            			if !exists("b:html_doctype")
                            				call htmlcomplete#CheckDoctype()
                            			endif
                            			if !exists("b:html_omni")
                            				"runtime! autoload/xml/xhtml10s.vim
                            				call htmlcomplete#LoadData()
                            			endif
                            			" }}}
                            			if attrname == 'href'
                            				" Now we are looking for local anchors defined by name or id
                            				if entered_value =~ '^#'
                            					let file = join(getline(1, line('$')), ' ')
                            					" Split it be sure there will be one id/name element in
                            					" item, it will be also first word [a-zA-Z0-9_-] in element
                            					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
                            					for i in oneelement
                            						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
                            					endfor
                            				endif
                            			else
                            				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
                            					let values = b:html_omni[tag][1][attrname]
                            				else
                            					return []
                            				endif
                            			endif
                            
                            			if len(values) == 0
                            				return []
                            			endif
                            
                            			" We need special version of sbase
                            			let attrbase = matchstr(context, ".*[\"']")
                            			let attrquote = matchstr(attrbase, '.$')
                            			if attrquote !~ "['\"]"
                            				let attrquoteopen = '"'
                            				let attrquote = '"'
                            			else
                            				let attrquoteopen = ''
                            			endif
                            
                            			for m in values
                            				" This if is needed to not offer all completions as-is
                            				" alphabetically but sort them. Those beginning with entered
                            				" part will be as first choices
                            				if m =~ '^'.entered_value
                            					call add(res, attrquoteopen . m . attrquote)
                            				elseif m =~ entered_value
                            					call add(res2, attrquoteopen . m . attrquote)
                            				endif
                            			endfor
                            
                            			return res + res2
                            
                            		endif
                            		" }}}
                            		" Attribute completion {{{
                            		" Shorten context to not include last word
                            		let sbase = matchstr(context, '.*\ze\s.*')
                            
                            		" Load data {{{
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			call htmlcomplete#LoadData()
                            		endif
                            		" }}}
                            
                            		if has_key(b:html_omni, tag)
                            			let attrs = keys(b:html_omni[tag][1])
                            		else
                            			return []
                            		endif
                            
                            		for m in sort(attrs)
                            			if m =~ '^'.attr
                            				call add(res, m)
                            			elseif m =~ attr
                            				call add(res2, m)
                            			endif
                            		endfor
                            		let menu = res + res2
                            		if has_key(b:html_omni, 'vimxmlattrinfo')
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if has_key(b:html_omni['vimxmlattrinfo'], item)
                            					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
                            					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
                            				else
                            					let m_menu = ''
                            					let m_info = ''
                            				endif
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            					let m_menu = 'Bool'
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
                            			endfor
                            		else
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [item]
                            			endfor
                            			return final_menu
                            
                            		endif
                            		return final_menu
                            
                            	endif
                            	" }}}
                            	" Close tag {{{
                            	let b:unaryTagsStack = "base meta link hr br param img area input col"
                            	if context =~ '^\/'
                            		if context =~ '^\/.'
                            			return []
                            		else
                            			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
                            			return [opentag.">"]
                            		endif
                            	endif
                            	" }}}
                            	" Load data {{{
                            	if !exists("b:html_doctype")
                            		call htmlcomplete#CheckDoctype()
                            	endif
                            	if !exists("b:html_omni")
                            		"runtime! autoload/xml/xhtml10s.vim
                            		call htmlcomplete#LoadData()
                            	endif
                            	" }}}
                            	" Tag completion {{{
                            	" Deal with tag completion.
                            	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
                            	" MM: TODO: GLOT works always the same but with some weird situation it
                            	" behaves as intended in HTML but screws in PHP
                            	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
                            		" Hack for sometimes failing GetLastOpenTag.
                            		" As far as I tested fail isn't GLOT fault but problem
                            		" of invalid document - not properly closed tags and other mish-mash.
                            		" Also when document is empty. Return list of *all* tags.
                            	    let tags = keys(b:html_omni)
                            		call filter(tags, 'v:val !~ "^vimxml"')
                            	else
                            		if has_key(b:html_omni, opentag)
                            			let tags = b:html_omni[opentag][0]
                            		else
                            			return []
                            		endif
                            	endif
                            	" }}}
                            
                            	if exists("uppercase_tag") && uppercase_tag == 1
                            		let context = tolower(context)
                            	endif
                            	" Handle XML keywords: DOCTYPE
                            	if opentag == ''
                            		let tags += [
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">'
                            				\ ]
                            	endif
                            
                            	for m in sort(tags)
                            		if m =~ '^'.context
                            			call add(res, m)
                            		elseif m =~ context
                            			call add(res2, m)
                            		endif
                            	endfor
                            	let menu = res + res2
                            	if has_key(b:html_omni, 'vimxmltaginfo')
                            		let final_menu = []
                            		for i in range(len(menu))
                            			let item = menu[i]
                            			if has_key(b:html_omni['vimxmltaginfo'], item)
                            				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
                            				let m_info = b:html_omni['vimxmltaginfo'][item][1]
                            			else
                            				let m_menu = ''
                            				let m_info = ''
                            			endif
                            			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
                            				let item = toupper(item)
                            			endif
                            			if item =~ 'DOCTYPE'
                            				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
                            			else
                            				let abbr = item
                            			endif
                            			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
                            		endfor
                            	else
                            		let final_menu = menu
                            	endif
                            	return final_menu
                            
                            	" }}}
                              endif
                            endfunction
                            
    1              0.000002 function! htmlcomplete#LoadData() " {{{
                            	if !exists("b:html_omni_flavor")
                            		if &filetype == 'html'
                            			let b:html_omni_flavor = 'html401t'
                            		else
                            			let b:html_omni_flavor = 'xhtml10s'
                            		endif
                            	endif
                            	" With that if we still have bloated memory but create new buffer
                            	" variables only by linking to existing g:variable, not sourcing whole
                            	" file.
                            	if exists('g:xmldata_'.b:html_omni_flavor)
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	else
                            		exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	endif
                            endfunction
                            " }}}
    1              0.000001 function! htmlcomplete#CheckDoctype() " {{{
                            	if exists('b:html_omni_flavor')
                            		let old_flavor = b:html_omni_flavor
                            	else
                            		let old_flavor = ''
                            	endif
                            	let i = 1
                            	while i < 10 && i < line("$")
                            		let line = getline(i)
                            		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
                            			let b:html_omni_flavor = 'html32'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
                            			let b:html_omni_flavor = 'html40t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
                            			let b:html_omni_flavor = 'html40f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
                            			let b:html_omni_flavor = 'html40s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
                            			let b:html_omni_flavor = 'html401t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
                            			let b:html_omni_flavor = 'html401f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
                            			let b:html_omni_flavor = 'html401s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
                            			let b:html_omni_flavor = 'xhtml10t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
                            			let b:html_omni_flavor = 'xhtml10f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
                            			let b:html_omni_flavor = 'xhtml10s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
                            			let b:html_omni_flavor = 'xhtml11'
                            			let b:html_doctype = 1
                            			break
                            		endif
                            		let i += 1
                            	endwhile
                            	if !exists("b:html_doctype")
                            		return
                            	else
                            		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
                            		" once, not every time per buffer.
                            		if old_flavor == b:html_omni_flavor
                            			return
                            		else
                            			if exists('g:xmldata_'.b:html_omni_flavor)
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			else
                            				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			endif
                            			return
                            		endif
                            	endif
                            endfunction
                            " }}}
                            " vim:set foldmethod=marker:

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim
Sourced 1 time
Total time:   0.010781
 Self time:   0.010730

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2021 Bailey Ling et al.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000003 scriptencoding utf-8
                            
    1              0.000004 function! airline#extensions#wordcount#formatters#default#update_fmt(...)
                              let s:fmt = get(g:, 'airline#extensions#wordcount#formatter#default#fmt', '%s words')
                              let s:fmt_short = get(g:, 'airline#extensions#wordcount#formatter#default#fmt_short', s:fmt == '%s words' ? '%sW' : s:fmt)
                            endfunction
                            
                            " Reload format when statusline is rebuilt
    1   0.000033   0.000019 call airline#extensions#wordcount#formatters#default#update_fmt()
                            
    1              0.000006 if index(g:airline_statusline_funcrefs, function('airline#extensions#wordcount#formatters#default#update_fmt')) == -1
                              " only add it, if not already done
    1   0.000046   0.000009   call airline#add_statusline_funcref(function('airline#extensions#wordcount#formatters#default#update_fmt'))
    1              0.000001 endif
                            
    1              0.000010 if match(get(v:, 'lang', ''), '\v\cC|en') > -1
    1              0.000002   let s:decimal_group = ','
                            elseif match(get(v:, 'lang', ''), '\v\cde|dk|fr|pt') > -1
                              let s:decimal_group = '.'
                            else
                              let s:decimal_group = ''
    1              0.000001 endif
                            
    1              0.000003 function! airline#extensions#wordcount#formatters#default#to_string(wordcount)
                              if airline#util#winwidth() > 85
                                if a:wordcount > 999
                                  " Format number according to locale, e.g. German: 1.245 or English: 1,245
                                  let wordcount = substitute(a:wordcount, '\d\@<=\(\(\d\{3\}\)\+\)$', s:decimal_group.'&', 'g')
                                else
                                  let wordcount = a:wordcount
                                endif
                                let str = printf(s:fmt, wordcount)
                              else
                                let str = printf(s:fmt_short, a:wordcount)
                              endif
                            
                              let str .= g:airline_symbols.space
                            
                              if !empty(g:airline_right_alt_sep)
                                let str .= g:airline_right_alt_sep . g:airline_symbols.space
                              endif
                            
                              return str
                            endfunction

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/alex.vim
Sourced 2 times
Total time:   0.038970
 Self time:   0.028688

count  total (s)   self (s)
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: alex for markdown files
                            
    2   0.015192   0.004911 call ale#handlers#alex#DefineLinter('markdown', '')

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/alex.vim
Sourced 1 time
Total time:   0.009548
 Self time:   0.009548

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: Error handling for errors in alex output format
                            
    1              0.000005 function! ale#handlers#alex#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer, 'alex', [
                                \   'node_modules/.bin/alex',
                                \   'node_modules/alex/cli.js',
                                \])
                            endfunction
                            
    1              0.000002 function! ale#handlers#alex#CreateCommandCallback(flags) abort
                                return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))
                                \            . ' %s '
                                \            . a:flags}
                            endfunction
                            
    1              0.000002 function! ale#handlers#alex#Handle(buffer, lines) abort
                                " Example output:
                                "       6:256-6:262  warning  Be careful with “killed”, it’s profane in some cases      killed           retext-profanities
                                let l:pattern = '\v^ *(\d+):(\d+)-(\d+):(\d+) +warning +(.{-})  +(.{-})  +(.{-})$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'end_lnum': l:match[3] + 0,
                                    \   'end_col': l:match[4] - 1,
                                    \   'text': l:match[5] . ' (' . (l:match[7]) . ')',
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define a linter for a specific filetype. Accept flags to adapt to the filetype.
                            "    no flags  treat input as markdown
                            "    --html    treat input as HTML
                            "    --text    treat input as plaintext
    1              0.000002 function! ale#handlers#alex#DefineLinter(filetype, flags) abort
                                call ale#Set('alex_executable', 'alex')
                                call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'alex',
                                \   'executable': function('ale#handlers#alex#GetExecutable'),
                                \   'command': ale#handlers#alex#CreateCommandCallback(a:flags),
                                \   'output_stream': 'stderr',
                                \   'callback': 'ale#handlers#alex#Handle',
                                \   'lint_file': 1,
                                \})
                            endfunction

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/languagetool.vim
Sourced 2 times
Total time:   0.023017
 Self time:   0.011944

count  total (s)   self (s)
                            " Author: Vincent (wahrwolf [at] wolfpit.net)
                            " Description: languagetool for markdown files
                            
                            
    2   0.012700   0.001627 call ale#handlers#languagetool#DefineLinter('markdown')

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/languagetool.vim
Sourced 1 time
Total time:   0.010547
 Self time:   0.010487

count  total (s)   self (s)
                            " Author: Vincent (wahrwolf [at] wolfpit.net)
                            " Description: languagetool for markdown files
                            "
    1   0.000065   0.000018 call ale#Set('languagetool_executable', 'languagetool')
    1   0.000023   0.000009 call ale#Set('languagetool_options', '--autoDetect')
                            
    1              0.000005 function! ale#handlers#languagetool#GetExecutable(buffer) abort
                                return ale#Var(a:buffer, 'languagetool_executable')
                            endfunction
                            
    1              0.000003 function! ale#handlers#languagetool#GetCommand(buffer) abort
                                let l:executable = ale#handlers#languagetool#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'languagetool_options')
                            
                                return ale#Escape(l:executable)
                                \ . (empty(l:options) ? '' : ' ' . l:options) . ' %s'
                            endfunction
                            
    1              0.000003 function! ale#handlers#languagetool#HandleOutput(buffer, lines) abort
                                " Match lines like:
                                " 1.) Line 5, column 1, Rule ID:
                                let l:head_pattern = '^\v.+.\) Line (\d+), column (\d+), Rule ID. (.+)$'
                                let l:head_matches = ale#util#GetMatches(a:lines, l:head_pattern)
                            
                                " Match lines like:
                                " Message: Did you forget a comma after a conjunctive/linking adverb?
                                let l:message_pattern = '^\vMessage. (.+)$'
                                let l:message_matches = ale#util#GetMatches(a:lines, l:message_pattern)
                            
                                " Match lines like:
                                "   ^^^^^ "
                                let l:markers_pattern = '^\v *(\^+) *$'
                                let l:markers_matches = ale#util#GetMatches(a:lines, l:markers_pattern)
                            
                                let l:output = []
                            
                            
                                " Okay tbh I was to lazy to figure out a smarter solution here
                                " We just check that the arrays are same sized and merge everything
                                " together
                                let l:i = 0
                            
                                while l:i < len(l:head_matches)
                                \   && (
                                \       (len(l:head_matches) == len(l:markers_matches))
                                \       && (len(l:head_matches) == len(l:message_matches))
                                \   )
                                    let l:item = {
                                    \   'lnum'    : str2nr(l:head_matches[l:i][1]),
                                    \   'col'     : str2nr(l:head_matches[l:i][2]),
                                    \   'end_col' : str2nr(l:head_matches[l:i][2]) + len(l:markers_matches[l:i][1])-1,
                                    \   'type'    : 'W',
                                    \   'code'    : l:head_matches[l:i][3],
                                    \   'text'    : l:message_matches[l:i][1]
                                    \}
                                    call add(l:output, l:item)
                                    let l:i+=1
                                endwhile
                            
                                return l:output
                            endfunction
                            
                            " Define the languagetool linter for a given filetype.
                            " TODO:
                            " - Add language detection settings based on user env (for mothertongue)
                            " - Add fixer
                            " - Add config options for rules
    1              0.000002 function! ale#handlers#languagetool#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'languagetool',
                                \   'executable': function('ale#handlers#languagetool#GetExecutable'),
                                \   'command': function('ale#handlers#languagetool#GetCommand'),
                                \   'output_stream': 'stdout',
                                \   'callback': 'ale#handlers#languagetool#HandleOutput',
                                \   'lint_file': 1,
                                \})
                            endfunction

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/markdownlint.vim
Sourced 2 times
Total time:   0.013245
 Self time:   0.012763

count  total (s)   self (s)
                            " Author: Ty-Lucas Kelley <tylucaskelley@gmail.com>
                            " Description: Adds support for markdownlint
                            
    2   0.000044   0.000021 call ale#Set('markdown_markdownlint_options', '')
                            
    2              0.000006 function! ale_linters#markdown#markdownlint#GetCommand(buffer) abort
                                let l:executable = 'markdownlint'
                            
                                let l:options = ale#Var(a:buffer, 'markdown_markdownlint_options')
                            
                                return ale#Escape(l:executable)
                                \ . (!empty(l:options) ? ' ' . l:options : '') . ' %s'
                            endfunction
                            
    2   0.000497   0.000037 call ale#linter#Define('markdown', {
                            \   'name': 'markdownlint',
                            \   'executable': 'markdownlint',
                            \   'lint_file': 1,
                            \   'output_stream': 'both',
                            \   'command': function('ale_linters#markdown#markdownlint#GetCommand'),
                            \   'callback': 'ale#handlers#markdownlint#Handle'
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/mdl.vim
Sourced 2 times
Total time:   0.008538
 Self time:   0.008007

count  total (s)   self (s)
                            " Author: Steve Dignam <steve@dignam.xyz>, Josh Leeb-du Toit <joshleeb.com>
                            " Description: Support for mdl, a markdown linter.
                            
    2   0.000069   0.000045 call ale#Set('markdown_mdl_executable', 'mdl')
    2   0.000023   0.000009 call ale#Set('markdown_mdl_options', '')
                            
    2              0.000006 function! ale_linters#markdown#mdl#GetExecutable(buffer) abort
                                return ale#Var(a:buffer, 'markdown_mdl_executable')
                            endfunction
                            
    2              0.000004 function! ale_linters#markdown#mdl#GetCommand(buffer) abort
                                let l:executable = ale_linters#markdown#mdl#GetExecutable(a:buffer)
                                let l:exec_args = l:executable =~? 'bundle$'
                                \   ? ' exec mdl'
                                \   : ''
                            
                                let l:options = ale#Var(a:buffer, 'markdown_mdl_options')
                            
                                return ale#Escape(l:executable) . l:exec_args
                                \   . ' -j' . (!empty(l:options) ? ' ' . l:options : '')
                            endfunction
                            
    2              0.000004 function! ale_linters#markdown#mdl#Handle(buffer, lines) abort
                                let l:output = []
                            
                                for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
                                    call add(l:output, {
                                    \   'lnum': l:error['line'],
                                    \   'code': l:error['rule']  . '/' . join(l:error['aliases'], '/'),
                                    \   'text': l:error['description'],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    2   0.000529   0.000036 call ale#linter#Define('markdown', {
                            \   'name': 'mdl',
                            \   'executable': function('ale_linters#markdown#mdl#GetExecutable'),
                            \   'command': function('ale_linters#markdown#mdl#GetCommand'),
                            \   'callback': 'ale_linters#markdown#mdl#Handle'
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/proselint.vim
Sourced 2 times
Total time:   0.024088
 Self time:   0.023647

count  total (s)   self (s)
                            " Author: poohzrn https://github.com/poohzrn
                            " Description: proselint for Markdown files
                            
    2   0.000483   0.000042 call ale#linter#Define('markdown', {
                            \   'name': 'proselint',
                            \   'executable': 'proselint',
                            \   'command': 'proselint %t',
                            \   'callback': 'ale#handlers#unix#HandleAsWarning',
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/redpen.vim
Sourced 2 times
Total time:   0.021190
 Self time:   0.020755

count  total (s)   self (s)
                            " Author: rhysd https://rhysd.github.io
                            " Description: Redpen, a proofreading tool (http://redpen.cc)
                            
    2   0.000474   0.000039 call ale#linter#Define('markdown', {
                            \   'name': 'redpen',
                            \   'executable': 'redpen',
                            \   'command': 'redpen -f markdown -r json %t',
                            \   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/remark_lint.vim
Sourced 2 times
Total time:   0.016241
 Self time:   0.015723

count  total (s)   self (s)
    2              0.000011 scriptencoding utf-8
                            " Author rhysd https://rhysd.github.io/, Dirk Roorda (dirkroorda), Adrián González Rus (@adrigzr)
                            " Description: remark-lint for Markdown files
    2   0.000044   0.000020 call ale#Set('markdown_remark_lint_executable', 'remark')
    2   0.000028   0.000014 call ale#Set('markdown_remark_lint_use_global', get(g:, 'ale_use_global_executables', 0))
    2   0.000021   0.000008 call ale#Set('markdown_remark_lint_options', '')
                            
    2              0.000006 function! ale_linters#markdown#remark_lint#GetCommand(buffer) abort
                                let l:options = ale#Var(a:buffer, 'markdown_remark_lint_options')
                            
                                return '%e' . ale#Pad(l:options) . ' --no-stdout --no-color'
                            endfunction
                            
    2              0.000004 function! ale_linters#markdown#remark_lint#Handle(buffer, lines) abort
                                " matches: '  1:4  warning  Incorrect list-item indent: add 1 space  list-item-indent  remark-lint'
                                " matches: '  18:71-19:1  error  Missing new line after list item  list-item-spacing  remark-lint',
                                let l:pattern = '^ \+\(\d\+\):\(\d\+\)\(-\(\d\+\):\(\d\+\)\)\?  \(warning\|error\)  \(.\+\)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    let l:item = {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'type': l:match[6] is# 'error' ? 'E' : 'W',
                                    \   'text': l:match[7],
                                    \}
                            
                                    if l:match[3] isnot# ''
                                        let l:item.end_lnum = l:match[4] + 0
                                        let l:item.end_col = l:match[5] + 0
                                    endif
                            
                                    call add(l:output, l:item)
                                endfor
                            
                                return l:output
                            endfunction
                            
    2   0.000518   0.000051 call ale#linter#Define('markdown', {
                            \   'name': 'remark_lint',
                            \   'aliases': ['remark-lint'],
                            \   'executable': {b -> ale#path#FindExecutable(b, 'markdown_remark_lint', [
                            \       'node_modules/.bin/remark',
                            \   ])},
                            \   'command': function('ale_linters#markdown#remark_lint#GetCommand'),
                            \   'callback': 'ale_linters#markdown#remark_lint#Handle',
                            \   'output_stream': 'stderr',
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/textlint.vim
Sourced 2 times
Total time:   0.011518
 Self time:   0.011055

count  total (s)   self (s)
                            " Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
                            " Description: textlint, a proofreading tool (https://textlint.github.io/)
                            
    2   0.000509   0.000046 call ale#linter#Define('markdown', {
                            \   'name': 'textlint',
                            \   'executable': function('ale#handlers#textlint#GetExecutable'),
                            \   'command': function('ale#handlers#textlint#GetCommand'),
                            \   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/vale.vim
Sourced 2 times
Total time:   0.010052
 Self time:   0.009573

count  total (s)   self (s)
                            " Author: chew-z https://github.com/chew-z
                            " Description: vale for Markdown files
                            
    2   0.000042   0.000021 call ale#Set('markdown_vale_executable', 'vale')
    2   0.000023   0.000009 call ale#Set('markdown_vale_input_file', '%t')
    2   0.000021   0.000008 call ale#Set('markdown_vale_options', '')
                            
    2              0.000006 function! ale_linters#markdown#vale#GetCommand(buffer) abort
                                let l:executable = ale#Var(a:buffer, 'markdown_vale_executable')
                                let l:input_file = ale#Var(a:buffer, 'markdown_vale_input_file')
                            
                                " Defaults to `vale --output=JSON %t`
                                return ale#Escape(l:executable)
                                \   . ' --output=JSON '
                                \   . ale#Var(a:buffer, 'markdown_vale_options')
                                \   . ' ' . l:input_file
                            endfunction
                            
    2   0.000470   0.000039 call ale#linter#Define('markdown', {
                            \   'name': 'vale',
                            \   'executable': {b -> ale#Var(b, 'markdown_vale_executable')},
                            \   'command': function('ale_linters#markdown#vale#GetCommand'),
                            \   'callback': 'ale#handlers#vale#Handle',
                            \})

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/writegood.vim
Sourced 2 times
Total time:   0.023552
 Self time:   0.015091

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: write-good for Markdown files
                            
    2   0.010901   0.002439 call ale#handlers#writegood#DefineLinter('markdown')

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/writegood.vim
Sourced 1 time
Total time:   0.007948
 Self time:   0.007883

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: Error handling for errors in the write-good format.
                            
    1              0.000005 function! ale#handlers#writegood#ResetOptions() abort
                                call ale#Set('writegood_options', '')
                                call ale#Set('writegood_executable', 'write-good')
                                call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))
                            endfunction
                            
                            " Reset the options so the tests can test how they are set.
    1   0.000078   0.000013 call ale#handlers#writegood#ResetOptions()
                            
    1              0.000003 function! ale#handlers#writegood#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer, 'writegood', [
                                \   'node_modules/.bin/write-good',
                                \   'node_modules/write-good/bin/write-good.js',
                                \])
                            endfunction
                            
    1              0.000002 function! ale#handlers#writegood#GetCommand(buffer) abort
                                let l:executable = ale#handlers#writegood#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'writegood_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' %t'
                            endfunction
                            
    1              0.000002 function! ale#handlers#writegood#Handle(buffer, lines) abort
                                " Look for lines like the following.
                                "
                                " "it is" is wordy or unneeded on line 20 at column 53
                                " "easily" can weaken meaning on line 154 at column 29
                                let l:marks_pattern = '\v^ *(\^+) *$'
                                let l:pattern = '\v^(".*"\s.*)\son\sline\s(\d+)\sat\scolumn\s(\d+)$'
                                let l:output = []
                                let l:last_len = 0
                            
                                for l:match in ale#util#GetMatches(a:lines, [l:marks_pattern, l:pattern])
                                    if empty(l:match[2])
                                        let l:last_len = len(l:match[1])
                                    else
                                        let l:col = l:match[3] + 1
                            
                                        " Add the linter error. Note that we need to add 1 to the col because
                                        " write-good reports the column corresponding to the space before the
                                        " offending word or phrase.
                                        call add(l:output, {
                                        \   'text': l:match[1],
                                        \   'lnum': l:match[2] + 0,
                                        \   'col': l:col,
                                        \   'end_col': l:last_len ? (l:col + l:last_len - 1) : l:col,
                                        \   'type': 'W',
                                        \})
                            
                                        let l:last_len = 0
                                    endif
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define the writegood linter for a given filetype.
    1              0.000002 function! ale#handlers#writegood#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'writegood',
                                \   'aliases': ['write-good'],
                                \   'executable': function('ale#handlers#writegood#GetExecutable'),
                                \   'command': function('ale#handlers#writegood#GetCommand'),
                                \   'callback': 'ale#handlers#writegood#Handle',
                                \})
                            endfunction

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim
Sourced 1 time
Total time:   0.000234
 Self time:   0.000187

count  total (s)   self (s)
                            " Author: w0rp <devw0rp@gmail.com>
                            " Description: Functions for working with paths in the filesystem.
                            
                            " simplify a path, and fix annoying issues with paths on Windows.
                            "
                            " Forward slashes are changed to back slashes so path equality works better
                            " on Windows. Back slashes are changed to forward slashes on Unix.
                            "
                            " Unix paths can technically contain back slashes, but in practice no path
                            " should, and replacing back slashes with forward slashes makes linters work
                            " in environments like MSYS.
                            "
                            " Paths starting with more than one forward slash are changed to only one
                            " forward slash, to prevent the paths being treated as special MSYS paths.
    1              0.000004 function! ale#path#Simplify(path) abort
                                if has('unix')
                                    let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
                                    return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks
                            endfunction
                            
                            " Simplify a path without a Windows drive letter.
                            " This function can be used for checking if paths are equal.
    1              0.000002 function! ale#path#RemoveDriveLetter(path) abort
                                return has('win32') && a:path[1:2] is# ':\'
                                \   ? ale#path#Simplify(a:path[2:])
                                \   : ale#path#Simplify(a:path)
                            endfunction
                            
                            " Given a buffer and a filename, find the nearest file by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000002 function! ale#path#FindNearestFile(buffer, filename) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer and a directory name, find the nearest directory by searching upwards
                            " through the paths relative to the given buffer.
    1              0.000002 function! ale#path#FindNearestDirectory(buffer, directory_name) abort
                                let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
                                let l:buffer_filename = fnameescape(l:buffer_filename)
                            
                                let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
                                if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''
                            endfunction
                            
                            " Given a buffer, a string to search for, and a global fallback for when
                            " the search fails, look for a file in parent paths, and if that fails,
                            " use the global fallback path instead.
    1              0.000002 function! ale#path#ResolveLocalPath(buffer, search_string, global_fallback) abort
                                " Search for a locally installed file first.
                                let l:path = ale#path#FindNearestFile(a:buffer, a:search_string)
                            
                                " If the search fails, try the global executable instead.
                                if empty(l:path)
                                    let l:path = a:global_fallback
                                endif
                            
                                return l:path
                            endfunction
                            
                            " Given a buffer number, a base variable name, and a list of paths to search
                            " for in ancestor directories, detect the executable path for a program.
    1              0.000002 function! ale#path#FindNearestExecutable(buffer, path_list) abort
                                for l:path in a:path_list
                                    if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
                                    else
                                        let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                                    endif
                            
                                    if !empty(l:executable)
                                        return l:executable
                                    endif
                                endfor
                            
                                return ''
                            endfunction
                            
                            " Given a buffer number, a base variable name, and a list of paths to search
                            " for in ancestor directories, detect the executable path for a program.
                            "
                            " The use_global and executable options for the relevant program will be used.
    1              0.000002 function! ale#path#FindExecutable(buffer, base_var_name, path_list) abort
                                if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
                                let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
                                if !empty(l:nearest)
                                    return l:nearest
                                endif
                            
                                return ale#Var(a:buffer, a:base_var_name . '_executable')
                            endfunction
                            
                            " Return 1 if a path is an absolute path.
    1              0.000002 function! ale#path#IsAbsolute(filename) abort
                                if has('win32') && a:filename[:0] is# '\'
                                    return 1
                                endif
                            
                                " Check for /foo and C:\foo, etc.
                                return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'
                            endfunction
                            
    1   0.000064   0.000018 let s:temp_dir = ale#path#Simplify(fnamemodify(ale#util#Tempname(), ':h:h'))
                            
                            " Given a filename, return 1 if the file represents some temporary file
                            " created by Vim.
    1              0.000002 function! ale#path#IsTempName(filename) abort
                                return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir
                            endfunction
                            
                            " Given a base directory, which must not have a trailing slash, and a
                            " filename, which may have an absolute path a path relative to the base
                            " directory, return the absolute path to the file.
    1              0.000001 function! ale#path#GetAbsPath(base_directory, filename) abort
                                if ale#path#IsAbsolute(a:filename)
                                    return ale#path#Simplify(a:filename)
                                endif
                            
                                let l:sep = has('win32') ? '\' : '/'
                            
                                return ale#path#Simplify(a:base_directory . l:sep . a:filename)
                            endfunction
                            
                            " Given a path, return the directory name for that path, with no trailing
                            " slashes. If the argument is empty(), return an empty string.
    1              0.000001 function! ale#path#Dirname(path) abort
                                if empty(a:path)
                                    return ''
                                endif
                            
                                " For /foo/bar/ we need :h:h to get /foo
                                if a:path[-1:] is# '/' || (has('win32') && a:path[-1:] is# '\')
                                    return fnamemodify(a:path, ':h:h')
                                endif
                            
                                return fnamemodify(a:path, ':h')
                            endfunction
                            
                            " Given a buffer number and a relative or absolute path, return 1 if the
                            " two paths represent the same file on disk.
    1              0.000002 function! ale#path#IsBufferPath(buffer, complex_filename) abort
                                " If the path is one of many different names for stdin, we have a match.
                                if a:complex_filename is# '-'
                                \|| a:complex_filename is# 'stdin'
                                \|| a:complex_filename[:0] is# '<'
                                    return 1
                                endif
                            
                                let l:test_filename = ale#path#Simplify(a:complex_filename)
                            
                                if l:test_filename[:1] is# './'
                                    let l:test_filename = l:test_filename[2:]
                                endif
                            
                                if l:test_filename[:1] is# '..'
                                    " Remove ../../ etc. from the front of the path.
                                    let l:test_filename = substitute(l:test_filename, '\v^(\.\.[/\\])+', '/', '')
                                endif
                            
                                " Use the basename for temporary files, as they are likely our files.
                                if ale#path#IsTempName(l:test_filename)
                                    let l:test_filename = fnamemodify(l:test_filename, ':t')
                                endif
                            
                                let l:buffer_filename = expand('#' . a:buffer . ':p')
                            
                                return l:buffer_filename is# l:test_filename
                                \   || l:buffer_filename[-len(l:test_filename):] is# l:test_filename
                            endfunction
                            
                            " Given a path, return every component of the path, moving upwards.
    1              0.000001 function! ale#path#Upwards(path) abort
                                let l:pattern = has('win32') ? '\v/+|\\+' : '\v/+'
                                let l:sep = has('win32') ? '\' : '/'
                                let l:parts = split(ale#path#Simplify(a:path), l:pattern)
                                let l:path_list = []
                            
                                while !empty(l:parts)
                                    call add(l:path_list, join(l:parts, l:sep))
                                    let l:parts = l:parts[:-2]
                                endwhile
                            
                                if has('win32') && a:path =~# '^[a-zA-z]:\'
                                    " Add \ to C: for C:\, etc.
                                    let l:path_list[-1] .= '\'
                                elseif a:path[0] is# '/'
                                    " If the path starts with /, even on Windows, add / and / to all paths.
                                    call map(l:path_list, '''/'' . v:val')
                                    call add(l:path_list, '/')
                                endif
                            
                                return l:path_list
                            endfunction
                            
                            " Convert a filesystem path to a file:// URI
                            " relatives paths will not be prefixed with the protocol.
                            " For Windows paths, the `:` in C:\ etc. will not be percent-encoded.
    1              0.000001 function! ale#path#ToURI(path) abort
                                let l:has_drive_letter = a:path[1:2] is# ':\'
                            
                                return substitute(
                                \   ((l:has_drive_letter || a:path[:0] is# '/') ? 'file://' : '')
                                \       . (l:has_drive_letter ? '/' . a:path[:2] : '')
                                \       . ale#uri#Encode(l:has_drive_letter ? a:path[3:] : a:path),
                                \   '\\',
                                \   '/',
                                \   'g',
                                \)
                            endfunction
                            
    1              0.000001 function! ale#path#FromURI(uri) abort
                                if a:uri[:6] is? 'file://'
                                    let l:encoded_path = a:uri[7:]
                                elseif a:uri[:4] is? 'file:'
                                    let l:encoded_path = a:uri[5:]
                                else
                                    let l:encoded_path = a:uri
                                endif
                            
                                let l:path = ale#uri#Decode(l:encoded_path)
                            
                                " If the path is like /C:/foo/bar, it should be C:\foo\bar instead.
                                if has('win32') && l:path =~# '^/[a-zA-Z][:|]'
                                    let l:path = substitute(l:path[1:], '/', '\\', 'g')
                                    let l:path = l:path[0] . ':' . l:path[2:]
                                endif
                            
                                return l:path
                            endfunction

SCRIPT  /remote/users/jesmith/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/textlint.vim
Sourced 1 time
Total time:   0.014422
 Self time:   0.013173

count  total (s)   self (s)
                            " Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
                            " Description: textlint, a proofreading tool (https://textlint.github.io/)
                            
    1   0.000031   0.000016 call ale#Set('textlint_executable', 'textlint')
    1   0.001233   0.000008 call ale#Set('textlint_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000021   0.000012 call ale#Set('textlint_options', '')
                            
    1              0.000003 function! ale#handlers#textlint#GetExecutable(buffer) abort
                                return ale#path#FindExecutable(a:buffer, 'textlint', [
                                \   'node_modules/.bin/textlint',
                                \   'node_modules/textlint/bin/textlint.js',
                                \])
                            endfunction
                            
    1              0.000002 function! ale#handlers#textlint#GetCommand(buffer) abort
                                let l:executable = ale#handlers#textlint#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'textlint_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \    . (!empty(l:options) ? ' ' . l:options : '')
                                \    . ' -f json --stdin --stdin-filename %s'
                            endfunction
                            
    1              0.000002 function! ale#handlers#textlint#HandleTextlintOutput(buffer, lines) abort
                                let l:res = get(ale#util#FuzzyJSONDecode(a:lines, []), 0, {'messages': []})
                                let l:output = []
                            
                                for l:err in l:res.messages
                                    call add(l:output, {
                                    \   'text': l:err.message,
                                    \   'type': 'W',
                                    \   'code': l:err.ruleId,
                                    \   'lnum': l:err.line,
                                    \   'col' : l:err.column
                                    \})
                                endfor
                            
                                return l:output
                            endfunction

FUNCTION  <SNR>3_SynSet()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.073549
 Self time:   0.010674

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000004   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000013   let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000010     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.069426   0.006551         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.004060         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000002       endif
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  <SNR>120_check_diff_git()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:161
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  <SNR>126_add_sign()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:263
Called 43 times
Total time:   0.001310
 Self time:   0.001310

count  total (s)   self (s)
   43              0.000073   call add(a:sy.lines, a:line)
   43              0.000075   let a:sy.signtable[a:line] = 1
                            
   43              0.000074   if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
   43              0.000083     if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
   43              0.000017     else
                                  " Update sign by overwriting the ID of the current sign.
   43              0.000073       let id = a:sy.internal[a:line].id
   43              0.000017     endif
   43              0.000016   endif
                            
   43              0.000058   if !exists('id')
                                let id = sy#sign#id_next(a:sy)
   43              0.000015   endif
                            
   43              0.000129   if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s', a:type, a:1, s:delete_highlight[g:signify_line_highlight])
   43              0.000015   endif
   43              0.000271   execute printf('sign place %d line=%d name=%s %s buffer=%s', id, a:line, a:type, s:sign_priority, a:sy.buffer)
                            
   43              0.000034   return id

FUNCTION  <SNR>64_init()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/plugin/airline.vim:15
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000001   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  if g:airline_theme is# 'random'
                                    let g:airline_theme=s:random_theme()
                                  endif
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  call airline#util#warning(printf('Could not resolve airline theme "%s". Themes have been migrated to github.com/vim-airline/vim-airline-themes.', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                endtry
                                try
                                  silent call airline#switch_theme(g:airline_theme)
                                catch
                                  call airline#util#warning(printf('Could not find airline theme "%s".', g:airline_theme))
                                  let g:airline_theme = 'dark'
                                  silent call airline#switch_theme(g:airline_theme)
                                endtry
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  5()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:8
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  7()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:17
Called 8 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    8              0.000026   call add(self._sections, [a:group, a:contents])

FUNCTION  ale#events#LintOnEnter()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/events.vim:42
Called 1 time
Total time:   0.417743
 Self time:   0.000028

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    1              0.000004     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    1   0.000026   0.000010     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    1   0.417710   0.000011         call ale#Queue(0, 'lint_file', a:buffer)
    1              0.000000     endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:93
Called 1 time
Total time:   0.014975
 Self time:   0.000098

count  total (s)   self (s)
    8              0.000009     for Fn in a:list
    8   0.014940   0.000064       let code = call(Fn, a:000)
    8              0.000008       if code != 0
    1              0.000001         return code
    7              0.000003       endif
    7              0.000004     endfor
                                return 0

FUNCTION  <SNR>88_ale_refresh()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:130
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000007   if !exists('#airline')
                                " airline disabled
                                return
    2              0.000001   endif
    2              0.000005   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    2              0.000001   endif

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:116
Called 18 times
Total time:   0.002380
 Self time:   0.000131

count  total (s)   self (s)
   18   0.002373   0.000124   return airline#extensions#ale#get('error')

FUNCTION  ale#linter#Get()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:367
Called 1 time
Total time:   0.214720
 Self time:   0.000174

count  total (s)   self (s)
    1              0.000002     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    2              0.000009     for l:original_filetype in split(a:original_filetypes, '\.')
    1   0.000060   0.000008         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    1   0.000036   0.000008         let l:linter_names = s:GetLinterNames(l:original_filetype)
    1   0.214475   0.000009         let l:all_linters = ale#linter#GetAll(l:filetype)
    1              0.000002         let l:filetype_linters = []
                            
    1              0.000004         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    1              0.000002             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    1              0.000001         endif
                            
    1              0.000003         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    2              0.000002     endfor
                            
    1              0.000001     let l:name_list = []
    1              0.000001     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   11              0.000009     for l:linter in reverse(l:possibly_duplicated_linters)
   10              0.000019         if index(l:name_list, l:linter.name) < 0
   10              0.000017             call add(l:name_list, l:linter.name)
   10              0.000015             call add(l:combined_linters, l:linter)
   10              0.000003         endif
   11              0.000004     endfor
                            
    1              0.000002     return reverse(l:combined_linters)

FUNCTION  <SNR>90_check_mixed_indent()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:17
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000006   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    2              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    2              0.000002   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    2              0.000001   else
    2              0.000020     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  ale#handlers#writegood#ResetOptions()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/writegood.vim:4
Called 1 time
Total time:   0.000065
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000038   0.000024     call ale#Set('writegood_options', '')
    1   0.000013   0.000005     call ale#Set('writegood_executable', 'write-good')
    1   0.000013   0.000006     call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))

FUNCTION  <SNR>108_get_path()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:156
Called 2 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000075   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    2              0.000008   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    2              0.000001   endif
    2              0.000002   return path

FUNCTION  airline#check_mode()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:216
Called 18 times
Total time:   0.069880
 Self time:   0.002240

count  total (s)   self (s)
   18              0.000044   if !has_key(s:contexts, a:winnr)
                                return ''
   18              0.000013   endif
   18              0.000048   let context = s:contexts[a:winnr]
                            
   18              0.000101   if get(w:, 'airline_active', 1)
   18              0.000036     let m = mode(1)
   18              0.000027     if m ==# "i"
                                  let mode = ['insert']
   18              0.000030     elseif m[0] ==# "i"
                                  let mode = ['insert']
   18              0.000016     elseif m ==# "Rv"
                                  let mode =['replace']
   18              0.000018     elseif m[0] ==# "R"
                                  let mode = ['replace']
   18              0.000164     elseif m[0] =~# '\v(v|V||s|S|)'
                                  let mode = ['visual']
   18              0.000017     elseif m ==# "t"
                                  let mode = ['terminal']
   18              0.000018     elseif m[0] ==# "c"
    2              0.000004       let mode = ['commandline']
   16              0.000019     elseif m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let mode = ['normal']
   16              0.000022     elseif m[0:1] ==# 'ni'
                                  let mode = ['insert']
                                  let m = 'ni'
   16              0.000008     else
   16              0.000027       let mode = ['normal']
   18              0.000010     endif
   18              0.000066     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let m = 'multi'
   18              0.000009     endif
   18              0.000086     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], m) == -1
   18              0.000025       let m = m[0]
   18              0.000008     endif
   18              0.000083     let w:airline_current_mode = get(g:airline_mode_map, m, m)
                              else
                                let mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
   18              0.000008   endif
                            
   18              0.000052   if g:airline_detect_modified && &modified
                                call add(mode, 'modified')
   18              0.000007   endif
                            
   18              0.000034   if g:airline_detect_paste && &paste
                                call add(mode, 'paste')
   18              0.000007   endif
                            
   18              0.000194   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(mode, 'crypt')
   18              0.000006   endif
                            
   18              0.000031   if g:airline_detect_spell && &spell
                                call add(mode, 'spell')
   18              0.000006   endif
                            
   18              0.000024   if &readonly || ! &modifiable
                                call add(mode, 'readonly')
   18              0.000006   endif
                            
   18              0.000097   let mode_string = join(mode)
   18              0.000061   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.001498   0.000050     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   0.065970   0.000077     call airline#highlighter#highlight(mode, string(context.bufnr))
    4   0.000352   0.000052     call airline#util#doautocmd('AirlineModeChanged')
    4              0.000009     let w:airline_lastmode = mode_string
   18              0.000007   endif
                            
   18              0.000016   return ''

FUNCTION  airline#util#append()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:49
Called 126 times
Total time:   0.001068
 Self time:   0.001068

count  total (s)   self (s)
  126              0.000250   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  126              0.000045   endif
  126              0.000307   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  126              0.000308   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>86_exec_separator()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:189
Called 47 times
Total time:   0.030811
 Self time:   0.001993

count  total (s)   self (s)
   47              0.000076     if pumvisible()
                                  return
   47              0.000022     endif
   47              0.000148     let group = a:from.'_to_'.a:to.a:suffix
   47   0.008036   0.000336     let l:from = airline#themes#get_highlight(a:from.a:suffix)
   47   0.007688   0.000368     let l:to = airline#themes#get_highlight(a:to.a:suffix)
   47              0.000043     if a:inverse
   14              0.000054       let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   33              0.000015     else
   33              0.000130       let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   47              0.000020     endif
   47              0.000159     let a:dict[group] = colors
   47   0.014191   0.000394     call airline#highlighter#exec(group, colors)

FUNCTION  airline#add_statusline_funcref()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:27
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000003   if index(g:airline_statusline_funcrefs, a:function) >= 0
                                let warn = get(a:, 1, 1)
                                if warn > 0
                                  call airline#util#warning(printf('The airline statusline funcref "%s" has already been added.', string(a:function)))
                                endif
                                return
    1              0.000019   endif
    1              0.000004   call add(g:airline_statusline_funcrefs, a:function)

FUNCTION  <SNR>98_add_section()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:47
Called 8 times
Total time:   0.000653
 Self time:   0.000209

count  total (s)   self (s)
    8              0.000032     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
    8   0.000126   0.000039     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
    8              0.000003     endif
    8              0.000006     if condition
                                  call a:builder.add_raw('%(')
    8              0.000003     endif
    8   0.000434   0.000076     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
    8              0.000006     if condition
                                  call a:builder.add_raw('%)')
    8              0.000003     endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/themes.vim:35
Called 94 times
Total time:   0.015021
 Self time:   0.000868

count  total (s)   self (s)
   94   0.014985   0.000832     return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/highlight.vim:72
Called 2 times
Total time:   0.000098
 Self time:   0.000083

count  total (s)   self (s)
    2              0.000004     if s:has_nvim_highlight
    2   0.000038   0.000023         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
                                else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
    2              0.000001     endif

FUNCTION  <SNR>86_hl_group_exists()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:99
Called 118 times
Total time:   0.001475
 Self time:   0.001475

count  total (s)   self (s)
  118              0.000420     if !hlexists(a:group)
                                  return 0
  118              0.000643     elseif empty(synIDattr(synIDtrans(hlID(a:group)), 'fg'))
                                  return 0
  118              0.000048     endif
  118              0.000085     return 1

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:17
Called 36 times
Total time:   0.001061
 Self time:   0.001061

count  total (s)   self (s)
   36              0.001008   if luaeval('vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
   36              0.000032     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  <SNR>86_GetHiCmd()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:140
Called 41 times
Total time:   0.003801
 Self time:   0.003801

count  total (s)   self (s)
                                " a:list needs to have 5 items!
   41              0.000042     let res = ''
   41              0.000040     let i = -1
  246              0.000210     while i < 4
  205              0.000211       let i += 1
  205              0.000422       let item = get(a:list, i, '')
  205              0.000211       if item is ''
   33              0.000020         continue
  172              0.000065       endif
  172              0.000124       if i == 0
   41              0.000094         let res .= ' guifg='.item
  131              0.000094       elseif i == 1
   41              0.000071         let res .= ' guibg='.item
   90              0.000055       elseif i == 2
   41              0.000084         let res .= ' ctermfg='.item
   49              0.000029       elseif i == 3
   41              0.000066         let res .= ' ctermbg='.item
    8              0.000005       elseif i == 4
    8              0.000029         let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  172              0.000067       endif
  213              0.000139     endwhile
   41              0.000042     return res

FUNCTION  quick_scope#HighlightLine()
    Defined: ~/local/share/nvim/site/pack/packer/start/quick-scope/autoload/quick_scope.vim:15
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000019   if g:qs_enable && (!exists('b:qs_local_disable') || !b:qs_local_disable) && index(get(g:, 'qs_buftype_blacklist', []), &buftype) < 0 && index(get(g:, 'qs_filetype_blacklist', []), &filetype) < 0
    1              0.000004     let line = getline(line('.'))
    1              0.000003     let len = strlen(line)
    1              0.000003     let pos = col('.')
                            
    1              0.000003     if !empty(line) && len <= g:qs_max_chars
                                  " Highlight after the cursor.
                                  if a:direction != 0
                                    let [patt_p, patt_s] = s:get_highlight_patterns(line, pos, len, a:targets)
                                    call s:apply_highlight_patterns([patt_p, patt_s])
                                  endif
                            
                                  " Highlight before the cursor.
                                  if a:direction != 1
                                    let [patt_p, patt_s] = s:get_highlight_patterns(line, pos, -1, a:targets)
                                    call s:apply_highlight_patterns([patt_p, patt_s])
                                  endif
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  <SNR>120_replace()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:529
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000013   let parts = split(a:cmd, a:pat, 1)
    3              0.000008   return join(parts, a:sub)

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/highlight.vim:136
Called 1 time
Total time:   0.000134
 Self time:   0.000065

count  total (s)   self (s)
    1              0.000008     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    1   0.000078   0.000010     call ale#highlight#RemoveHighlights()
                            
    1              0.000002     for l:item in l:item_list
                                    if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
                                    let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
                                    call s:highlight_range(l:item.bufnr, l:range, l:group)
    1              0.000001     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    1              0.000001     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  <SNR>88_airline_ale_get_line_number()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:68
Called 36 times
Total time:   0.000497
 Self time:   0.000379

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
   36              0.000092   if exists("*ale#statusline#FirstProblem")
   36   0.000375   0.000257     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>88_airline_ale_count()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:11
Called 36 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
   36              0.000066   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#util#stl_disabled()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:189
Called 2 times
Total time:   0.000060
 Self time:   0.000043

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    2   0.000058   0.000040   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  airline#parts#filetype()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:102
Called 18 times
Total time:   0.000288
 Self time:   0.000162

count  total (s)   self (s)
   18   0.000276   0.000150   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  <SNR>120_callback_nvim_stdout()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:15
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000014   let self.stdoutbuf[-1] .= a:data[0]
    2              0.000028   call extend(self.stdoutbuf, a:data[1:])

FUNCTION  ale#handlers#alex#CreateCommandCallback()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/alex.vim:12
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000016     return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))            . ' %s '            . a:flags}

FUNCTION  <SNR>90_conflict_marker()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:52
Called 2 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                              " Checks for git conflict markers
    2              0.000003   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    2              0.000018   if match(['rst', 'markdown'], &ft) >= 0
                                " rst filetypes use '=======' as header
    2              0.000007     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
                              else
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    2              0.000001   endif
    2              0.000034   return search(pattern, 'nw')

FUNCTION  airline#parts#iminsert()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:82
Called 18 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   18              0.000043   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   18              0.000007   endif
   18              0.000011   return ''

FUNCTION  airline#update_tabline()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:290
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000013   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
    5              0.000002   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/term.vim:14
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    1              0.000000   endif

FUNCTION  sy#verbose()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:114
Called 6 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    6              0.000009   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
    6              0.000003   endif

FUNCTION  <SNR>87_get_hunks_signify()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:29
Called 8 times
Total time:   0.000143
 Self time:   0.000075

count  total (s)   self (s)
    8   0.000115   0.000047   let hunks = sy#repo#get_stats()
    8              0.000013   if hunks[0] >= 0
    8              0.000008     return hunks
                              endif
                              return []

FUNCTION  <SNR>86_get_syn()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:44
Called 1060 times
Total time:   0.021927
 Self time:   0.021927

count  total (s)   self (s)
 1060              0.001110     let color = ''
 1060              0.003567     if hlexists(a:group)
 1024              0.005672       let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 1060              0.000483     endif
 1060              0.002025     if empty(color) || color == -1
                                  " should always exist
   44              0.000368       let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                  " however, just in case
   44              0.000074       if empty(color) || color == -1
   26              0.000025         let color = 'NONE'
   44              0.000020       endif
 1060              0.000417     endif
 1060              0.000993     return color

FUNCTION  ale#events#ReadOrEnterEvent()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/events.vim:51
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    1              0.000010     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
    1              0.000001     endif
                            
                                " When entering a buffer, we are no longer quitting it.
    1              0.000005     call setbufvar(a:buffer, 'ale_quitting', 0)
    1              0.000005     let l:filetype = getbufvar(a:buffer, '&filetype')
    1              0.000006     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    1              0.000002     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
    1              0.000000     endif

FUNCTION  peekaboo#on()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-peekaboo/plugin/peekaboo.vim:27
Called 1 time
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    1              0.000005   if get(b:, 'peekaboo_on', 0)
                                return
    1              0.000000   endif
                            
    1              0.000005   let prefix = get(g:, 'peekaboo_prefix', '')
    1              0.000004   let ins_prefix = get(g:, 'peekaboo_ins_prefix', '')
    1              0.000044   execute 'nmap <buffer> <expr> '.prefix.    '"     peekaboo#peek(v:count1, ''"'',  0)'
    1              0.000012   execute 'xmap <buffer> <expr> '.prefix.    '"     peekaboo#peek(v:count1, ''"'',  1)'
    1              0.000009   execute 'nmap <buffer> <expr> '.prefix.    '@     peekaboo#peek(v:count1, ''@'', 0)'
    1              0.000014   execute 'imap <buffer> <expr> '.ins_prefix.'<c-r> peekaboo#peek(1, "\<c-r>",  0)'
    1              0.000002   let b:peekaboo_on = 1
    1              0.000001   return ''

FUNCTION  airline#extensions#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:71
Called 1 time
Total time:   0.000102
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000004   let filetype_overrides = get(s:, 'filetype_overrides', {})
    1              0.000007   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    1   0.000050   0.000007   if s:is_excluded_window()
                                return -1
    1              0.000000   endif
                            
    1              0.000003   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    1              0.000000   endif
                            
    1              0.000003   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    1              0.000000   endif
                            
    1              0.000007   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    1              0.000000   endif
                            
    1              0.000002   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    1              0.000000   endif
                            
    1              0.000003   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    1              0.000001   endfor

FUNCTION  airline#mode_changed()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:296
Called 4 times
Total time:   0.000082
 Self time:   0.000060

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    4              0.000032   let g:airline#visual_active = (mode() =~? '[vs]')
    4   0.000042   0.000021   call airline#update_tabline()

FUNCTION  12()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:62
Called 1 time
Total time:   0.008218
 Self time:   0.000804

count  total (s)   self (s)
    1              0.000001   let side = 1
    1              0.000001   let line = ''
    1              0.000001   let i = 0
    1              0.000002   let length = len(self._sections)
    1              0.000001   let split = 0
    1              0.000001   let is_empty = 0
    1              0.000001   let prev_group = ''
                            
   10              0.000013   while i < length
    9              0.000017     let section = self._sections[i]
    9              0.000013     let group = section[0]
    9              0.000013     let contents = section[1]
    9              0.000012     let pgroup = prev_group
    9   0.000174   0.000078     let prev_group = airline#builder#get_prev_group(self._sections, i)
    9              0.000042     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
    9              0.000030     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
    9              0.000027     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
    9              0.000004     endif
    9              0.000008     if is_empty
                                  let prev_group = pgroup
    9              0.000003     endif
    9   0.000172   0.000068     let is_empty = s:section_is_empty(self, contents)
                            
    9              0.000006     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
    9              0.000003     endif
                            
    9              0.000010     if group == ''
                                  let line .= contents
    9              0.000010     elseif group == '|'
    1              0.000001       let side = 0
    1              0.000002       let line .= contents
    1              0.000001       let split = 1
    8              0.000003     else
    8              0.000009       if prev_group == ''
    1              0.000002         let line .= '%#'.group.'#'
    7              0.000005       elseif split
    1              0.000001         if !is_empty
    1   0.000743   0.000009           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    1              0.000001         endif
    1              0.000001         let split = 0
    6              0.000003       else
    6              0.000005         if !is_empty
    6   0.006130   0.000051           let line .= s:get_seperator(self, prev_group, group, side)
    6              0.000003         endif
    8              0.000004       endif
    8   0.000490   0.000090       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
    9              0.000004     endif
                            
    9              0.000012     let i = i + 1
   10              0.000007   endwhile
                            
    1              0.000001   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    1              0.000000   endif
    1              0.000002   return line

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:184
Called 7 times
Total time:   0.004515
 Self time:   0.000099

count  total (s)   self (s)
    7              0.000035     let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
    7   0.004477   0.000060     call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:32
Called 2 times
Total time:   0.000246
 Self time:   0.000170

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
    2              0.000011     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
    2              0.000001     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
    2              0.000006     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
    2              0.000001     endif
                            
    2              0.000007     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
    2              0.000002     if l:filetype is# ''
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing for diff buffers.
    2              0.000004     if getbufvar(a:buffer, '&diff')
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing for blacklisted files.
    2              0.000012     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing if running from command mode.
    2              0.000006     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
    2              0.000001     endif
                            
    2              0.000009     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    2              0.000002     if l:filename is# '.'
                                    return 1
    2              0.000001     endif
                            
                                " Don't start linting and so on when an operator is pending.
    2   0.000029   0.000015     if ale#util#Mode(1) is# 'no'
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing if running in the sandbox.
    2   0.000048   0.000011     if ale#util#InSandbox()
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing if the file is too large.
    2   0.000036   0.000010     if ale#FileTooLarge(a:buffer)
                                    return 1
    2              0.000001     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    2              0.000016     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
    2              0.000001     endif
                            
    2              0.000001     return 0

FUNCTION  airline#extensions#po#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/po.vim:64
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000007   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * call s:autocmd_handler()
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    1              0.000000   endif

FUNCTION  <SNR>28_LoadIndent()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.004018
 Self time:   0.004018

count  total (s)   self (s)
    1              0.000004     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000005     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000007       for name in split(s, '\.')
    1              0.002171         exe 'runtime! indent/' . name . '.vim'
    1              0.001812         exe 'runtime! indent/' . name . '.lua'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/fzf.vim:28
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000001   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    1              0.000000   endif

FUNCTION  airline#util#winwidth()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:19
Called 140 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
  140              0.000325   let nr = get(a:000, 0, 0)
  140              0.000298   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  140              0.000060   else
  140              0.000202     return winwidth(nr)
                              endif

FUNCTION  sy#sign#get_current_signs()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:27
Called 1 time
Total time:   0.001459
 Self time:   0.001366

count  total (s)   self (s)
    1              0.000047   let a:sy.internal = {}
    1              0.000002   let a:sy.external = {}
                            
    1   0.000105   0.000013   let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
   44              0.000050   for signline in split(signlist, '\n')[2:]
   43              0.000499     let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
   43              0.000074     let line   = str2nr(tokens[1])
   43              0.000065     let id     = str2nr(tokens[2])
   43              0.000048     let type   = tokens[3]
                            
   43              0.000123     if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
   43              0.000076       if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
   43              0.000017       endif
   43              0.000114       let a:sy.internal[line] = { 'type': type, 'id': id }
                                else
                                  let a:sy.external[line] = id
   43              0.000017     endif
   44              0.000018   endfor

FUNCTION  <SNR>86_CheckDefined()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:108
Called 159 times
Total time:   0.002117
 Self time:   0.002117

count  total (s)   self (s)
                                " Checks, whether the definition of the colors is valid and is not empty or NONE
                                " e.g. if the colors would expand to this:
                                " hi airline_c ctermfg=NONE ctermbg=NONE
                                " that means to clear that highlighting group, therefore, fallback to Normal
                                " highlighting group for the cterm values
                            
                                " This only works, if the Normal highlighting group is actually defined, so
                                " return early, if it has been cleared
  159              0.000472     if !exists("g:airline#highlighter#normal_fg_hi")
                                  let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  159              0.000073     endif
  159              0.000431     if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  159              0.000169       return a:colors
                                endif
                            
                                for val in a:colors
                                  if !empty(val) && val !=# 'NONE'
                                    return a:colors
                                  endif
                                endfor
                                " this adds the bold attribute to the term argument of the :hi command,
                                " but at least this makes sure, the group will be defined
                                let fg = g:airline#highlighter#normal_fg_hi
                                let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                                if empty(bg) || bg < 0
                                  " in case there is no background color defined for Normal
                                  let bg = a:colors[3]
                                endif
                                return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  sy#util#execute()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/util.vim:107
Called 1 time
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    1              0.000002   let lang = v:lang
    1              0.000003   redir => output
    1              0.000058     silent! execute a:cmd
    1              0.000002   redir END
    1              0.000024   silent! execute 'language message' lang
    1              0.000002   return output

FUNCTION  airline#util#doautocmd()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:176
Called 4 times
Total time:   0.000300
 Self time:   0.000093

count  total (s)   self (s)
    4              0.000023   if !exists('#airline') && a:event !=? 'AirlineToggledOff'
                                " airline disabled
                                return
    4              0.000002   endif
    4   0.000267   0.000060   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  quick_scope#HighlightLineDelayCallback()
    Defined: ~/local/share/nvim/site/pack/packer/start/quick-scope/autoload/quick_scope.vim:40
Called 1 time
Total time:   0.000123
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000052   0.000016   call quick_scope#UnhighlightLine()
    1   0.000066   0.000011   call quick_scope#HighlightLine(a:direction, a:targets)

FUNCTION  <SNR>64_on_window_changed()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/plugin/airline.vim:51
Called 5 times
Total time:   0.023672
 Self time:   0.000253

count  total (s)   self (s)
                              " don't trigger for Vim popup windows
    5              0.000017   if &buftype is# 'popup'
                                return
    5              0.000003   endif
                            
    5              0.000012   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                " do not trigger for previewwindows
                                return
    5              0.000002   endif
    5              0.000016   let s:active_winnr = winnr()
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    5              0.000073   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    5              0.000078   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    4              0.000003     return
    1              0.000000   endif
    1              0.000004   let g:airline_last_window_changed = l:key
    1   0.000011   0.000008   call s:init()
    1   0.023423   0.000007   call airline#update_statusline()

FUNCTION  <SNR>111_IsBoolean()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:79
Called 40 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   40              0.000128     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  <SNR>120_wrap_cmd()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:469
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell|pwsh)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
    1              0.000000   else
    1              0.000002     let cmd = ['sh', '-c', a:cmd]
    1              0.000001   endif
    1              0.000005   let options = { 'stdoutbuf': [''], 'vcs': a:vcs, 'bufnr': a:bufnr, }
    1              0.000002   return [cmd, options]

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:38
Called 18 times
Total time:   0.000883
 Self time:   0.000114

count  total (s)   self (s)
   18   0.000875   0.000106   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/cursor.vim:63
Called 1 time
Total time:   0.000262
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000012     let l:buffer = bufnr('')
                            
    1              0.000002     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    1              0.000001     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    1              0.000002     if mode(1) isnot# 'n'
                                    return
    1              0.000000     endif
                            
    1   0.000154   0.000012     if ale#ShouldDoNothing(l:buffer)
                                    return
    1              0.000000     endif
                            
    1   0.000053   0.000010     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    1              0.000001     if g:ale_echo_cursor
    1              0.000002         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
    1              0.000002         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
    1              0.000001         endif
    1              0.000000     endif
                            
    1              0.000001     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    1              0.000000     endif

FUNCTION  <SNR>109_AddProblemsFromOtherBuffers()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:493
Called 1 time
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    1              0.000015     let l:filename = expand('#' . a:buffer . ':p')
    1              0.000001     let l:loclist = []
    1              0.000001     let l:name_map = {}
                            
                                " Build a map of the active linters.
   11              0.000009     for l:linter in a:linters
   10              0.000020         let l:name_map[l:linter.name] = 1
   11              0.000005     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
    3              0.000009     for l:info in values(g:ale_buffer_info)
    2              0.000004         for l:item in l:info.loclist
                                        if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
    2              0.000001         endfor
    3              0.000002     endfor
                            
    1              0.000002     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
    1              0.000000     endif

FUNCTION  ale#linter#Define()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:251
Called 20 times
Total time:   0.004553
 Self time:   0.000741

count  total (s)   self (s)
                                " This command will throw from the sandbox.
   20              0.000105     let &l:equalprg=&l:equalprg
                            
   20   0.003981   0.000169     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
   20              0.000043     if !has_key(s:linters, a:filetype)
    1              0.000002         let s:linters[a:filetype] = []
   20              0.000007     endif
                            
                                " Remove previously defined linters with the same name.
   20              0.000276     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
   20              0.000056     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  <SNR>120_initialize_job()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:448
Called 1 time
Total time:   0.000128
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000128   0.000028   return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))

FUNCTION  <SNR>109_GetLintFileValues()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:607
Called 1 time
Total time:   0.202535
 Self time:   0.000244

count  total (s)   self (s)
    1              0.000001     let l:deferred_list = []
    1              0.000001     let l:new_slots = []
                            
   11              0.000012     for [l:lint_file, l:linter] in a:slots
   10   0.000082   0.000056         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
   10              0.000005         endwhile
                            
   10   0.000071   0.000046         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
   10              0.000004         else
                                        " If we have the value now, coerce it to 0 or 1.
   10              0.000020             let l:lint_file = l:lint_file is 1
   10              0.000004         endif
                            
   10              0.000022         call add(l:new_slots, [l:lint_file, l:linter])
   11              0.000005     endfor
                            
    1              0.000002     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    1              0.000001     else
    1   0.202246   0.000006         call a:Callback(l:new_slots)
    1              0.000000     endif

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 18 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
   18              0.000092   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   18              0.000064     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
   18              0.000112     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
   18              0.000047     let default = get(g:, 'airline#extensions#keymap#default', '')
   18              0.000026     if (label !=# '')
   18              0.000032       let label .= ' '
   18              0.000009     endif
   18              0.000028     let keymap = &keymap
   18              0.000037     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
   18              0.000008     endif
   18              0.000107     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  ale#events#QuitEvent()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/events.vim:14
Called 1 time
Total time:   0.000021
 Self time:   0.000014

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    1   0.000020   0.000013     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  <SNR>74_wrap()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-slash/plugin/slash.vim:23
Called 2 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    2              0.000027   if mode() == 'c' && stridx('/?', getcmdtype()) < 0
    2              0.000008     return a:seq
                              endif
                              silent! autocmd! slash
                              set hlsearch
                              return a:seq."\<plug>(slash-trailer)"

FUNCTION  <SNR>97_get_transitioned_seperator()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:140
Called 7 times
Total time:   0.004734
 Self time:   0.000218

count  total (s)   self (s)
    7              0.000008   let line = ''
    7              0.000031   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
    7              0.000003   else
    7   0.004567   0.000051     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    7              0.000026     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
    7              0.000025     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
    7              0.000013     let line .= '%#'.a:group.'#'
    7              0.000004   endif
    7              0.000007   return line

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:82
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    1              0.000006         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    1              0.000001         return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>97_get_seperator()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:155
Called 6 times
Total time:   0.006079
 Self time:   0.000101

count  total (s)   self (s)
    6   0.002019   0.000042   if airline#builder#should_change_group(a:prev_group, a:group)
    6   0.004056   0.000056     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  ale#statusline#Count()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:119
Called 36 times
Total time:   0.001513
 Self time:   0.000302

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   36   0.001485   0.000274     return copy(s:GetCounts(a:buffer))

FUNCTION  airline#extensions#default#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:79
Called 1 time
Total time:   0.000853
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000002   let winnr = a:context.winnr
    1              0.000001   let active = a:context.active
                            
    1   0.000013   0.000009   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000260   0.000008     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = !empty(s:get_section(winnr, 'c')) ? s:get_section(winnr, 'c') : ' %f%m '
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    1              0.000000   endif
                            
    1   0.000045   0.000010   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    1   0.000008   0.000005   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    1   0.000513   0.000007     call s:build_sections(a:builder, a:context, s:layout[1])
    1              0.000000   endif
                            
    1              0.000001   return 1

FUNCTION  ale#FileTooLarge()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:24
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000016     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    2              0.000007     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  <SNR>110_CreateCountDict()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:5
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    1              0.000006     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  quick_scope#HighlightLineDelay()
    Defined: ~/local/share/nvim/site/pack/packer/start/quick-scope/autoload/quick_scope.vim:47
Called 2 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    2              0.000004   if g:qs_enable && g:qs_delay > 0
    2              0.000005     call timer_stop(s:timer)
    2              0.000016     let Cb = function('quick_scope#HighlightLineDelayCallback', [a:direction, a:targets])
    2              0.000011     let s:timer = timer_start(g:qs_delay, Cb)
                              else
                                call quick_scope#UnhighlightLine()
                                call quick_scope#HighlightLine(a:direction, a:targets)
    2              0.000001   endif

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:101
Called 37 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
   37              0.000137     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   37              0.000216     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#Var()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:180
Called 12 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
   12              0.000031     let l:full_name = 'ale_' . a:variable_name
   12              0.000060     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   12              0.000051     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  airline#extensions#ale#get()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:77
Called 36 times
Total time:   0.004789
 Self time:   0.002318

count  total (s)   self (s)
   36              0.000110   if !exists(':ALELint')
                                return ''
   36              0.000014   endif
                            
   36              0.000109   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
   36              0.000094   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
   36              0.000099   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
   36              0.000102   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
   36              0.000068   let is_err = a:type ==# 'error'
                            
   36   0.000622   0.000243   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
   36              0.000014   endif
                            
   36              0.000077   let symbol = is_err ? error_symbol : warning_symbol
                            
   36   0.001722   0.000209   let counts = ale#statusline#Count(bufnr(''))
   36              0.000136   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   36              0.000076     let errors = counts.error + counts.style_error
   36              0.000080     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
   36              0.000016   endif
                            
   36              0.000044   if show_line_numbers == 1
   36   0.001087   0.000509     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  airline#util#wrap()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:42
Called 180 times
Total time:   0.000990
 Self time:   0.000875

count  total (s)   self (s)
  180   0.000542   0.000427   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  180              0.000077   endif
  180              0.000164   return a:text

FUNCTION  ale#events#ClockMilliseconds()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/events.vim:10
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#events#FileTypeEvent()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/events.vim:69
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    1              0.000006     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    1              0.000004     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
                                    call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
                                    if g:ale_lint_on_filetype_changed
                                        call ale#Queue(300, 'lint_file', a:buffer)
                                    endif
    1              0.000000     endif

FUNCTION  sy#start()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:7
Called 2 times
Total time:   0.003075
 Self time:   0.000197

count  total (s)   self (s)
    2              0.000003   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    2              0.000001   endif
                            
    2              0.000010   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    2              0.000006   let sy = getbufvar(bufnr, 'sy')
                            
    2              0.000003   if empty(sy)
    1   0.000048   0.000008     let path = s:get_path(bufnr)
    1   0.000031   0.000006     if s:skip(bufnr, path)
    1   0.000025   0.000008       call sy#verbose('Skip file: '. path)
    1              0.000001       return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = { 'path':       path, 'buffer':     bufnr, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#set_buflocal_autocmds(bufnr)
                                call sy#repo#detect(bufnr)
    1              0.000006   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    1              0.000000   else
    1   0.000059   0.000007     let path = s:get_path(bufnr)
    1              0.000012     if !filereadable(path)
                                  call sy#stop()
                                  return
    1              0.000002     elseif empty(sy.vcs)
                                  if get(sy, 'retry')
                                    let sy.retry = 0
                                    call sy#verbose('Redetecting VCS.')
                                    call sy#repo#detect(sy.buffer)
                                  else
                                    if get(sy, 'detecting')
                                      call sy#verbose('Detection is already in progress.')
                                    else
                                      call sy#verbose('No VCS found. Disabling.')
                                      call sy#stop(sy.buffer)
                                    endif
                                  endif
    1              0.000000     else
    2              0.000007       for vcs in sy.vcs
    1              0.000004         let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
    1              0.000003         if type(job_id) != type(0) || job_id > 0
                                      call sy#verbose('Update is already in progress.', vcs)
    1              0.000000         else
    1   0.000062   0.000007           call sy#verbose('Updating signs.', vcs)
    1   0.002713   0.000024           call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
    1              0.000002         endif
    2              0.000006       endfor
    1              0.000001     endif
    1              0.000000   endif

FUNCTION  ale#command#IsDeferred()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/command.vim:471
Called 27 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
   27              0.000073     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim:117
Called 5 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    5              0.000027     if has('win32') && a:filename[:0] is# '\'
                                    return 1
    5              0.000002     endif
                            
                                " Check for /foo and C:\foo, etc.
    5              0.000016     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  airline#parts#paste()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:63
Called 18 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   18              0.000046   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>92_update_wordcount()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:66
Called 2 times
Total time:   0.013781
 Self time:   0.000032

count  total (s)   self (s)
    2   0.000029   0.000012   let wordcount = s:get_wordcount(0)
    2              0.000004   if wordcount != s:wordcount_cache || a:force_update
    1              0.000001     let s:wordcount_cache = wordcount
    1   0.013741   0.000008     let b:airline_wordcount =  s:format_wordcount(wordcount)
    2              0.000001   endif

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:37
Called 9 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    9              0.000015   let x = a:i - 1
   10              0.000012   while x >= 0
    9              0.000019     let group = a:sections[x][0]
    9              0.000018     if group != '' && group != '|'
    8              0.000009       return group
    1              0.000000     endif
    1              0.000001     let x = x - 1
    2              0.000002   endwhile
    1              0.000001   return ''

FUNCTION  airline#util#getwinvar()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:82
Called 17 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
   17              0.000046     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:64
Called 18 times
Total time:   0.002757
 Self time:   0.002102

count  total (s)   self (s)
   18              0.000059   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   18              0.000096   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   18              0.000007   endif
   18              0.000157   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   18              0.000048   if !exists('b:airline_whitespace_check')
    2              0.000003     let b:airline_whitespace_check = ''
    2              0.000009     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    2              0.000002     let trailing = 0
    2              0.000002     let check = 'trailing'
    2              0.000020     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2              0.000002       try
    2              0.000009         let regexp = get(b:, 'airline_whitespace_trailing_regexp', get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$'))
    2              0.000015         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    2              0.000002       endtry
    2              0.000001     endif
                            
    2              0.000002     let mixed = 0
    2              0.000002     let check = 'indent'
    2              0.000018     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.000063   0.000015       let mixed = s:check_mixed_indent()
    2              0.000001     endif
                            
    2              0.000002     let mixed_file = ''
    2              0.000002     let check = 'mixed-indent-file'
    2              0.000014     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    2   0.000073   0.000017       let mixed_file = s:check_mixed_indent_file()
    2              0.000001     endif
                            
    2              0.000002     let long = 0
    2              0.000004     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    2              0.000001     endif
                            
    2              0.000002     let conflicts = 0
    2              0.000004     if index(checks, 'conflicts') > -1
    2   0.000083   0.000012       let conflicts = s:conflict_marker()
    2              0.000001     endif
                            
    2              0.000008     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    2              0.000001     endif
   18              0.000008   endif
   18   0.000597   0.000117   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  ale#path#FindExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim:102
Called 3 times
Total time:   0.071456
 Self time:   0.000113

count  total (s)   self (s)
    3   0.000063   0.000021     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
    3              0.000002     endif
                            
    3   0.071288   0.000030     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
    3              0.000005     if !empty(l:nearest)
                                    return l:nearest
    3              0.000001     endif
                            
    3   0.000079   0.000037     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  ale#handlers#alex#DefineLinter()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/alex.vim:42
Called 2 times
Total time:   0.000615
 Self time:   0.000092

count  total (s)   self (s)
    2   0.000070   0.000031     call ale#Set('alex_executable', 'alex')
    2   0.000032   0.000016     call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
    2   0.000509   0.000042     call ale#linter#Define(a:filetype, {   'name': 'alex',   'executable': function('ale#handlers#alex#GetExecutable'),   'command': ale#handlers#alex#CreateCommandCallback(a:flags),   'output_stream': 'stderr',   'callback': 'ale#handlers#alex#Handle',   'lint_file': 1,})

FUNCTION  <SNR>88_new_airline_ale_get_line_number()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:40
Called 36 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
   36              0.000037   if a:cnt == 0
   36              0.000026     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  ale#handlers#textlint#GetExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/textlint.vim:8
Called 1 time
Total time:   0.068883
 Self time:   0.000013

count  total (s)   self (s)
    1   0.068882   0.000012     return ale#path#FindExecutable(a:buffer, 'textlint', [   'node_modules/.bin/textlint',   'node_modules/textlint/bin/textlint.js',])

FUNCTION  ale#Queue()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:123
Called 1 time
Total time:   0.417699
 Self time:   0.000054

count  total (s)   self (s)
    1              0.000002     if a:0 > 2
                                    throw 'too many arguments!'
    1              0.000001     endif
                            
    1              0.000004     let l:buffer = get(a:000, 1, v:null)
                            
    1              0.000002     if l:buffer is v:null
                                    let l:buffer = bufnr('')
    1              0.000000     endif
                            
    1              0.000002     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    1              0.000000     endif
                            
    1   0.000112   0.000008     if ale#ShouldDoNothing(l:buffer)
                                    return
    1              0.000000     endif
                            
                                " Default linting_flag to ''
    1              0.000003     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    1              0.000001     if s:lint_timer != -1
                                    call timer_stop(s:lint_timer)
                                    let s:lint_timer = -1
    1              0.000000     endif
                            
    1              0.000001     if a:delay > 0
                                    let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000001     else
    1   0.417551   0.000010         call s:Lint(l:buffer, l:should_lint_file, 0)
    1              0.000000     endif

FUNCTION  <SNR>109_GetLintFileSlots()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:591
Called 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    1              0.000001     let l:linter_slots = []
                            
   11              0.000008     for l:linter in a:linters
   10              0.000012         let l:LintFile = l:linter.lint_file
                            
   10              0.000015         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
   10              0.000004         endif
                            
   10              0.000021         call add(l:linter_slots, [l:LintFile, l:linter])
   11              0.000005     endfor
                            
    1              0.000001     return l:linter_slots

FUNCTION  <SNR>120_get_base_cmd()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:501
Called 1 time
Total time:   0.000073
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003   let cmd = a:vcs_cmds[a:vcs]
    1   0.000043   0.000013   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
    1   0.000013   0.000007   let cmd = s:replace(cmd, '%d', s:difftool)
    1   0.000011   0.000005   let cmd = s:replace(cmd, '%n', s:devnull)
    1              0.000001   return cmd

FUNCTION  sy#repo#get_diff()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:72
Called 1 time
Total time:   0.002689
 Self time:   0.002549

count  total (s)   self (s)
    1   0.000017   0.000005   call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
    1              0.000004   let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
    1              0.000004   if getbufvar(a:bufnr, '&modified')
                                let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
                                let options.difftool = 'diff'
    1              0.000000   else
    1   0.000139   0.000011     let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
    1              0.000002     let options.difftool = a:vcs
    1              0.000000   endif
                            
    1              0.000002   let options.func = a:func
                            
    1              0.000002   if has('nvim')
    1              0.000001     if job_id
                                  silent! call jobstop(job_id)
    1              0.000000     endif
    1              0.002467     let job_id = jobstart(cmd, extend(options, { 'cwd':       getbufvar(a:bufnr, 'sy').info.dir, 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
    1              0.000010     call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = { 'cwd':      getbufvar(a:bufnr, 'sy').info.dir, 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
    1              0.000001   endif

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:53
Called 7 times
Total time:   0.110965
 Self time:   0.110764

count  total (s)   self (s)
    7              0.000012     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
    7              0.000003     endif
                            
                                " Check for a cached executable() check.
    7              0.000027     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    7              0.000011     if l:result isnot v:null
                                    return l:result
    7              0.000003     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
    7              0.110435     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
    7              0.000050     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
    7              0.000007     endif
                            
    7              0.000009     if g:ale_history_enabled
    7   0.000315   0.000113         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
    7              0.000004     endif
                            
    7              0.000008     return l:result

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:173
Called 1 time
Total time:   0.000057
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000035   0.000007   if airline#util#stl_disabled(winnr())
                                return
    1              0.000000   endif
    1              0.000002   for nr in a:range
                                if airline#util#stl_disabled(nr)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, g:airline_inactive_funcrefs)
    1              0.000002   endfor

FUNCTION  htmlcomplete#DetectOmniFlavor()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/autoload/htmlcomplete.vim:9
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
    1              0.000001   else
    1              0.000002     let b:html_omni_flavor = 'html401t'
    1              0.000001   endif
    1              0.000001   let i = 1
    1              0.000001   let line = ""
    1              0.000004   while i < 10 && i < line("$")
                                let line = getline(i)
                                if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
                                let i += 1
    1              0.000001   endwhile
    1              0.000006   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
    1              0.000000   endif

FUNCTION  <SNR>126_external_sign_present()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:299
Called 43 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                              " If sign priority is supported, so are multiple signs per line.
                              " Therefore, we can report no external signs present and let
                              " g:signify_priority control whether Sy's signs are shown.
   43              0.000062   if !empty(s:sign_priority)
   43              0.000022     return
                              endif
                              if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif

FUNCTION  <SNR>110_BufferCacheExists()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:88
Called 36 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   36              0.000145     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return 0
   36              0.000017     endif
                            
   36              0.000024     return 1

FUNCTION  <SNR>111_GetAliasedFiletype()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:294
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000004     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    1              0.000004     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    1              0.000000     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
    4              0.000007     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    3              0.000006         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    3              0.000001         endif
    4              0.000002     endfor
                            
    1              0.000001     return a:original_filetype

FUNCTION  <SNR>82_invoke_funcrefs()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:194
Called 1 time
Total time:   0.023267
 Self time:   0.000049

count  total (s)   self (s)
    1   0.000032   0.000007   let builder = airline#builder#new(a:context)
    1   0.014988   0.000013   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    1              0.000001   if err == 1
    1   0.008226   0.000008     let a:context.line = builder.build()
    1              0.000005     let s:contexts[a:context.winnr] = a:context
    1              0.000003     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    1              0.000010     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    1              0.000000   endif

FUNCTION  <SNR>92_format_wordcount()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:40
Called 1 time
Total time:   0.013733
 Self time:   0.002865

count  total (s)   self (s)
    1   0.013732   0.002864   return airline#extensions#wordcount#formatters#{s:formatter}#to_string(a:wordcount)

FUNCTION  <SNR>120_callback_nvim_exit()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:21
Called 1 time
Total time:   0.004435
 Self time:   0.000009

count  total (s)   self (s)
    1   0.004435   0.000008   return s:handle_diff(self, a:exitval)

FUNCTION  ale#util#Tempname()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/util.vim:300
Called 1 time
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000003     let l:clear_tempdir = 0
                            
    1              0.000007     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    1              0.000001     endif
                            
    1              0.000001     try
    1              0.000004         let l:name = tempname() " no-custom-checks
    1              0.000001     finally
    1              0.000001         if l:clear_tempdir
                                        let $TMPDIR = ''
    1              0.000001         endif
    1              0.000001     endtry
                            
    1              0.000001     return l:name

FUNCTION  <SNR>90_check_mixed_indent_file()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:34
Called 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000010   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    2              0.000010   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    2              0.000001   else
    2              0.000002     let head_spc = '\v(^ +)'
    2              0.000001   endif
    2              0.000010   let indent_tabs = search('\v(^\t+)', 'nw')
    2              0.000008   let indent_spc  = search(head_spc, 'nw')
    2              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    2              0.000001   else
    2              0.000001     return ''
                              endif

FUNCTION  airline#highlighter#highlight()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:255
Called 4 times
Total time:   0.065893
 Self time:   0.008274

count  total (s)   self (s)
    4              0.000009     let bufnr = a:0 ? a:1 : ''
    4              0.000013     let p = g:airline#themes#{g:airline_theme}#palette
                            
                                " draw the base mode, followed by any overrides
    4              0.000026     let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4              0.000009     let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    4              0.000006     let airline_grouplist = []
    4              0.000013     let buffers_in_tabpage = sort(tabpagebuflist())
    4              0.000008     if exists("*uniq")
    4              0.000009       let buffers_in_tabpage = uniq(buffers_in_tabpage)
    4              0.000002     endif
                                " mapped might be something like ['normal', 'normal_modified']
                                " if a group is in both modes available, only define the second
                                " that is how this was done previously overwrite the previous definition
    8              0.000015     for mode in reverse(mapped)
    4              0.000021       if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000013         let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   80              0.000206         for kvp in items(dict)
   76              0.000141           let mode_colors = kvp[1]
   76              0.000104           let name = kvp[0]
   76              0.000200           if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                        let name = 'airline_c'.bufnr
   76              0.000035           endif
                                      " do not re-create highlighting for buffers that are no longer visible
                                      " in the current tabpage
   76              0.000422           if name =~# 'airline_c\d\+'
    8              0.000058             let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
    8              0.000025             if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
    8              0.000006               continue
                                        endif
   68              0.000353           elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                        " group will be redefined below at exec_separator
                                        " or is not needed for tabline with '_inactive' suffix
                                        " since active flag is 1 for builder)
   32              0.000027             continue
   36              0.000015           endif
   36   0.000520   0.000270           if s:group_not_done(airline_grouplist, name.suffix)
   36   0.010535   0.000291             call airline#highlighter#exec(name.suffix, mode_colors)
   36              0.000019           endif
                            
   36              0.000072           if !has_key(p, 'accents')
                                        " work around a broken installation
                                        " shouldn't actually happen, p should always contain accents
                                        continue
   36              0.000018           endif
                            
  108              0.000176           for accent in keys(s:accents)
   72              0.000165             if !has_key(p.accents, accent)
                                          continue
   72              0.000032             endif
   72              0.000212             let colors = copy(mode_colors)
   72              0.000162             if p.accents[accent][0] != ''
   36              0.000087               let colors[0] = p.accents[accent][0]
   72              0.000030             endif
   72              0.000126             if p.accents[accent][2] != ''
   36              0.000069               let colors[2] = p.accents[accent][2]
   72              0.000026             endif
   72              0.000115             if len(colors) >= 5
   72              0.000276               let colors[4] = get(p.accents[accent], 4, '')
                                        else
                                          call add(colors, get(p.accents[accent], 4, ''))
   72              0.000030             endif
   72   0.001097   0.000635             if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   72   0.020889   0.000621               call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   72              0.000039             endif
  108              0.000066           endfor
   40              0.000023         endfor
                            
    4              0.000008         if empty(s:separators)
                                      " nothing to be done
                                      continue
    4              0.000002         endif
                                    " TODO: optimize this
   44              0.000083         for sep in items(s:separators)
                                      " we cannot check, that the group already exists, else the separators
                                      " might not be correctly defined. But perhaps we can skip above groups
                                      " that match the '_to_' name, because they would be redefined here...
   40   0.026864   0.000470           call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   44              0.000030         endfor
    4              0.000002       endif
    8              0.000010     endfor

FUNCTION  <SNR>80_check_defined_section()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:47
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000007   if !exists('w:airline_section_{a:name}')
    2              0.000009     let w:airline_section_{a:name} = g:airline_section_{a:name}
    2              0.000001   endif

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/highlight.vim:44
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000013     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  ale#handlers#writegood#DefineLinter()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/writegood.vim:64
Called 2 times
Total time:   0.000485
 Self time:   0.000033

count  total (s)   self (s)
    2   0.000483   0.000032     call ale#linter#Define(a:filetype, {   'name': 'writegood',   'aliases': ['write-good'],   'executable': function('ale#handlers#writegood#GetExecutable'),   'command': function('ale#handlers#writegood#GetCommand'),   'callback': 'ale#handlers#writegood#Handle',})

FUNCTION  airline#parts#ffenc()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:108
Called 18 times
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
   18              0.000053   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   18              0.000033   let bomb     = &bomb ? '[BOM]' : ''
   18              0.000093   let noeolf   = &eol ? '' : '[!EOL]'
   18              0.000164   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   18              0.000098   if expected is# &fenc.bomb.noeolf.ff
                                return ''
   18              0.000007   else
   18              0.000094     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  <SNR>109_RunLinter()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:579
Called 7 times
Total time:   0.201750
 Self time:   0.000171

count  total (s)   self (s)
    7              0.000018     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
    7              0.000004     else
    7   0.090308   0.000057         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    7   0.111395   0.000067         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/nvimlsp.vim:42
Called 18 times
Total time:   0.000404
 Self time:   0.000112

count  total (s)   self (s)
   18   0.000396   0.000104   return airline#extensions#nvimlsp#get('Error')

FUNCTION  airline#util#ignore_buf()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:136
Called 18 times
Total time:   0.000427
 Self time:   0.000427

count  total (s)   self (s)
   18              0.000121   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
   18              0.000286   return match(a:name, pat) > -1

FUNCTION  airline#extensions#wordcount#formatters#default#update_fmt()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim:6
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000008   let s:fmt = get(g:, 'airline#extensions#wordcount#formatter#default#fmt', '%s words')
    1              0.000005   let s:fmt_short = get(g:, 'airline#extensions#wordcount#formatter#default#fmt_short', s:fmt == '%s words' ? '%sW' : s:fmt)

FUNCTION  airline#parts#get()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:49
Called 18 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   18              0.000067   return get(s:parts, a:key, {})

FUNCTION  sy#highlight#line_disable()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/highlight.vim:42
Called 1 time
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000018   execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl='
    1              0.000008   execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl='
    1              0.000008   execute 'sign define SignifyChangeDelete text='. s:sign_change_delete 'texthl=SignifySignChangeDelete linehl='
    1              0.000007   execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl='
    1              0.000002   let g:signify_line_highlight = 0

FUNCTION  airline#extensions#prepend_to_section()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:58
Called 1 time
Total time:   0.000023
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000018   0.000008   call <sid>check_defined_section(a:name)
    1              0.000005   let w:airline_section_{a:name} = a:value . w:airline_section_{a:name}

FUNCTION  airline#update_statusline()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:144
Called 1 time
Total time:   0.023416
 Self time:   0.000059

count  total (s)   self (s)
    1   0.000040   0.000008   if airline#util#stl_disabled(winnr())
                                return
    1              0.000000   endif
    1              0.000007   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    1   0.000064   0.000007   call airline#update_statusline_inactive(range)
                            
    1              0.000002   unlet! w:airline_render_left w:airline_render_right
    1              0.000012   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    1              0.000001   let w:airline_active = 1
    1              0.000005   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.023280   0.000013   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:95
Called 18 times
Total time:   0.003158
 Self time:   0.001697

count  total (s)   self (s)
   18              0.000041   if !get(w:, 'airline_active', 0)
                                return ''
   18              0.000007   endif
                              " Cache values, so that it isn't called too often
   18   0.000480   0.000341   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
   18              0.000008   endif
   18   0.001041   0.000136   let hunks = airline#extensions#hunks#get_raw_hunks()
   18              0.000019   let string = ''
   18   0.000203   0.000123   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   18              0.000028   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
   32              0.000039     for i in [0, 1, 2]
   24   0.000337   0.000168       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
   24              0.000104         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
   24              0.000012       endif
   32              0.000019     endfor
   18              0.000008   endif
   18   0.000225   0.000185   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
    8              0.000015     let string = string[0:-2]
   18              0.000008   endif
                            
   18              0.000032   let b:airline_hunks = string
   18              0.000029   let b:airline_changenr = b:changedtick
   18   0.000217   0.000091   let s:airline_winwidth = airline#util#winwidth()
   18              0.000017   return string

FUNCTION  ale#util#BinarySearch()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/util.vim:231
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002     let l:min = 0
    1              0.000003     let l:max = len(a:loclist) - 1
                            
    1              0.000001     while 1
    1              0.000001         if l:max < l:min
    1              0.000001             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  airline#parts#readonly()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:89
Called 18 times
Total time:   0.000723
 Self time:   0.000297

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
   18   0.000581   0.000154   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
   18              0.000008   endif
   18              0.000041   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   18              0.000007   else
   18              0.000029     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>86_group_not_done()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:32
Called 108 times
Total time:   0.000712
 Self time:   0.000712

count  total (s)   self (s)
  108              0.000298     if index(a:list, a:name) == -1
  108              0.000251       call add(a:list, a:name)
  108              0.000090       return 1
                                else
                                  if &vbs
                                    echomsg printf("airline: group: %s already done, skipping", a:name)
                                  endif
                                  return 0
                                endif

FUNCTION  <SNR>111_IsCallback()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:75
Called 20 times
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
   20              0.000080     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  <SNR>87_coc_git_enabled()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:18
Called 10 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   10              0.000033   if !exists("*CocAction") || !get(g:, 'airline#extensions#hunks#coc_git', 0)
                                 " coc-git extension is disabled by default
                                 " unless specifically being enabled by the user
                                 " (as requested from coc maintainer)
   10              0.000008     return 0
                              endif
                              return 1

FUNCTION  ale#engine#RunLinters()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:679
Called 1 time
Total time:   0.202680
 Self time:   0.000038

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    1   0.000018   0.000007     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    1   0.202660   0.000030     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim:37
Called 5 times
Total time:   0.071042
 Self time:   0.071042

count  total (s)   self (s)
    5              0.000065     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
    5              0.000018     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
    5              0.070910     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
    5              0.000017     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
    5              0.000003     endif
                            
    5              0.000005     return ''

FUNCTION  airline#builder#should_change_group()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:130
Called 6 times
Total time:   0.001977
 Self time:   0.000135

count  total (s)   self (s)
    6              0.000010   if a:group1 == a:group2
                                return 0
    6              0.000002   endif
    6   0.000956   0.000043   let color1 = airline#highlighter#get_highlight(a:group1)
    6   0.000972   0.000043   let color2 = airline#highlighter#get_highlight(a:group2)
    6              0.000026   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#highlighter#exec()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:219
Called 159 times
Total time:   0.045608
 Self time:   0.013755

count  total (s)   self (s)
  159              0.000216     if pumvisible()
                                  return
  159              0.000071     endif
  159              0.000232     let colors = a:colors
  159              0.000278     if len(colors) == 4
   47              0.000093       call add(colors, '')
  159              0.000062     endif
                                " colors should always be string values
  159              0.002845     let colors = map(copy(colors), 'type(v:val) != type("") ? string(v:val) : v:val')
  159              0.000170     if s:is_win32term
                                  let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                  let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  159              0.000063     endif
  159   0.025683   0.001224     let old_hi = airline#highlighter#get_highlight(a:group)
  159              0.001077     let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  159   0.003083   0.000966     let colors = s:CheckDefined(colors)
  159   0.002424   0.000949     if old_hi != new_hi || !s:hl_group_exists(a:group)
   41   0.004108   0.000307       let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   41              0.000026       try
   41              0.000377         exe cmd
                                  catch /^Vim\%((\a\+)\)\=:E421:/ " color definition not found
                                    let group=matchstr(v:exception, '\w\+\ze=')
                                    let color=matchstr(v:exception, '=\zs\w\+')
                                    let cmd=substitute(cmd, color, 'grey', 'g')
                                    exe cmd
                                    call airline#util#warning('color definition for group ' . a:group . ' not found, using grey as fallback')
                                  catch
                                    call airline#util#warning('Error when running command: '. cmd)
   41              0.000040       endtry
   41              0.000102       if has_key(s:hl_groups, a:group)
   41              0.000094         let s:hl_groups[a:group] = colors
   41              0.000019       endif
  159              0.000066     endif

FUNCTION  <SNR>79_Lint()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:99
Called 1 time
Total time:   0.417541
 Self time:   0.000088

count  total (s)   self (s)
                                " Use the filetype from the buffer
    1              0.000003     let l:filetype = getbufvar(a:buffer, '&filetype')
    1   0.214735   0.000015     let l:linters = ale#linter#Get(l:filetype)
    1   0.000053   0.000014     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    1              0.000002     let g:ale_want_results_buffer = a:buffer
    1   0.000024   0.000009     silent doautocmd <nomodeline> User ALEWantResults
    1              0.000002     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    1              0.000004     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    1              0.000001     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    1              0.000022     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    1   0.202690   0.000010     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  sy#buffer_is_active()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:108
Called 10 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   10              0.000027   let bufnr = a:0 ? a:1 : bufnr('')
   10              0.000033   return !empty(getbufvar(bufnr, 'sy'))

FUNCTION  <SNR>111_GetLinterNames()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:330
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000003     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    1              0.000001     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    1              0.000000     endif
                            
                                " b:ale_linters can be set to a List.
    1              0.000002     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    1              0.000000     endif
                            
                                " Try to get a buffer-local setting for the filetype
    1              0.000002     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    1              0.000000     endif
                            
                                " Try to get a global setting for the filetype
    1              0.000002     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    1              0.000000     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    1              0.000001     if g:ale_linters_explicit
                                    return []
    1              0.000000     endif
                            
                                " Try to get a default setting for the filetype
    1              0.000003     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    1              0.000000     endif
                            
    1              0.000001     return 'all'

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/util.vim:484
Called 1 time
Total time:   0.000043
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000008     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1              0.000003     let l:loclist = get(l:info, 'loclist', [])
    1              0.000005     let l:pos = getpos('.')
    1   0.000020   0.000009     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    1              0.000004     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    1              0.000002     return [l:info, l:loc]

FUNCTION  ale_linters#markdown#mdl#GetExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/mdl.vim:7
Called 1 time
Total time:   0.000017
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000016   0.000005     return ale#Var(a:buffer, 'markdown_mdl_executable')

FUNCTION  sy#repo#get_stats()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:232
Called 8 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    8              0.000039   let sy = getbufvar(a:0 ? a:1 : bufnr(''), 'sy')
    8              0.000024   return empty(sy) ? [-1, -1, -1] : sy.stats

FUNCTION  <SNR>97_section_is_empty()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:182
Called 9 times
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    9              0.000011   let start=1
                            
                              " do not check for inactive windows or the tabline
    9              0.000013   if a:self._context.active == 0
                                return 0
    9              0.000020   elseif get(a:self._context, 'tabline', 0)
                                return 0
    9              0.000004   endif
                            
                              " only check, if airline#skip_empty_sections == 1
    9              0.000019   if get(g:, 'airline_skip_empty_sections', 0) == 0
    9              0.000006     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>120_get_vcs_path()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:494
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000019   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? getbufvar(a:bufnr, 'sy').info.file : getbufvar(a:bufnr, 'sy').info.path

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:53
Called 1 time
Total time:   0.000018
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000014   0.000006   call <sid>check_defined_section(a:name)
    1              0.000003   let w:airline_section_{a:name} .= a:value

FUNCTION  quick_scope#UnhighlightLine()
    Defined: ~/local/share/nvim/site/pack/packer/start/quick-scope/autoload/quick_scope.vim:64
Called 2 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    3              0.000046   for m in filter(getmatches(), printf('v:val.group ==# "%s" || v:val.group ==# "%s"', g:qs_hi_group_primary, g:qs_hi_group_secondary))
    1              0.000003     call matchdelete(m.id)
    3              0.000003   endfor

FUNCTION  <SNR>86_get_array()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:60
Called 265 times
Total time:   0.001539
 Self time:   0.001539

count  total (s)   self (s)
  265              0.001437     return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  <SNR>112_StopCursorTimer()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/cursor.vim:56
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000005     if s:cursor_timer != -1
    1              0.000004         call timer_stop(s:cursor_timer)
    1              0.000002         let s:cursor_timer = -1
    3              0.000001     endif

FUNCTION  sy#sign#process_diff()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:55
Called 1 time
Total time:   0.004230
 Self time:   0.001292

count  total (s)   self (s)
    1              0.000010   let a:sy.signtable             = {}
    1              0.000009   let a:sy.hunks                 = []
    1              0.000003   let [added, modified, deleted] = [0, 0, 0]
                            
    1   0.001469   0.000010   call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
    2              0.000113   for line in filter(a:diff, 'v:val =~ "^@@ "')
    1              0.000003     let a:sy.lines = []
    1              0.000001     let ids        = []
                            
    1   0.000031   0.000011     let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
    1              0.000002     if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
    1              0.000001     endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
    1              0.000001     if old_count == 0 && new_count > 0
                                  let added += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
                                  endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
    1              0.000002     elseif old_count > 0 && new_count == 0
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    if old_count > 99
                                      let text = s:sign_delete . '>'
                                    elseif old_count < 2
                                      let text = s:sign_delete
                                    else
                                      let text = s:sign_delete . old_count
                                    endif
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                                " All lines are modified.
    1              0.000002     elseif old_count > 0 && new_count > 0 && old_count == new_count
                                  let modified += new_count
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    let offset += 1
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                  endwhile
                                " Some lines are modified and some new lines are added.
    1              0.000002     elseif old_count > 0 && new_count > 0 && old_count < new_count
    1              0.000002       let modified += old_count
    1              0.000002       let added += new_count - old_count
    1              0.000001       let offset = 0
   31              0.000031       while offset < old_count
   30              0.000038         let line    = new_line + offset
   30              0.000027         let offset += 1
   59   0.000292   0.000196         if s:external_sign_present(a:sy, line) | continue | endif
   30   0.001094   0.000169         call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
   31              0.000015       endwhile
   14              0.000014       while offset < new_count
   13              0.000016         let line    = new_line + offset
   13              0.000011         let offset += 1
   25   0.000119   0.000079         if s:external_sign_present(a:sy, line) | continue | endif
   13   0.000455   0.000070         call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
   14              0.000006       endwhile
                                " Some lines are modified and some lines are deleted.
                                elseif old_count > 0 && new_count > 0 && old_count > new_count
                                  let modified += new_count
                                  let deleted_count = old_count - new_count
                                  let deleted += deleted_count
                            
                                  let prev_line_available = new_line > 1 && !get(a:sy.signtable, new_line - 1, 0)
                                  if prev_line_available
                                    if s:sign_show_count
                                      if deleted_count > 99
                                        let text = s:sign_delete . '>'
                                      elseif deleted_count < 2
                                        let text = s:sign_delete
                                      else
                                        let text = s:sign_delete . deleted_count
                                      endif
                                      while strwidth(text) > 2
                                        let text = substitute(text, '.', '', '')
                                      endwhile
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDelete'. deleted_count, text))
                                    else
                                      call add(ids, s:add_sign(a:sy, new_line - 1, 'SignifyDeleteMore', s:sign_delete))
                                    endif
                                  endif
                            
                                  let offset = 0
                                  while offset < new_count
                                    let line    = new_line + offset
                                    if s:external_sign_present(a:sy, line) | continue | endif
                                    if !prev_line_available && offset == 0
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChangeDelete'))
                                    else
                                      call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
                                    endif
                                    let offset += 1
                                  endwhile
    1              0.000000     endif
                            
    1              0.000002     if !empty(ids)
    1              0.000006       call add(a:sy.hunks, { 'ids'  : ids, 'start': a:sy.lines[0], 'end'  : a:sy.lines[-1] })
    1              0.000000     endif
    2              0.000005   endfor
                            
                              " Remove obsoleted signs.
    1              0.000062   for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
                                execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
    1              0.000001   endfor
                            
    1              0.000003   if empty(a:sy.updated_by) && empty(a:sy.hunks)
                                call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
                                return
    1              0.000000   endif
                            
    1   0.000024   0.000011   call sy#verbose('Signs updated.', a:vcs)
    1              0.000002   let a:sy.updated_by = a:vcs
    1              0.000002   if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
    1              0.000000   endif
                            
    1              0.000003   let a:sy.stats = [added, modified, deleted]

FUNCTION  ale#statusline#Update()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:21
Called 1 time
Total time:   0.000066
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000003     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
    1              0.000000     endif
                            
    1              0.000004     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    1   0.000012   0.000006     let l:count = s:CreateCountDict()
    1              0.000002     let l:count.total = len(l:loclist)
                            
                                " Allows easy access to the first instance of each problem type.
    1              0.000001     let l:first_problems = {}
                            
    1              0.000002     for l:entry in l:loclist
                                    if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                            
                                            if l:count.style_warning == 1
                                                let l:first_problems.style_warning = l:entry
                                            endif
                                        else
                                            let l:count.warning += 1
                            
                                            if l:count.warning == 1
                                                let l:first_problems.warning = l:entry
                                            endif
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                            
                                        if l:count.info == 1
                                            let l:first_problems.info = l:entry
                                        endif
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                            
                                        if l:count.style_error == 1
                                            let l:first_problems.style_error = l:entry
                                        endif
                                    else
                                        let l:count.error += 1
                            
                                        if l:count.error == 1
                                            let l:first_problems.error = l:entry
                                        endif
                                    endif
    1              0.000001     endfor
                            
                                " Set keys for backwards compatibility.
    1              0.000003     let l:count[0] = l:count.error + l:count.style_error
    1              0.000002     let l:count[1] = l:count.total - l:count[0]
                            
    1              0.000002     let g:ale_buffer_info[a:buffer].count = l:count
    1              0.000003     let g:ale_buffer_info[a:buffer].first_problems = l:first_problems

FUNCTION  airline#extensions#searchcount#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/searchcount.vim:15
Called 1 time
Total time:   0.000026
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000025   0.000008   call airline#extensions#append_to_section('y', '%{v:hlsearch ? airline#extensions#searchcount#status() : ""}')

FUNCTION  airline#parts#spell()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:67
Called 18 times
Total time:   0.000426
 Self time:   0.000426

count  total (s)   self (s)
   18              0.000172   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   18              0.000034   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                elseif !empty(g:airline_symbols.spell)
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   18              0.000007   endif
   18              0.000012   return ''

FUNCTION  ale#linter#GetAll()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:271
Called 1 time
Total time:   0.214466
 Self time:   0.023569

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    1   0.000011   0.000004     if ale#util#InSandbox()
                                    return []
    1              0.000000     endif
                            
    1              0.000002     let l:combined_linters = []
                            
    2              0.000003     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    1              0.000004         if !has_key(s:runtime_loaded_map, l:filetype)
    1   0.214417   0.023527             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    1              0.000005             let s:runtime_loaded_map[l:filetype] = 1
    1              0.000001         endif
                            
    1              0.000006         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    2              0.000002     endfor
                            
    1              0.000001     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:320
Called 1 time
Total time:   0.000052
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000047   0.000009     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    1              0.000002     if type(l:filetype) isnot v:t_list
    1              0.000001         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>110_UpdateCacheIfNecessary()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:78
Called 36 times
Total time:   0.000335
 Self time:   0.000268

count  total (s)   self (s)
                                " Cache is cold, so manually ask for an update.
   36              0.000109     if !has_key(g:ale_buffer_info[a:buffer], 'count')
    1   0.000074   0.000008         call ale#statusline#Update(   a:buffer,   g:ale_buffer_info[a:buffer].loclist)
   36              0.000015     endif

FUNCTION  <SNR>120_handle_diff()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/repo.vim:116
Called 1 time
Total time:   0.004427
 Self time:   0.000081

count  total (s)   self (s)
    1   0.000022   0.000006   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
    1              0.000002   if has_key(a:options, 'tempfiles')
                                for f in a:options.tempfiles
                                  call delete(f)
                                endfor
    1              0.000000   endif
                            
    1              0.000003   let sy = getbufvar(a:options.bufnr, 'sy')
    1              0.000001   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
    1              0.000003   elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
    1              0.000001   elseif empty(sy.vcs)
                                let sy.detecting -= 1
    1              0.000000   endif
                            
    1              0.000005   let fenc = getbufvar(a:options.bufnr, '&fenc')
    1              0.000004   let enc  = getbufvar(a:options.bufnr, '&enc')
    1              0.000002   if (fenc != enc) && has('iconv')
                                call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
    1              0.000000   endif
                            
    1   0.000014   0.000011   let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
    1              0.000001   if found_diff
    1              0.000003     if index(sy.vcs, a:options.vcs) == -1
                                  let sy.vcs += [a:options.vcs]
    1              0.000000     endif
    1   0.004335   0.000008     call a:options.func(sy, a:options.vcs, diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    1              0.000000   endif
                            
    1              0.000004   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  ale#util#Mode()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/util.vim:5
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000010     return call('mode', a:000)

FUNCTION  <SNR>92_get_wordcount()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:8
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000007     if get(g:, 'actual_curbuf', '') != bufnr('')
    1              0.000001       return
    1              0.000000     endif
    1              0.000002     let query = a:visual_mode_active ? 'visual_words' : 'words'
    1              0.000004     return get(wordcount(), query, 0)

FUNCTION  <SNR>109_StopCurrentJobs()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:449
Called 1 time
Total time:   0.000088
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1   0.000027   0.000007     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    1              0.000001     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
    1              0.000000     else
    1              0.000001         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
   11              0.000011         for [l:lint_file, l:linter] in a:linter_slots
   10              0.000008             if l:lint_file is 1
    3              0.000006                 let l:lint_file_map[l:linter.name] = 1
   10              0.000004             endif
   11              0.000005         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    1              0.000003         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    1              0.000001     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/util.vim:289
Called 3 times
Total time:   0.000043
 Self time:   0.000042

count  total (s)   self (s)
    3              0.000003     try
    3   0.000023   0.000021         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
    3              0.000002     endtry
                            
    3              0.000002     return 0

FUNCTION  airline#parts#crypt()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:59
Called 18 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
   18              0.000170   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  ale#path#Simplify()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim:15
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     if has('unix')
    1              0.000008         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
    1              0.000008         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  <SNR>64_on_cursor_moved()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/plugin/airline.vim:83
Called 1 time
Total time:   0.000018
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
    1              0.000000   endif
    1   0.000012   0.000005   call airline#update_tabline()

FUNCTION  ale#handlers#writegood#GetExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/writegood.vim:13
Called 1 time
Total time:   0.001226
 Self time:   0.000010

count  total (s)   self (s)
    1   0.001225   0.000009     return ale#path#FindExecutable(a:buffer, 'writegood', [   'node_modules/.bin/write-good',   'node_modules/write-good/bin/write-good.js',])

FUNCTION  <SNR>87_get_hunks_empty()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:72
Called 10 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
   10              0.000008   return ''

FUNCTION  sy#sign#set_signs()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:235
Called 1 time
Total time:   0.004326
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000016   0.000005   call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
    1              0.000002   if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
    1              0.000000   endif
                            
    1              0.000001   if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
    1              0.000000   endif
                            
    1              0.000002   if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
    1              0.000000   else
    1   0.000049   0.000007     call sy#highlight#line_disable()
    1              0.000001   endif
                            
    1   0.004238   0.000008   call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
    1              0.000005   if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
    1              0.000000   endif

FUNCTION  <SNR>110_GetCounts()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/statusline.vim:97
Called 36 times
Total time:   0.001211
 Self time:   0.000627

count  total (s)   self (s)
   36   0.000461   0.000212     if !s:BufferCacheExists(a:buffer)
                                    return s:CreateCountDict()
   36              0.000014     endif
                            
   36   0.000573   0.000238     call s:UpdateCacheIfNecessary(a:buffer)
                            
   36              0.000065     return g:ale_buffer_info[a:buffer].count

FUNCTION  <SNR>35_Remove_Matches()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
    1              0.000000   endif

FUNCTION  <SNR>27_LoadFTPlugin()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.033995
 Self time:   0.014386

count  total (s)   self (s)
    1              0.000003     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000004     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000013       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000008       for name in split(s, '\.')
    1   0.027521   0.007912         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.006421         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  airline#parts#mode()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/parts.vim:55
Called 18 times
Total time:   0.000672
 Self time:   0.000164

count  total (s)   self (s)
   18   0.000660   0.000153   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  ale#highlight#BufferHidden()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/highlight.vim:193
Called 1 time
Total time:   0.000040
 Self time:   0.000011

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
    1   0.000038   0.000009     call ale#highlight#RemoveHighlights()

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/hunks.vim:76
Called 18 times
Total time:   0.000905
 Self time:   0.000623

count  total (s)   self (s)
   18              0.000078   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
   10   0.000132   0.000064     if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
   10              0.000024     elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
   10              0.000019     elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
   10              0.000021     elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
   10   0.000116   0.000058     elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
   10              0.000005     else
   10              0.000016       let b:source_func = 's:get_hunks_empty'
   10              0.000005     endif
   18              0.000007   endif
   18   0.000293   0.000136   return {b:source_func}()

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000002   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    1              0.000001   endif

FUNCTION  <SNR>98_build_sections()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:35
Called 2 times
Total time:   0.000757
 Self time:   0.000104

count  total (s)   self (s)
   10              0.000010   for key in a:keys
    8              0.000020     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
    8              0.000003     endif
    8   0.000699   0.000046     call s:add_section(a:builder, a:context, key)
   10              0.000006   endfor

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 1 time
Total time:   0.013848
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000007   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    1              0.000002   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    1              0.000001   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
    1              0.000006     let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
    1              0.000016     if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
    1              0.000002       let b:airline_changedtick = -1
    1   0.013767   0.000009       call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
    1              0.000000     endif
    1              0.000000   endif
                            
    1              0.000002   if exists('b:airline_wordcount')
    1   0.000034   0.000011     call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    1              0.000000   endif

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:413
Called 1 time
Total time:   0.000039
 Self time:   0.000018

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    1   0.000019   0.000006     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    1   0.000014   0.000005     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    1              0.000005     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/path.vim:82
Called 3 times
Total time:   0.071259
 Self time:   0.000161

count  total (s)   self (s)
    8              0.000013     for l:path in a:path_list
    5   0.000085   0.000030         if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
    5              0.000003         else
    5   0.071081   0.000039             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
    5              0.000003         endif
                            
    5              0.000009         if !empty(l:executable)
                                        return l:executable
    5              0.000002         endif
    8              0.000008     endfor
                            
    3              0.000002     return ''

FUNCTION  <SNR>108_skip()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy.vim:165
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000023   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
    1              0.000001     return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return 0

FUNCTION  <SNR>35_Highlight_Matching_Pair()
    Defined: /gctmp/jesmith/.mount_nvimHuHqbv/usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 1 time
Total time:   0.000074
 Self time:   0.000066

count  total (s)   self (s)
                              " Remove any previous match.
    1   0.000013   0.000006   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    1              0.000003   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    1              0.000000   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    1              0.000002   let c_lnum = line('.')
    1              0.000002   let c_col = col('.')
    1              0.000001   let before = 0
                            
    1              0.000002   let text = getline(c_lnum)
    1              0.000014   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    1              0.000002   if empty(matches)
                                let [c_before, c] = ['', '']
    1              0.000001   else
    1              0.000003     let [c_before, c] = matches[1:2]
    1              0.000000   endif
    1              0.000010   let plist = split(&matchpairs, '.\zs[:,]')
    1              0.000003   let i = index(plist, c)
    1              0.000001   if i < 0
                                " not found, in Insert mode try character before the cursor
    1              0.000003     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    1              0.000000     endif
    1              0.000001     if i < 0
                                  " not found, nothing to do
    1              0.000001       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  airline#extensions#wordcount#get()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount.vim:74
Called 10 times
Total time:   0.000176
 Self time:   0.000153

count  total (s)   self (s)
   10              0.000023   if get(g:, 'airline#visual_active', 0)
                                return s:format_wordcount(s:get_wordcount(1))
   10              0.000004   else
   10              0.000025     if get(b:, 'airline_changedtick', 0) != b:changedtick
    1   0.000029   0.000006       call s:update_wordcount(0)
    1              0.000002       let b:airline_changedtick = b:changedtick
   10              0.000005     endif
   10              0.000021     return get(b:, 'airline_wordcount', '')
                              endif

FUNCTION  <SNR>109_RunIfExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:527
Called 7 times
Total time:   0.111328
 Self time:   0.000330

count  total (s)   self (s)
    7   0.000074   0.000041     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
    7              0.000003     endif
                            
    7   0.111021   0.000056     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
                                    let l:job_type = a:lint_file ? 'file_linter' : 'linter'
                                    call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
                                    let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
                                    endif
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
                                    if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
                                    endif
                            
                                    let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
                                    return s:RunJob(l:command, l:options)
    7              0.000003     endif
                            
    7              0.000006     return 0

FUNCTION  airline#statusline()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline.vim:207
Called 18 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
   18              0.000107   if has_key(s:contexts, a:winnr)
   18              0.000123     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#extensions#wordcount#formatters#default#to_string()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/wordcount/formatters/default.vim:27
Called 1 time
Total time:   0.000055
 Self time:   0.000044

count  total (s)   self (s)
    1   0.000017   0.000006   if airline#util#winwidth() > 85
    1              0.000001     if a:wordcount > 999
                                  " Format number according to locale, e.g. German: 1.245 or English: 1,245
                                  let wordcount = substitute(a:wordcount, '\d\@<=\(\(\d\{3\}\)\+\)$', s:decimal_group.'&', 'g')
    1              0.000001     else
    1              0.000001       let wordcount = a:wordcount
    1              0.000001     endif
    1              0.000013     let str = printf(s:fmt, wordcount)
                              else
                                let str = printf(s:fmt_short, a:wordcount)
    1              0.000001   endif
                            
    1              0.000004   let str .= g:airline_symbols.space
                            
    1              0.000003   if !empty(g:airline_right_alt_sep)
                                let str .= g:airline_right_alt_sep . g:airline_symbols.space
    1              0.000001   endif
                            
    1              0.000002   return str

FUNCTION  <lambda>11()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/remark_lint.vim:38
Called 1 time
Total time:   0.003280
 Self time:   0.001646

count  total (s)   self (s)
                            return ale#path#FindExecutable(b, 'markdown_remark_lint', [       'node_modules/.bin/remark',   ])

FUNCTION  <lambda>12()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/ale_linters/markdown/vale.vim:18
Called 1 time
Total time:   0.000017
 Self time:   0.000005

count  total (s)   self (s)
                            return ale#Var(b, 'markdown_vale_executable')

FUNCTION  <SNR>109_RunLinters()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:638
Called 1 time
Total time:   0.202230
 Self time:   0.000226

count  total (s)   self (s)
    1   0.000097   0.000009     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    1   0.000051   0.000010     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    1   0.000018   0.000007     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    1   0.000011   0.000005     silent doautocmd <nomodeline> User ALELintPre
                            
   11              0.000018     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
   10              0.000014         if !l:lint_file || a:should_lint_file
    7   0.201811   0.000061             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
                                            let l:can_clear_results = 0
    7              0.000004             endif
    3              0.000001         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
    3              0.000004             let l:can_clear_results = 0
   10              0.000004         endif
   11              0.000007     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    1              0.000001     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    1              0.000001     elseif a:new_buffer
    1   0.000131   0.000023         call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    1              0.000000     endif

FUNCTION  ale#Set()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale.vim:190
Called 30 times
Total time:   0.001552
 Self time:   0.001552

count  total (s)   self (s)
   30              0.000116     let l:full_name = 'ale_' . a:variable_name
                            
   30              0.001304     if !has_key(g:, l:full_name)
   19              0.000062         let g:[l:full_name] = a:default
   30              0.000018     endif

FUNCTION  <SNR>90_ws_refresh()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/whitespace.vim:186
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000004   if !exists('#airline')
                                " airline disabled
                                return
    2              0.000001   endif
    2              0.000007   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    1              0.000001     return
    1              0.000000   endif
    1              0.000004   unlet! b:airline_whitespace_check
    1              0.000002   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    1              0.000000   endif
    1              0.000002   let b:airline_ws_changedtick = b:changedtick

FUNCTION  ale#linter#PreProcess()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:83
Called 20 times
Total time:   0.003812
 Self time:   0.003580

count  total (s)   self (s)
   20              0.000054     if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
   20              0.000012     endif
                            
   20              0.000113     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                            
   20              0.000046     if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
   20              0.000008     endif
                            
   20              0.000045     let l:needs_address = l:obj.lsp is# 'socket'
   20              0.000039     let l:needs_executable = l:obj.lsp isnot# 'socket'
   20              0.000032     let l:needs_command = l:obj.lsp isnot# 'socket'
   20              0.000049     let l:needs_lsp_details = !empty(l:obj.lsp)
                            
   20              0.000030     if empty(l:obj.lsp)
   20              0.000055         let l:obj.callback = get(a:linter, 'callback')
                            
   20   0.000227   0.000137         if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
   20              0.000010         endif
   20              0.000010     endif
                            
   20              0.000082     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
   20              0.000008     endif
                            
   20              0.000021     if !l:needs_executable
                                    if has_key(a:linter, 'executable')
                                        throw '`executable` cannot be used when lsp == ''socket'''
                                    endif
   20              0.000039     elseif has_key(a:linter, 'executable')
   20              0.000039         let l:obj.executable = a:linter.executable
                            
   20              0.000097         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
   20              0.000008         endif
                                else
                                    throw '`executable` must be defined'
   20              0.000008     endif
                            
   20              0.000019     if !l:needs_command
                                    if has_key(a:linter, 'command')
                                        throw '`command` cannot be used when lsp == ''socket'''
                                    endif
   20              0.000031     elseif has_key(a:linter, 'command')
   20              0.000036         let l:obj.command = a:linter.command
                            
   20              0.000068         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
   20              0.000008         endif
                                else
                                    throw '`command` must be defined'
   20              0.000008     endif
                            
   20              0.000017     if !l:needs_address
   20              0.000030         if has_key(a:linter, 'address')
                                        throw '`address` cannot be used when lsp != ''socket'''
   20              0.000007         endif
                                elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                            
                                    if has_key(a:linter, 'cwd')
                                        throw '`cwd` makes no sense for socket LSP connections'
                                    endif
                                else
                                    throw '`address` must be defined for getting the LSP address'
   20              0.000008     endif
                            
   20              0.000028     if has_key(a:linter, 'cwd')
                                    let l:obj.cwd = a:linter.cwd
                            
                                    if type(l:obj.cwd) isnot v:t_string&& type(l:obj.cwd) isnot v:t_func
                                        throw '`cwd` must be a String or Function if defined'
                                    endif
   20              0.000007     endif
                            
   20              0.000019     if l:needs_lsp_details
                                    " Default to using the filetype as the language.
                                    let l:obj.language = get(a:linter, 'language', a:filetype)
                            
                                    if type(l:obj.language) isnot v:t_string&& type(l:obj.language) isnot v:t_func
                                        throw '`language` must be a String or Function if defined'
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function'
                                        endif
                                    else
                                        throw '`project_root` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a Dictionary or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
   20              0.000008     endif
                            
   20              0.000058     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
   20              0.000099     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
   20              0.000007     endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
   20              0.000078     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
   20   0.000218   0.000140     if !s:IsBoolean(l:obj.lint_file) && type(l:obj.lint_file) isnot v:t_func
                                    throw '`lint_file` must be `0`, `1`, or a Function'
   20              0.000008     endif
                            
                                " An option indicating that the buffer should be read.
   20              0.000053     let l:obj.read_buffer = get(a:linter, 'read_buffer', 1)
                            
   20   0.000160   0.000095     if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
   20              0.000007     endif
                            
   20              0.000052     let l:obj.aliases = get(a:linter, 'aliases', [])
                            
   20              0.000127     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
   20              0.000007     endif
                            
   20              0.000020     return l:obj

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:68
Called 265 times
Total time:   0.040454
 Self time:   0.016988

count  total (s)   self (s)
                                " only check for the cterm reverse attribute
                                " TODO: do we need to check all modes (gui, term, as well)?
  265              0.001859     let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  265              0.001028     if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                  let res = s:hl_groups[a:group]
                                  return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  265              0.000157     else
  265   0.007450   0.001584       let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  265   0.007036   0.001459       let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  265   0.006763   0.001441       let guifg = s:get_syn(a:group, 'fg', 'gui')
  265   0.006532   0.001369       let guibg = s:get_syn(a:group, 'bg', 'gui')
  265              0.001484       let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  265              0.000239       if reverse
                                    let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  265              0.000126       else
  265   0.003651   0.002112         let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  265              0.000128       endif
  265              0.000108     endif
  265              0.000989     let s:hl_groups[a:group] = res
  265              0.000217     return res

FUNCTION  ale#history#Add()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/history.vim:12
Called 7 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    7              0.000013     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
    7              0.000004     endif
                            
    7              0.000033     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    7              0.000019     if len(l:history) >= g:ale_max_buffer_history_size
                                    let l:history = l:history[1:]
    7              0.000003     endif
                            
    7              0.000042     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    7              0.000022     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  airline#util#shorten()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:28
Called 36 times
Total time:   0.000987
 Self time:   0.000632

count  total (s)   self (s)
   36   0.000618   0.000264   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
   36              0.000014   else
   36              0.000037     return a:text
                              endif

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/linter.vim:424
Called 7 times
Total time:   0.090252
 Self time:   0.002370

count  total (s)   self (s)
    7              0.000019     let l:Executable = a:linter.executable
                            
    7   0.090226   0.002345     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/highlighter.vim:205
Called 4 times
Total time:   0.001447
 Self time:   0.000149

count  total (s)   self (s)
    4              0.000016     if getbufvar(a:bufnr, '&modified')
                                  let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000002     else
    4              0.000042       let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000002     endif
                            
    4              0.000008     if !empty(colors)
    4   0.001349   0.000051       call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4              0.000002     endif

FUNCTION  <SNR>98_get_section()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/default.vim:20
Called 11 times
Total time:   0.000447
 Self time:   0.000356

count  total (s)   self (s)
   11              0.000025   if has_key(s:section_truncate_width, a:key)
    8   0.000108   0.000050     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
    8              0.000003     endif
   11              0.000005   endif
   11              0.000016   let spc = g:airline_symbols.space
   11              0.000036   if !exists('g:airline_section_{a:key}')
                                return ''
   11              0.000004   endif
   11   0.000116   0.000083   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   11              0.000060   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   11              0.000036   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>80_is_excluded_window()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:111
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    1              0.000001   endfor
                            
    4              0.000005   for matchw in g:airline_exclude_filenames
    3              0.000017     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    3              0.000001     endif
    4              0.000002   endfor
                            
    1              0.000002   if g:airline_exclude_preview && &previewwindow
                                return 1
    1              0.000000   endif
                            
    1              0.000001   return 0

FUNCTION  <SNR>109_RemoveProblemsForDisabledLinters()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/engine.vim:477
Called 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    1              0.000002     let l:name_map = {}
                            
   11              0.000008     for l:linter in a:linters
   10              0.000016         let l:name_map[l:linter.name] = 1
   11              0.000005     endfor
                            
    1              0.000006     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  airline#util#prepend()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:63
Called 90 times
Total time:   0.000487
 Self time:   0.000487

count  total (s)   self (s)
   90              0.000153   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
   90              0.000031   endif
   90              0.000209   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  ale#command#StopJobs()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/command.vim:261
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000003     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000002     if !empty(l:info)
                                    let l:new_map = {}
                            
                                    for [l:job_id, l:job_type] in items(l:info.jobs)
                                        let l:job_id = str2nr(l:job_id)
                            
                                        if a:job_type is# 'all' || a:job_type is# l:job_type
                                            call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
                                    endfor
                            
                                    let l:info.jobs = l:new_map
    1              0.000001     endif

FUNCTION  sy#sign#parse_hunk()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-signify/autoload/sy/sign.vim:224
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000010   let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
    1              0.000009   return [ str2nr(tokens[1]), empty(tokens[2]) ? 1 : str2nr(tokens[2]), str2nr(tokens[3]), empty(tokens[4]) ? 1 : str2nr(tokens[4]) ]

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/cursor.vim:104
Called 3 times
Total time:   0.000203
 Self time:   0.000154

count  total (s)   self (s)
    3              0.000016     let l:buffer = bufnr('')
                            
    3              0.000007     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    3              0.000003     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    3              0.000008     if mode(1) isnot# 'n'
                                    return
    3              0.000001     endif
                            
    3   0.000070   0.000032     call s:StopCursorTimer()
                            
    3              0.000014     let l:pos = getpos('.')[0:2]
                            
    3              0.000007     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    3              0.000001     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    3              0.000005     if l:pos != w:last_pos
    1   0.000017   0.000005         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    1              0.000004         let w:last_pos = l:pos
    1              0.000006         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    3              0.000002     endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/util.vim:71
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000005     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  ale#handlers#languagetool#DefineLinter()
    Defined: ~/local/share/nvim/site/pack/packer/start/ale/autoload/ale/handlers/languagetool.vim:68
Called 2 times
Total time:   0.000500
 Self time:   0.000036

count  total (s)   self (s)
    2   0.000498   0.000035     call ale#linter#Define(a:filetype, {   'name': 'languagetool',   'executable': function('ale#handlers#languagetool#GetExecutable'),   'command': function('ale#handlers#languagetool#GetCommand'),   'output_stream': 'stdout',   'callback': 'ale#handlers#languagetool#HandleOutput',   'lint_file': 1,})

FUNCTION  <SNR>97_get_accented_line()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:163
Called 8 times
Total time:   0.000401
 Self time:   0.000401

count  total (s)   self (s)
    8              0.000010   if a:self._context.active
                                " active window
    8              0.000010     let contents = []
    8              0.000053     let content_parts = split(a:contents, '__accent')
   24              0.000030     for cpart in content_parts
   16              0.000086       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   16              0.000034       call add(contents, cpart)
   24              0.000015     endfor
    8              0.000028     let line = join(contents, a:group)
    8              0.000049     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
    8              0.000004   endif
    8              0.000008   return line

FUNCTION  quick_scope#StopTimer()
    Defined: ~/local/share/nvim/site/pack/packer/start/quick-scope/autoload/quick_scope.vim:58
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003   if g:qs_delay > 0
    1              0.000004     call timer_stop(s:timer)
    1              0.000001   endif

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions/ale.vim:112
Called 18 times
Total time:   0.002675
 Self time:   0.000135

count  total (s)   self (s)
   18   0.002667   0.000127   return airline#extensions#ale#get('warning')

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/extensions.vim:505
Called 18 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
   18              0.000032   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/local/share/nvim/site/pack/packer/start/vim-airline/autoload/airline/builder.vim:229
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000007   let builder = copy(s:prototype)
    1              0.000002   let builder._context = a:context
    1              0.000001   let builder._sections = []
                            
    1              0.000012   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    1              0.000001   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.417743   0.000028  ale#events#LintOnEnter()
    1   0.417699   0.000054  ale#Queue()
    1   0.417541   0.000088  <SNR>79_Lint()
    1   0.214720   0.000174  ale#linter#Get()
    1   0.214466   0.023569  ale#linter#GetAll()
    1   0.202680   0.000038  ale#engine#RunLinters()
    1   0.202535   0.000244  <SNR>109_GetLintFileValues()
    1   0.202230   0.000226  <SNR>109_RunLinters()
    7   0.201750   0.000171  <SNR>109_RunLinter()
    7   0.111328   0.000330  <SNR>109_RunIfExecutable()
    7   0.110965   0.110764  ale#engine#IsExecutable()
    7   0.090252   0.002370  ale#linter#GetExecutable()
    1   0.073549   0.010674  <SNR>3_SynSet()
    3   0.071456   0.000113  ale#path#FindExecutable()
    3   0.071259   0.000161  ale#path#FindNearestExecutable()
    5   0.071042             ale#path#FindNearestFile()
   18   0.069880   0.002240  airline#check_mode()
    1   0.068883   0.000013  ale#handlers#textlint#GetExecutable()
    4   0.065893   0.008274  airline#highlighter#highlight()
  159   0.045608   0.013755  airline#highlighter#exec()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    7   0.110965   0.110764  ale#engine#IsExecutable()
    5              0.071042  ale#path#FindNearestFile()
    1   0.214466   0.023569  ale#linter#GetAll()
 1060              0.021927  <SNR>86_get_syn()
  265   0.040454   0.016988  airline#highlighter#get_highlight()
    1   0.033995   0.014386  <SNR>27_LoadFTPlugin()
  159   0.045608   0.013755  airline#highlighter#exec()
    1   0.073549   0.010674  <SNR>3_SynSet()
    4   0.065893   0.008274  airline#highlighter#highlight()
    1              0.004018  <SNR>28_LoadIndent()
   41              0.003801  <SNR>86_GetHiCmd()
   20   0.003812   0.003580  ale#linter#PreProcess()
    1   0.013733   0.002865  <SNR>92_format_wordcount()
    1   0.002689   0.002549  sy#repo#get_diff()
    7   0.090252   0.002370  ale#linter#GetExecutable()
   36   0.004789   0.002318  airline#extensions#ale#get()
   18   0.069880   0.002240  airline#check_mode()
  159              0.002117  <SNR>86_CheckDefined()
   18   0.002757   0.002102  airline#extensions#whitespace#check()
   47   0.030811   0.001993  <SNR>86_exec_separator()

