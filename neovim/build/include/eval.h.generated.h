#define DEFINE_FUNC_ATTRIBUTES
#include "nvim/func_attr.h"
#undef DEFINE_FUNC_ATTRIBUTES
#ifndef DLLEXPORT
#  ifdef WIN32
#    define DLLEXPORT __declspec(dllexport)
#  else
#    define DLLEXPORT
#  endif
#endif
DLLEXPORT varnumber_T num_divide(varnumber_T n1, varnumber_T n2) FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT varnumber_T num_modulus(varnumber_T n1, varnumber_T n2) FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT void eval_init(void);
DLLEXPORT void set_internal_string_var(const char *name, char_u *value) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT int var_redir_start(char_u *name, int append);
DLLEXPORT void var_redir_str(char_u *value, int value_len);
DLLEXPORT void var_redir_stop(void);
DLLEXPORT int eval_charconvert(const char *const enc_from, const char *const enc_to, const char *const fname_from, const char *const fname_to);
DLLEXPORT int eval_printexpr(const char *const fname, const char *const args);
DLLEXPORT void eval_diff(const char *const origfile, const char *const newfile, const char *const outfile);
DLLEXPORT void eval_patch(const char *const origfile, const char *const difffile, const char *const outfile);
DLLEXPORT int eval_to_bool(char_u *arg, _Bool *error, char_u **nextcmd, int skip);
DLLEXPORT int eval_expr_typval(const typval_T *expr, typval_T *argv, int argc, typval_T *rettv) FUNC_ATTR_NONNULL_ARG(1, 2, 4);
DLLEXPORT _Bool eval_expr_to_bool(const typval_T *expr, _Bool *error) FUNC_ATTR_NONNULL_ARG(1, 2);
DLLEXPORT char *eval_to_string_skip(const char *arg, const char **nextcmd, const _Bool skip) FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int skip_expr(char_u **pp);
DLLEXPORT char_u *eval_to_string(char_u *arg, char_u **nextcmd, _Bool convert);
DLLEXPORT char_u *eval_to_string_safe(char_u *arg, char_u **nextcmd, int use_sandbox);
DLLEXPORT varnumber_T eval_to_number(char_u *expr);
DLLEXPORT typval_T *eval_expr(char_u *arg);
DLLEXPORT void prepare_vimvar(int idx, typval_T *save_tv);
DLLEXPORT void restore_vimvar(int idx, typval_T *save_tv);
DLLEXPORT void find_win_for_curbuf(void);
DLLEXPORT list_T *eval_spell_expr(char_u *badword, char_u *expr);
DLLEXPORT int get_spellword(list_T *const list, const char **ret_word);
DLLEXPORT int call_vim_function(const char_u *func, int argc, typval_T *argv, typval_T *rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT varnumber_T call_func_retnr(const char_u *func, int argc, typval_T *argv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *call_func_retstr(const char *const func, int argc, typval_T *argv) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC;
DLLEXPORT void *call_func_retlist(const char_u *func, int argc, typval_T *argv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void prof_child_enter(proftime_T *tm);
DLLEXPORT void prof_child_exit(proftime_T *tm);
DLLEXPORT int eval_foldexpr(char_u *arg, int *cp);
DLLEXPORT void ex_const(exarg_T *eap);
DLLEXPORT void ex_let(exarg_T *eap);
DLLEXPORT void list_hashtable_vars(hashtab_T *ht, const char *prefix, int empty, int *first);
DLLEXPORT char_u *get_lval(char_u *const name, typval_T *const rettv, lval_T *const lp, const _Bool unlet, const _Bool skip, const int flags, const int fne_flags) FUNC_ATTR_NONNULL_ARG(1, 3);
DLLEXPORT void clear_lval(lval_T *lp);
DLLEXPORT void *eval_for_line(const char_u *arg, _Bool *errp, char_u **nextcmdp, int skip);
DLLEXPORT _Bool next_for_item(void *fi_void, char_u *arg);
DLLEXPORT void free_for_info(void *fi_void);
DLLEXPORT void set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void ex_unlet(exarg_T *eap);
DLLEXPORT void ex_lockvar(exarg_T *eap);
DLLEXPORT int do_unlet(const char *const name, const size_t name_len, const _Bool forceit) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void del_menutrans_vars(void);
DLLEXPORT char_u *cat_prefix_varname(int prefix, const char_u *name) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char_u *get_user_var_name(expand_T *xp, int idx);
DLLEXPORT int eval0(char_u *arg, typval_T *rettv, char_u **nextcmd, int evaluate);
DLLEXPORT int eval1(char_u **arg, typval_T *rettv, int evaluate);
DLLEXPORT int get_option_tv(const char **const arg, typval_T *const rettv, const _Bool evaluate) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT char_u *partial_name(partial_T *pt);
DLLEXPORT void partial_unref(partial_T *pt);
DLLEXPORT _Bool func_equal(typval_T *tv1, typval_T *tv2, _Bool ic);
DLLEXPORT int get_copyID(void) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool garbage_collect(_Bool testing);
DLLEXPORT _Bool set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT size_t string2float(const char *const text, float_T *const ret_value) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void get_arglist_as_rettv(aentry_T *arglist, int argcount, typval_T *rettv);
DLLEXPORT void prepare_assert_error(garray_T *gap);
DLLEXPORT void fill_assert_error(garray_T *gap, typval_T *opt_msg_tv, char_u *exp_str, typval_T *exp_tv, typval_T *got_tv, assert_type_T atype);
DLLEXPORT void assert_error(garray_T *gap);
DLLEXPORT int assert_equal_common(typval_T *argvars, assert_type_T atype) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_equalfile(typval_T *argvars) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_inrange(typval_T *argvars) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_bool(typval_T *argvars, _Bool is_true) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_exception(typval_T *argvars) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_beeps(typval_T *argvars, _Bool no_beep) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_fails(typval_T *argvars) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int assert_match_common(typval_T *argvars, assert_type_T atype) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT win_T *find_win_by_nr_or_id(typval_T *vp);
DLLEXPORT void filter_map(typval_T *argvars, typval_T *rettv, int map);
DLLEXPORT void common_function(typval_T *argvars, typval_T *rettv, _Bool is_funcref, FunPtr fptr);
DLLEXPORT dict_T *get_buffer_info(buf_T *buf);
DLLEXPORT linenr_T tv_get_lnum_buf(const typval_T *const tv, const buf_T *const buf) FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT void get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv);
DLLEXPORT dict_T *get_tabpage_info(tabpage_T *tp, int tp_idx);
DLLEXPORT dict_T *get_win_info(win_T *wp, int16_t tpnr, int16_t winnr);
DLLEXPORT win_T *find_win_by_nr(typval_T *vp, tabpage_T *tp);
DLLEXPORT win_T *find_tabwin(typval_T *wvp, typval_T *tvp);
DLLEXPORT void getwinvar(typval_T *argvars, typval_T *rettv, int off);
DLLEXPORT void get_user_input(const typval_T *const argvars, typval_T *const rettv, const _Bool inputdialog, const _Bool secret) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void dict_list(typval_T *const tv, typval_T *const rettv, const DictListType what);
DLLEXPORT char **tv_to_argv(typval_T *cmd_tv, const char **cmd, _Bool *executable);
DLLEXPORT void mapblock_fill_dict(dict_T *const dict, const mapblock_T *const mp, long buffer_value, _Bool compatible) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int matchadd_dict_arg(typval_T *tv, const char **conceal_char, win_T **win);
DLLEXPORT void return_register(int regname, typval_T *rettv);
DLLEXPORT void screenchar_adjust_grid(ScreenGrid **grid, int *row, int *col);
DLLEXPORT void set_buffer_lines(buf_T *buf, linenr_T lnum_arg, _Bool append, const typval_T *lines, typval_T *rettv) FUNC_ATTR_NONNULL_ARG(4, 5);
DLLEXPORT void setwinvar(typval_T *argvars, typval_T *rettv, int off);
DLLEXPORT void get_xdg_var_list(const XDGVarType xdg, typval_T *rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv, _Bool retlist);
DLLEXPORT _Bool callback_from_typval(Callback *const callback, typval_T *const arg) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool callback_call(Callback *const callback, const int argcount_in, typval_T *const argvars_in, typval_T *const rettv) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT timer_T *find_timer_by_nr(varnumber_T xx);
DLLEXPORT void add_timer_info(typval_T *rettv, timer_T *timer);
DLLEXPORT void add_timer_info_all(typval_T *rettv);
DLLEXPORT void timer_due_cb(TimeWatcher *tw, void *data);
DLLEXPORT uint64_t timer_start(const long timeout, const int repeat_count, const Callback *const callback);
DLLEXPORT void timer_stop(timer_T *timer);
DLLEXPORT void timer_stop_all(void);
DLLEXPORT void timer_teardown(void);
DLLEXPORT _Bool write_list(FileDescriptor *const fp, const list_T *const list, const _Bool binary) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT _Bool write_blob(FileDescriptor *const fp, const blob_T *const blob) FUNC_ATTR_NONNULL_ARG(1);
DLLEXPORT _Bool read_blob(FILE *const fd, blob_T *const blob) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, _Bool endnl) FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL;
DLLEXPORT pos_T *var2fpos(const typval_T *const tv, const _Bool dollar_lnum, int *const ret_fnum) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp);
DLLEXPORT int get_id_len(const char **const arg);
DLLEXPORT int get_name_len(const char **const arg, char **alias, _Bool evaluate, _Bool verbose);
DLLEXPORT const char_u *find_name_end(const char_u *arg, const char_u **expr_start, const char_u **expr_end, int flags);
DLLEXPORT int eval_isnamec(int c);
DLLEXPORT int eval_isnamec1(int c);
DLLEXPORT varnumber_T get_vim_var_nr(int idx) FUNC_ATTR_PURE;
DLLEXPORT char_u *get_vim_var_str(int idx) FUNC_ATTR_PURE FUNC_ATTR_NONNULL_RET;
DLLEXPORT list_T *get_vim_var_list(int idx) FUNC_ATTR_PURE;
DLLEXPORT dict_T *get_vim_var_dict(int idx) FUNC_ATTR_PURE;
DLLEXPORT void set_vim_var_char(int c);
DLLEXPORT void set_vcount(long count, long count1, int set_prevcount);
DLLEXPORT void set_vim_var_nr(const VimVarIndex idx, const varnumber_T val);
DLLEXPORT void set_vim_var_bool(const VimVarIndex idx, const BoolVarValue val);
DLLEXPORT void set_vim_var_special(const VimVarIndex idx, const SpecialVarValue val);
DLLEXPORT void set_vim_var_string(const VimVarIndex idx, const char *const val, const ptrdiff_t len);
DLLEXPORT void set_vim_var_list(const VimVarIndex idx, list_T *const val);
DLLEXPORT void set_vim_var_dict(const VimVarIndex idx, dict_T *const val);
DLLEXPORT void set_argv_var(char **argv, int argc);
DLLEXPORT void set_reg_var(int c);
DLLEXPORT char_u *v_exception(char_u *oldval);
DLLEXPORT char_u *v_throwpoint(char_u *oldval);
DLLEXPORT char_u *set_cmdarg(exarg_T *eap, char_u *oldarg);
DLLEXPORT int get_var_tv(const char *name, int len, typval_T *rettv, dictitem_T **dip, int verbose, int no_autoload);
DLLEXPORT _Bool is_luafunc(partial_T *partial);
DLLEXPORT const char *skip_luafunc_name(const char *p) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int check_luafunc_name(const char *const str, const _Bool paren) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int handle_subscript(const char **const arg, typval_T *rettv, int evaluate, int verbose, const char_u *const start_leader, const char_u **const end_leaderp);
DLLEXPORT void set_selfdict(typval_T *const rettv, dict_T *const selfdict);
DLLEXPORT dictitem_T *find_var(const char *const name, const size_t name_len, hashtab_T **htp, int no_autoload);
DLLEXPORT dictitem_T *find_var_in_ht(hashtab_T *const ht, int htname, const char *const varname, const size_t varname_len, int no_autoload) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT hashtab_T *find_var_ht(const char *name, const size_t name_len, const char **varname);
DLLEXPORT char_u *get_var_value(const char *const name);
DLLEXPORT void new_script_vars(scid_T id);
DLLEXPORT void init_var_dict(dict_T *dict, ScopeDictDictItem *dict_var, int scope);
DLLEXPORT void unref_var_dict(dict_T *dict);
DLLEXPORT void vars_clear(hashtab_T *ht);
DLLEXPORT void vars_clear_ext(hashtab_T *ht, int free_val);
DLLEXPORT void set_var(const char *name, const size_t name_len, typval_T *const tv, const _Bool copy) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT _Bool var_check_ro(const int flags, const char *name, size_t name_len) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT _Bool var_check_fixed(const int flags, const char *name, size_t name_len) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL;
DLLEXPORT _Bool var_check_func_name(const char *const name, const _Bool new_var) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool valid_varname(const char *varname) FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT int var_item_copy(const vimconv_T *const conv, typval_T *const from, typval_T *const to, const _Bool deep, const int copyID) FUNC_ATTR_NONNULL_ARG(2, 3);
DLLEXPORT void ex_echo(exarg_T *eap);
DLLEXPORT void ex_echohl(exarg_T *eap);
DLLEXPORT void ex_execute(exarg_T *eap);
DLLEXPORT void func_do_profile(ufunc_T *fp);
DLLEXPORT void func_dump_profile(FILE *fd);
DLLEXPORT char *autoload_name(const char *const name, const size_t name_len) FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT;
DLLEXPORT _Bool script_autoload(const char *const name, const size_t name_len, const _Bool reload);
DLLEXPORT void func_line_start(void *cookie);
DLLEXPORT void func_line_exec(void *cookie);
DLLEXPORT void func_line_end(void *cookie);
DLLEXPORT const void *var_shada_iter(const void *const iter, const char **const name, typval_T *rettv, var_flavour_T flavour) FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(2, 3);
DLLEXPORT void var_set_global(const char *const name, typval_T vartv);
DLLEXPORT int store_session_globals(FILE *fd);
DLLEXPORT void last_set_msg(sctx_T script_ctx);
DLLEXPORT void option_last_set_msg(LastSet last_set);
DLLEXPORT void reset_v_option_vars(void);
DLLEXPORT int modify_fname(char_u *src, _Bool tilde_file, size_t *usedlen, char_u **fnamep, char_u **bufp, size_t *fnamelen);
DLLEXPORT char_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, typval_T *expr, char_u *flags);
DLLEXPORT _Bool common_job_callbacks(dict_T *vopts, CallbackReader *on_stdout, CallbackReader *on_stderr, Callback *on_exit);
DLLEXPORT Channel *find_job(uint64_t id, _Bool show_error);
DLLEXPORT void script_host_eval(char *name, typval_T *argvars, typval_T *rettv);
DLLEXPORT typval_T eval_call_provider(char *provider, char *method, list_T *arguments, _Bool discard);
DLLEXPORT _Bool eval_has_provider(const char *feat);
DLLEXPORT void eval_fmt_source_name_line(char *buf, size_t bufsize);
DLLEXPORT void ex_checkhealth(exarg_T *eap);
DLLEXPORT void invoke_prompt_callback(void);
DLLEXPORT _Bool invoke_prompt_interrupt(void);
DLLEXPORT int typval_compare(typval_T *typ1, typval_T *typ2, exprtype_T type, _Bool ic) FUNC_ATTR_NONNULL_ALL;
DLLEXPORT char *typval_tostring(typval_T *arg);
DLLEXPORT _Bool var_exists(const char *var) FUNC_ATTR_NONNULL_ALL;
#include "nvim/func_attr.h"
