# 1 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/jesmith/neovim/src/nvim/eval/funcs.c"



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/float.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 461 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 452 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 453 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 454 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 462 "/usr/include/features.h" 2 3 4
# 485 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 486 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/math.h" 2 3 4









# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 31 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 38 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 121 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 44 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 289 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 290 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));




extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));







extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double nextup (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextup (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));




extern double roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern double fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorder (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern double __getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayload (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsig (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 291 "/usr/include/math.h" 2 3 4
# 306 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 307 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));





 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));







extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern float nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));




extern float roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern float fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__)); extern float __getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));







extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 308 "/usr/include/math.h" 2 3 4
# 349 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 350 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 211 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));







extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));




extern long double roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern long double fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 351 "/usr/include/math.h" 2 3 4
# 389 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32 expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));





extern _Float32 erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 390 "/usr/include/math.h" 2 3 4
# 406 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64 expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));





extern _Float64 erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 407 "/usr/include/math.h" 2 3 4
# 420 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 421 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float128 expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));





extern _Float128 erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 424 "/usr/include/math.h" 2 3 4
# 440 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32x expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));





extern _Float32x erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 441 "/usr/include/math.h" 2 3 4
# 457 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64x expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 196 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));





extern _Float64x erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
# 249 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 458 "/usr/include/math.h" 2 3 4
# 503 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdiv (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmul (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsub (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 504 "/usr/include/math.h" 2 3 4
# 517 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 518 "/usr/include/math.h" 2 3 4
# 537 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double ddivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 538 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 617 "/usr/include/math.h" 2 3 4
# 626 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 627 "/usr/include/math.h" 2 3 4
# 636 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 637 "/usr/include/math.h" 2 3 4
# 646 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 647 "/usr/include/math.h" 2 3 4
# 666 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 667 "/usr/include/math.h" 2 3 4
# 676 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 677 "/usr/include/math.h" 2 3 4
# 686 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 687 "/usr/include/math.h" 2 3 4
# 706 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 707 "/usr/include/math.h" 2 3 4
# 716 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 717 "/usr/include/math.h" 2 3 4
# 736 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 737 "/usr/include/math.h" 2 3 4
# 773 "/usr/include/math.h" 3 4
extern int signgam;
# 853 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 973 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 974 "/usr/include/math.h" 2 3 4
# 1245 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathinline.h" 1 3 4
# 1246 "/usr/include/math.h" 2 3 4
# 1338 "/usr/include/math.h" 3 4

# 6 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/api/private/converter.h" 1



# 1 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdbool.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdint.h" 2 3 4
# 6 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 91 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 104 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 115 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 154 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 226 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 266 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 303 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 330 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 360 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 421 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 433 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) mempcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
# 71 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 1 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 1 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 1 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 1 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 1 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 1 > 1));
}
# 496 "/usr/include/string.h" 2 3 4




# 7 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 2

# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 44 "/home/jesmith/neovim/src/nvim/func_attr.h"
# 1 "/home/jesmith/neovim/src/nvim/macros.h" 1



# 1 "/home/jesmith/neovim/build/config/auto/config.h" 1
# 5 "/home/jesmith/neovim/src/nvim/macros.h" 2
# 45 "/home/jesmith/neovim/src/nvim/func_attr.h" 2
# 9 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 2
# 1 "/home/jesmith/neovim/src/nvim/types.h" 1








# 8 "/home/jesmith/neovim/src/nvim/types.h"
typedef void *vim_acl_T;



typedef unsigned char char_u;


typedef uint32_t u8char_T;


typedef int handle_T;




typedef int LuaRef;

typedef handle_T NS;

typedef struct expand expand_T;

typedef enum {
  kNone = -1,
  kFalse = 0,
  kTrue = 1,
} TriState;
# 10 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 2
# 26 "/home/jesmith/neovim/src/nvim/api/private/defs.h"
typedef enum {
  kErrorTypeNone = -1,
  kErrorTypeException,
  kErrorTypeValidation,
} ErrorType;

typedef enum {
  kMessageTypeUnknown = -1,

  kMessageTypeRequest = 0,
  kMessageTypeResponse = 1,
  kMessageTypeNotification = 2,
} MessageType;
# 49 "/home/jesmith/neovim/src/nvim/api/private/defs.h"
static inline 
# 49 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 3 4
             _Bool 
# 49 "/home/jesmith/neovim/src/nvim/api/private/defs.h"
                  is_internal_call(const uint64_t channel_id)
  __attribute__((always_inline)) __attribute__((const));






static inline 
# 57 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 3 4
             _Bool 
# 57 "/home/jesmith/neovim/src/nvim/api/private/defs.h"
                  is_internal_call(const uint64_t channel_id)
{
  return !!(channel_id & (((uint64_t)1) << (sizeof(uint64_t) * 8 - 1)));
}

typedef struct {
  ErrorType type;
  char *msg;
} Error;

typedef 
# 67 "/home/jesmith/neovim/src/nvim/api/private/defs.h" 3 4
       _Bool 
# 67 "/home/jesmith/neovim/src/nvim/api/private/defs.h"
            Boolean;
typedef int64_t Integer;
typedef double Float;







typedef struct {
  char *data;
  size_t size;
} String;

typedef handle_T Buffer;
typedef handle_T Window;
typedef handle_T Tabpage;

typedef struct object Object;

typedef struct {
  Object *items;
  size_t size, capacity;
} Array;

typedef struct key_value_pair KeyValuePair;

typedef struct {
  KeyValuePair *items;
  size_t size, capacity;
} Dictionary;

typedef enum {
  kObjectTypeNil = 0,
  kObjectTypeBoolean,
  kObjectTypeInteger,
  kObjectTypeFloat,
  kObjectTypeString,
  kObjectTypeArray,
  kObjectTypeDictionary,
  kObjectTypeLuaRef,

  kObjectTypeBuffer,
  kObjectTypeWindow,
  kObjectTypeTabpage,
} ObjectType;

struct object {
  ObjectType type;
  union {
    Boolean boolean;
    Integer integer;
    Float floating;
    String string;
    Array array;
    Dictionary dictionary;
    LuaRef luaref;
  } data;
};

struct key_value_pair {
  String key;
  Object value;
};

typedef Object *(*field_hash)(void *retval, const char *str, size_t len);
typedef struct {
  char *str;
  size_t ptr_off;
} KeySetLink;
# 5 "/home/jesmith/neovim/src/nvim/api/private/converter.h" 2
# 1 "/home/jesmith/neovim/src/nvim/eval/typval.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4

# 34 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));





extern long int __strtol_internal (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoimax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __strtoul_internal (const char *__restrict __nptr,
          char ** __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) strtoumax (const char *__restrict nptr, char **__restrict endptr, int base)

{
  return __strtoul_internal (nptr, endptr, base, 0);
}

extern long int __wcstol_internal (const __gwchar_t * __restrict __nptr,
       __gwchar_t **__restrict __endptr,
       int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) intmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoimax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstol_internal (nptr, endptr, base, 0);
}

extern unsigned long int __wcstoul_internal (const __gwchar_t *
          __restrict __nptr,
          __gwchar_t **
          __restrict __endptr,
          int __base, int __group)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__gnu_inline__)) uintmax_t
__attribute__ ((__nothrow__ , __leaf__)) wcstoumax (const __gwchar_t *__restrict nptr, __gwchar_t **__restrict endptr, int base)

{
  return __wcstoul_internal (nptr, endptr, base, 0);
}
# 432 "/usr/include/inttypes.h" 3 4

# 6 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 321 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef int wchar_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 3 4
} max_align_t;
# 8 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2


# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 11 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/garray.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/garray.h" 2

# 1 "/home/jesmith/neovim/src/nvim/log.h" 1




# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));







extern FILE *tmpfile (void) __attribute__ ((__warn_unused_result__));
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__));







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));






extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 432 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));




extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 485 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 510 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 521 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 537 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__));
# 587 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 603 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 662 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 673 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 707 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 750 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);





# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 782 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) __attribute__ ((__warn_unused_result__));





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 858 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 865 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 1 - 1,
      __builtin_object_size (__s, 1 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 1 - 1,
       __builtin_object_size (__s, 1 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 1 - 1,
       __builtin_object_size (__s, 1 > 1), __fmt, __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 1 - 1,
        __builtin_object_size (__s, 1 > 1), __fmt, __ap);
}
# 243 "/usr/include/x86_64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")

                                        __attribute__ ((__warn_unused_result__));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_chk (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 1 > 1))
 return __fgets_chk_warn (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);
    }
  return __fgets_alias (__s, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n, __stream);
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")

                                                 __attribute__ ((__warn_unused_result__));
extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n) || __n <= 0)
 return __fgets_unlocked_chk (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);

      if ((size_t) __n > __builtin_object_size (__s, 1 > 1))
 return __fgets_unlocked_chk_warn (__s, __builtin_object_size (__s, 1 > 1), __n, __stream);
    }
  return __fgets_unlocked_alias (__s, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  if (__builtin_object_size (__ptr, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size)
   || !__builtin_constant_p (__n)
   || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
 return __fread_unlocked_chk (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
         __stream);

      if (__size * __n > __builtin_object_size (__ptr, 0))
 return __fread_unlocked_chk_warn (__ptr, __builtin_object_size (__ptr, 0), __size, __n,
       __stream);
    }


  if (__builtin_constant_p (__size)
      && __builtin_constant_p (__n)
      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
      && __size * __n <= 8)
    {
      size_t __cnt = __size * __n;
      char *__cptr = (char *) __ptr;
      if (__cnt == 0)
 return 0;

      for (; __cnt > 0; --__cnt)
 {
   int __c = getc_unlocked (__stream);
   if (__c == (-1))
     break;
   *__cptr++ = __c;
 }
      return (__cptr - (char *) __ptr) / __size;
    }

  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}
# 868 "/usr/include/stdio.h" 2 3 4






# 6 "/home/jesmith/neovim/src/nvim/log.h" 2
# 84 "/home/jesmith/neovim/src/nvim/log.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 1 3 4
# 15 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 1 3 4
# 14 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 15 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 2 3 4
# 26 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 3 4
  typedef struct {

    int coverage_sandboxed;



    intptr_t coverage_fd;




    unsigned int coverage_max_block_size;
  } __sanitizer_sandbox_arguments;


  void __sanitizer_set_report_path(const char *path);


  void __sanitizer_set_report_fd(void *fd);




  void __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args);




  void __sanitizer_report_error_summary(const char *error_summary);




  uint16_t __sanitizer_unaligned_load16(const void *p);
  uint32_t __sanitizer_unaligned_load32(const void *p);
  uint64_t __sanitizer_unaligned_load64(const void *p);
  void __sanitizer_unaligned_store16(void *p, uint16_t x);
  void __sanitizer_unaligned_store32(void *p, uint32_t x);
  void __sanitizer_unaligned_store64(void *p, uint64_t x);




  int __sanitizer_acquire_crash_state();
# 101 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 3 4
  void __sanitizer_annotate_contiguous_container(const void *beg,
                                                 const void *end,
                                                 const void *old_mid,
                                                 const void *new_mid);






  int __sanitizer_verify_contiguous_container(const void *beg, const void *mid,
                                              const void *end);




  const void *__sanitizer_contiguous_container_find_bad_address(
      const void *beg, const void *mid, const void *end);


  void __sanitizer_print_stack_trace(void);
# 133 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 3 4
  void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,
                                size_t out_buf_size);

  void __sanitizer_symbolize_global(void *data_ptr, const char *fmt,
                                    char *out_buf, size_t out_buf_size);



  void __sanitizer_set_death_callback(void (*callback)(void));







  void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,
                                    const void *s2, size_t n, int result);
  void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,
                                    const char *s2, size_t n, int result);
  void __sanitizer_weak_hook_strncasecmp(void *called_pc, const char *s1,
                                         const char *s2, size_t n, int result);
  void __sanitizer_weak_hook_strcmp(void *called_pc, const char *s1,
                                    const char *s2, int result);
  void __sanitizer_weak_hook_strcasecmp(void *called_pc, const char *s1,
                                        const char *s2, int result);
  void __sanitizer_weak_hook_strstr(void *called_pc, const char *s1,
                                    const char *s2, char *result);
  void __sanitizer_weak_hook_strcasestr(void *called_pc, const char *s1,
                                        const char *s2, char *result);
  void __sanitizer_weak_hook_memmem(void *called_pc,
                                    const void *s1, size_t len1,
                                    const void *s2, size_t len2, void *result);






  void __sanitizer_print_memory_profile(size_t top_percent,
                                        size_t max_number_of_contexts);
# 191 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/common_interface_defs.h" 3 4
  void __sanitizer_start_switch_fiber(void **fake_stack_save,
                                      const void *bottom, size_t size);
  void __sanitizer_finish_switch_fiber(void *fake_stack_save,
                                       const void **bottom_old,
                                       size_t *size_old);



  int __sanitizer_get_module_and_offset_for_pc(void *pc, char *module_path,
                                               size_t module_path_len,
                                               void **pc_offset);
# 16 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 2 3 4
# 28 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 3 4
  void __asan_poison_memory_region(void const volatile *addr, size_t size);







  void __asan_unpoison_memory_region(void const volatile *addr, size_t size);
# 54 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 3 4
  int __asan_address_is_poisoned(void const volatile *addr);



  void *__asan_region_is_poisoned(void *beg, size_t size);


  void __asan_describe_address(void *addr);



  int __asan_report_present(void);





  void *__asan_get_report_pc(void);
  void *__asan_get_report_bp(void);
  void *__asan_get_report_sp(void);
  void *__asan_get_report_address(void);
  int __asan_get_report_access_type(void);
  size_t __asan_get_report_access_size(void);
  const char *__asan_get_report_description(void);
# 86 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 3 4
  const char *__asan_locate_address(void *addr, char *name, size_t name_size,
                                    void **region_address, size_t *region_size);




  size_t __asan_get_alloc_stack(void *addr, void **trace, size_t size,
                                int *thread_id);




  size_t __asan_get_free_stack(void *addr, void **trace, size_t size,
                               int *thread_id);



  void __asan_get_shadow_mapping(size_t *shadow_scale, size_t *shadow_offset);




  void __asan_report_error(void *pc, void *bp, void *sp,
                           void *addr, int is_write, size_t access_size);


  void __asan_set_death_callback(void (*callback)(void));

  void __asan_set_error_report_callback(void (*callback)(const char*));




  void __asan_on_error(void);


  void __asan_print_accumulated_stats(void);



  const char* __asan_default_options(void);






  void *__asan_get_current_fake_stack(void);
# 142 "/usr/lib/gcc/x86_64-linux-gnu/9/include/sanitizer/asan_interface.h" 3 4
  void *__asan_addr_is_in_fake_stack(void *fake_stack, void *addr, void **beg,
                                     void **end);



  void __asan_handle_no_return(void);
# 85 "/home/jesmith/neovim/src/nvim/log.h" 2
# 7 "/home/jesmith/neovim/src/nvim/garray.h" 2






# 12 "/home/jesmith/neovim/src/nvim/garray.h"
typedef struct growarray {
  int ga_len;
  int ga_maxlen;
  int ga_itemsize;
  int ga_growsize;
  void *ga_data;
} garray_T;
# 38 "/home/jesmith/neovim/src/nvim/garray.h"
static inline void *ga_append_via_ptr(garray_T *gap, size_t item_size)
{
  if ((int)item_size != gap->ga_itemsize) {
    logmsg(3, 
# 41 "/home/jesmith/neovim/src/nvim/garray.h" 3 4
   ((void *)0)
# 41 "/home/jesmith/neovim/src/nvim/garray.h"
   , __func__, 41, 
# 41 "/home/jesmith/neovim/src/nvim/garray.h" 3 4
   1
# 41 "/home/jesmith/neovim/src/nvim/garray.h"
   , "wrong item size (%zu), should be %d", item_size, gap->ga_itemsize);
  }
  ga_grow(gap, 1);
  return ((char *)gap->ga_data) + (item_size * (size_t)gap->ga_len++);
}
# 12 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/gettext.h" 1




# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4






# 39 "/usr/include/libintl.h" 3 4
extern char *gettext (const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) __attribute__ ((__nothrow__ , __leaf__));



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) __attribute__ ((__nothrow__ , __leaf__));







# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 101 "/usr/include/libintl.h" 2 3 4


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4


# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) __attribute__ ((__nothrow__ , __leaf__));


extern struct lconv *localeconv (void) __attribute__ ((__nothrow__ , __leaf__));
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) __attribute__ ((__nothrow__ , __leaf__));
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));



extern void freelocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));






extern locale_t uselocale (locale_t __dataset) __attribute__ ((__nothrow__ , __leaf__));








# 104 "/usr/include/libintl.h" 2 3 4
# 121 "/usr/include/libintl.h" 3 4

# 6 "/home/jesmith/neovim/src/nvim/gettext.h" 2
# 13 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/hashtab.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/hashtab.h" 2







# 11 "/home/jesmith/neovim/src/nvim/hashtab.h"
extern char hash_removed;


typedef size_t hash_T;
# 38 "/home/jesmith/neovim/src/nvim/hashtab.h"
typedef struct hashitem_S {

  hash_T hi_hash;







  char_u *hi_key;
} hashitem_T;
# 63 "/home/jesmith/neovim/src/nvim/hashtab.h"
typedef struct hashtable_S {
  hash_T ht_mask;

  size_t ht_used;
  size_t ht_filled;
  int ht_locked;
  hashitem_T *ht_array;

  hashitem_T ht_smallarray[16];
} hashtab_T;
# 14 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/lib/queue.h" 1
# 23 "/home/jesmith/neovim/src/nvim/lib/queue.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/home/jesmith/neovim/src/nvim/lib/queue.h" 2

# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 26 "/home/jesmith/neovim/src/nvim/lib/queue.h" 2

typedef struct _queue {
  struct _queue *next;
  struct _queue *prev;
} QUEUE;
# 49 "/home/jesmith/neovim/src/nvim/lib/queue.h"
static inline int QUEUE_EMPTY(const QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT
{
  return q == q->next;
}



static inline void QUEUE_INIT(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE
{
  q->next = q;
  q->prev = q;
}

static inline void QUEUE_ADD(QUEUE *const h, QUEUE *const n)
  FUNC_ATTR_ALWAYS_INLINE
{
  h->prev->next = n->next;
  n->next->prev = h->prev;
  h->prev = n->prev;
  h->prev->next = h;
}

static inline void QUEUE_INSERT_HEAD(QUEUE *const h, QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE
{
  q->next = h->next;
  q->prev = h;
  q->next->prev = q;
  h->next = q;
}

static inline void QUEUE_INSERT_TAIL(QUEUE *const h, QUEUE *const q)
  FUNC_ATTR_ALWAYS_INLINE
{
  q->next = h;
  q->prev = h->prev;
  q->prev->next = q;
  h->prev = q;
}

static inline void QUEUE_REMOVE(QUEUE *const q) FUNC_ATTR_ALWAYS_INLINE
{
  q->prev->next = q->next;
  q->next->prev = q->prev;
}
# 15 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2

# 1 "/home/jesmith/neovim/src/nvim/mbyte.h" 1







# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 9 "/home/jesmith/neovim/src/nvim/mbyte.h" 2
# 1 "/home/jesmith/neovim/src/nvim/iconv.h" 1






# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4









# 37 "/usr/include/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 8 "/home/jesmith/neovim/src/nvim/iconv.h" 2
# 1 "/usr/include/iconv.h" 1 3 4
# 23 "/usr/include/iconv.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/iconv.h" 2 3 4





typedef void *iconv_t;







extern iconv_t iconv_open (const char *__tocode, const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);


# 9 "/home/jesmith/neovim/src/nvim/iconv.h" 2
# 10 "/home/jesmith/neovim/src/nvim/mbyte.h" 2
# 1 "/home/jesmith/neovim/src/nvim/os/os_defs.h" 1



# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 5 "/home/jesmith/neovim/src/nvim/os/os_defs.h" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 58 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 360 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 101 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);





# 1 "/usr/include/x86_64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 124 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void *)0);
}
# 826 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));







extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 957 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1013 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1014 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  if (__builtin_object_size (__resolved, 1 > 1) != (size_t) -1)
    {




      return __realpath_chk (__name, __resolved, __builtin_object_size (__resolved, 1 > 1));
    }

  return __realpath_alias (__name, __resolved);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 1 > 1) != (size_t) -1 && 16 > __builtin_object_size (__s, 1 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 1 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __mbstowcs_chk (__dst, __src, __len,
          __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));

      if (__len > __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t))
 return __mbstowcs_chk_warn (__dst, __src, __len,
         __builtin_object_size (__dst, 1 > 1) / sizeof (wchar_t));
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))


                                  ;
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  if (__builtin_object_size (__dst, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1));
      if (__len > __builtin_object_size (__dst, 1 > 1))
 return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 1 > 1));
    }
  return __wcstombs_alias (__dst, __src, __len);
}
# 1018 "/usr/include/stdlib.h" 2 3 4






# 7 "/home/jesmith/neovim/src/nvim/os/os_defs.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 224 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 249 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));







extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 272 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));
# 428 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 5)));


# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/stat.h" 2 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 __spare2[14];

};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 39 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 447 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) stat (const char *__path, struct stat *__statbuf)
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) lstat (const char *__path, struct stat *__statbuf)
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) stat64 (const char *__path, struct stat64 *__statbuf)
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf)
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstat64 (int __fd, struct stat64 *__statbuf)
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag)

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}







# 8 "/home/jesmith/neovim/src/nvim/os/os_defs.h" 2





# 1 "/home/jesmith/neovim/src/nvim/os/unix_defs.h" 1



# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 194 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 183 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 184 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 188 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 192 "/usr/include/limits.h" 2 3 4
# 195 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/9/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/signum.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/signum.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 210 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause");
# 170 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 185 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 227 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 286 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[(64 + 1)];
extern const char *const sys_siglist[(64 + 1)];



# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 292 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 302 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 304 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 307 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 317 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 318 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 328 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 360 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 375 "/usr/include/signal.h" 2 3 4


# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 5 "/home/jesmith/neovim/src/nvim/os/unix_defs.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__));





extern ssize_t write (int __fd, const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__));
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) __attribute__ ((__warn_unused_result__));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) __attribute__ ((__warn_unused_result__));
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__));







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 870 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 991 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1003 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1014 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 1024 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 1035 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1056 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1079 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) __attribute__ ((__warn_unused_result__));
# 1089 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) __attribute__ ((__warn_unused_result__));
# 1107 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1124 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 1161 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen) __attribute__ ((__warn_unused_result__));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read")
                               __attribute__ ((__warn_unused_result__));
extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));

      if (__nbytes > __builtin_object_size (__buf, 0))
 return __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0));
    }
  return __read_alias (__fd, __buf, __nbytes);
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize) __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread")

                                 __attribute__ ((__warn_unused_result__));
extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")

                                     __attribute__ ((__warn_unused_result__));
extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")))
                                  ;
extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")))
                                  ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread_chk_warn (__fd, __buf, __nbytes, __offset,
     __builtin_object_size (__buf, 0));
    }
  return __pread_alias (__fd, __buf, __nbytes, __offset);
}
# 104 "/usr/include/x86_64-linux-gnu/bits/unistd.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__nbytes))
 return __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0));

      if ( __nbytes > __builtin_object_size (__buf, 0))
 return __pread64_chk_warn (__fd, __buf, __nbytes, __offset,
       __builtin_object_size (__buf, 0));
    }

  return __pread64_alias (__fd, __buf, __nbytes, __offset);
}




extern ssize_t __readlink_chk (const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_alias (const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlink") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlink_chk_warn (const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlink_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlink (const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if ( __len > __builtin_object_size (__buf, 1 > 1))
 return __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 1 > 1));
    }
  return __readlink_alias (__path, __buf, __len);
}



extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_alias (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlinkat") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__));
extern ssize_t __readlinkat_chk_warn (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlinkat_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")))

                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if (__len > __builtin_object_size (__buf, 1 > 1))
 return __readlinkat_chk_warn (__fd, __path, __buf, __len,
          __builtin_object_size (__buf, 1 > 1));
    }
  return __readlinkat_alias (__fd, __path, __buf, __len);
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) __asm__ ("" "getcwd") __attribute__ ((__nothrow__ , __leaf__))
                                              __attribute__ ((__warn_unused_result__));
extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) __asm__ ("" "__getcwd_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")))
                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getcwd (char *__buf, size_t __size)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size))
 return __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 1 > 1));

      if (__size > __builtin_object_size (__buf, 1 > 1))
 return __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 1 > 1));
    }
  return __getcwd_alias (__buf, __size);
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern char *__getwd_warn (char *__buf) __asm__ ("" "getwd") __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getwd (char *__buf)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 1 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) __attribute__ ((__nothrow__ , __leaf__));
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) __asm__ ("" "confstr") __attribute__ ((__nothrow__ , __leaf__))
                             ;
extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) __asm__ ("" "__confstr_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) confstr (int __name, char *__buf, size_t __len)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__len))
 return __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 1 > 1));

      if (__builtin_object_size (__buf, 1 > 1) < __len)
 return __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 1 > 1));
    }
  return __confstr_alias (__name, __buf, __len);
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __getgroups_alias (int __size, __gid_t __list[]) __asm__ ("" "getgroups") __attribute__ ((__nothrow__ , __leaf__))
                 __attribute__ ((__warn_unused_result__));
extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) __asm__ ("" "__getgroups_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")))
                                           ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getgroups (int __size, __gid_t __list[])
{
  if (__builtin_object_size (__list, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__size) || __size < 0)
 return __getgroups_chk (__size, __list, __builtin_object_size (__list, 1 > 1));

      if (__size * sizeof (__gid_t) > __builtin_object_size (__list, 1 > 1))
 return __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 1 > 1));
    }
  return __getgroups_alias (__size, __list);
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ttyname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ttyname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ttyname_r (int __fd, char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __ttyname_r_alias (__fd, __buf, __buflen);
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r")
                     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __getlogin_r_alias (__buf, __buflen);
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern int __gethostname_alias (char *__buf, size_t __buflen) __asm__ ("" "gethostname") __attribute__ ((__nothrow__ , __leaf__))
                   __attribute__ ((__nonnull__ (1)));
extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__gethostname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) gethostname (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __gethostname_alias (__buf, __buflen);
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_alias (char *__buf, size_t __buflen) __asm__ ("" "getdomainname") __attribute__ ((__nothrow__ , __leaf__))

                     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getdomainname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")))

                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getdomainname (char *__buf, size_t __buflen)
{
  if (__builtin_object_size (__buf, 1 > 1) != (size_t) -1)
    {
      if (!__builtin_constant_p (__buflen))
 return __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));

      if (__buflen > __builtin_object_size (__buf, 1 > 1))
 return __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 1 > 1));
    }
  return __getdomainname_alias (__buf, __buflen);
}
# 1167 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));
# 1171 "/usr/include/unistd.h" 2 3 4


# 6 "/home/jesmith/neovim/src/nvim/os/unix_defs.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 9 "/home/jesmith/neovim/src/nvim/os/unix_defs.h" 2
# 14 "/home/jesmith/neovim/src/nvim/os/os_defs.h" 2
# 11 "/home/jesmith/neovim/src/nvim/mbyte.h" 2
# 42 "/home/jesmith/neovim/src/nvim/mbyte.h"

# 42 "/home/jesmith/neovim/src/nvim/mbyte.h"
typedef enum {
  CONV_NONE = 0,
  CONV_TO_UTF8 = 1,
  CONV_9_TO_UTF8 = 2,
  CONV_TO_LATIN1 = 3,
  CONV_TO_LATIN9 = 4,
  CONV_ICONV = 5,
} ConvFlags;
# 58 "/home/jesmith/neovim/src/nvim/mbyte.h"
typedef struct {
  int vc_type;
  int vc_factor;

  iconv_t vc_fd;

  
# 64 "/home/jesmith/neovim/src/nvim/mbyte.h" 3 4
 _Bool 
# 64 "/home/jesmith/neovim/src/nvim/mbyte.h"
      vc_fail;

} vimconv_T;

extern const uint8_t utf8len_tab_zero[256];

extern const uint8_t utf8len_tab[256];





static inline int mb_strcmp_ic(
# 76 "/home/jesmith/neovim/src/nvim/mbyte.h" 3 4
                              _Bool 
# 76 "/home/jesmith/neovim/src/nvim/mbyte.h"
                                   ic, const char *s1, const char *s2)
  __attribute__((nonnull)) __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline int mb_strcmp_ic(
# 84 "/home/jesmith/neovim/src/nvim/mbyte.h" 3 4
                              _Bool 
# 84 "/home/jesmith/neovim/src/nvim/mbyte.h"
                                   ic, const char *s1, const char *s2)
{
  return (ic ? mb_stricmp(s1, s2) : strcmp(s1, s2));
}
# 17 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/message.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stdarg.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/message.h" 2

# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 7 "/home/jesmith/neovim/src/nvim/message.h" 2


# 1 "/home/jesmith/neovim/src/nvim/grid_defs.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/grid_defs.h" 2







typedef char_u schar_T[(6 +1) * 4 + 1];
typedef int sattr_T;

enum {
  kZIndexDefaultGrid = 0,
  kZIndexFloatDefault = 50,
  kZIndexPopupMenu = 100,
  kZIndexMessages = 200,
  kZIndexCmdlinePopupMenu = 250,
};
# 47 "/home/jesmith/neovim/src/nvim/grid_defs.h"
typedef struct ScreenGrid ScreenGrid;
struct ScreenGrid {
  handle_T handle;

  schar_T *chars;
  sattr_T *attrs;
  unsigned *line_offset;
  char_u *line_wraps;



  int *dirty_col;


  int Rows;
  int Columns;


  
# 65 "/home/jesmith/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 65 "/home/jesmith/neovim/src/nvim/grid_defs.h"
      valid;



  
# 69 "/home/jesmith/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 69 "/home/jesmith/neovim/src/nvim/grid_defs.h"
      throttled;





  int row_offset;
  int col_offset;
  ScreenGrid *target;


  
# 80 "/home/jesmith/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 80 "/home/jesmith/neovim/src/nvim/grid_defs.h"
      blending;


  
# 83 "/home/jesmith/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 83 "/home/jesmith/neovim/src/nvim/grid_defs.h"
      focusable;


  int zindex;





  int comp_row;
  int comp_col;




  int comp_width;
  int comp_height;



  size_t comp_index;



  
# 107 "/home/jesmith/neovim/src/nvim/grid_defs.h" 3 4
 _Bool 
# 107 "/home/jesmith/neovim/src/nvim/grid_defs.h"
      comp_disabled;
};
# 10 "/home/jesmith/neovim/src/nvim/message.h" 2
# 1 "/home/jesmith/neovim/src/nvim/lib/kvec.h" 1
# 43 "/home/jesmith/neovim/src/nvim/lib/kvec.h"
# 1 "/home/jesmith/neovim/src/nvim/memory.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/memory.h" 2

# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4

# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));


# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 8 "/home/jesmith/neovim/src/nvim/memory.h" 2



# 10 "/home/jesmith/neovim/src/nvim/memory.h"
typedef void *(*MemMalloc)(size_t);


typedef void (*MemFree)(void *);


typedef void *(*MemCalloc)(size_t, size_t);


typedef void *(*MemRealloc)(void *, size_t);
# 44 "/home/jesmith/neovim/src/nvim/lib/kvec.h" 2
# 151 "/home/jesmith/neovim/src/nvim/lib/kvec.h"
static inline void *_memcpy_free(void *const restrict dest, void *const restrict src,
                                 const size_t size)
  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_ALWAYS_INLINE
{
  memcpy(dest, src, size);
  do { void **ptr_ = (void **)&(src); xfree(*ptr_); *ptr_ = 
# 156 "/home/jesmith/neovim/src/nvim/lib/kvec.h" 3 4
 ((void *)0)
# 156 "/home/jesmith/neovim/src/nvim/lib/kvec.h"
 ; (void)(*ptr_); } while (0);
  return dest;
}
# 11 "/home/jesmith/neovim/src/nvim/message.h" 2
# 33 "/home/jesmith/neovim/src/nvim/message.h"
typedef struct {
  String text;
  int attr;
} HlMessageChunk;

typedef struct { size_t size; size_t capacity; HlMessageChunk *items; } HlMessage;


typedef struct msg_hist {
  struct msg_hist *next;
  char_u *msg;
  const char *kind;
  int attr;
  
# 46 "/home/jesmith/neovim/src/nvim/message.h" 3 4
 _Bool 
# 46 "/home/jesmith/neovim/src/nvim/message.h"
      multiline;
} MessageHistoryEntry;


extern MessageHistoryEntry *first_msg_hist;

extern MessageHistoryEntry *last_msg_hist;

extern 
# 54 "/home/jesmith/neovim/src/nvim/message.h" 3 4
      _Bool 
# 54 "/home/jesmith/neovim/src/nvim/message.h"
           msg_ext_need_clear ;



extern ScreenGrid msg_grid ;
extern int msg_grid_pos ;







extern ScreenGrid msg_grid_adj ;


extern int msg_scrolled_at_flush ;
# 18 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/pos.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/pos.h" 2

typedef long linenr_T;




typedef int colnr_T;




enum { MAXLNUM = 0x7fffffff, };

enum { MAXCOL = 0x7fffffff, };

enum { MINLNUM = 1, };

enum { MINCOL = 1, };




typedef struct {
  linenr_T lnum;
  colnr_T col;
  colnr_T coladd;
} pos_T;





typedef struct {
  linenr_T lnum;
  colnr_T col;
} lpos_T;
# 19 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/profile.h" 1






typedef uint64_t proftime_T;
# 20 "/home/jesmith/neovim/src/nvim/eval/typval.h" 2






typedef int64_t varnumber_T;
typedef uint64_t uvarnumber_T;


typedef double float_T;


enum { DO_NOT_FREE_CNT = (0x7fffffff / 2), };


enum ListLenSpecials {




  kListLenUnknown = -1,





  kListLenShouldKnow = -2,



  kListLenMayKnow = -3,
};
# 64 "/home/jesmith/neovim/src/nvim/eval/typval.h"
typedef struct listvar_S list_T;
typedef struct dictvar_S dict_T;
typedef struct partial_S partial_T;
typedef struct blobvar_S blob_T;

typedef struct ufunc ufunc_T;

typedef enum {
  kCallbackNone = 0,
  kCallbackFuncref,
  kCallbackPartial,
} CallbackType;

typedef struct {
  union {
    char_u *funcref;
    partial_T *partial;
  } data;
  CallbackType type;
} Callback;



typedef struct dict_watcher {
  Callback callback;
  char *key_pattern;
  size_t key_pattern_len;
  QUEUE node;
  
# 92 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 92 "/home/jesmith/neovim/src/nvim/eval/typval.h"
      busy;
  
# 93 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 93 "/home/jesmith/neovim/src/nvim/eval/typval.h"
      needs_free;
} DictWatcher;


typedef enum {
  kBoolVarFalse,
  kBoolVarTrue,
} BoolVarValue;


typedef enum {
  kSpecialVarNull,
} SpecialVarValue;


typedef enum {
  VAR_UNLOCKED = 0,
  VAR_LOCKED = 1,
  VAR_FIXED = 2,
} VarLockStatus;


typedef enum {
  VAR_UNKNOWN = 0,
  VAR_NUMBER,
  VAR_STRING,
  VAR_FUNC,
  VAR_LIST,
  VAR_DICT,
  VAR_FLOAT,
  VAR_BOOL,
  VAR_SPECIAL,

  VAR_PARTIAL,
  VAR_BLOB,
} VarType;


typedef struct {
  VarType v_type;
  VarLockStatus v_lock;
  union typval_vval_union {
    varnumber_T v_number;
    BoolVarValue v_bool;
    SpecialVarValue v_special;
    float_T v_float;
    char_u *v_string;
    list_T *v_list;
    dict_T *v_dict;
    partial_T *v_partial;
    blob_T *v_blob;
  } vval;
} typval_T;


typedef enum {
  VAR_NO_SCOPE = 0,
  VAR_SCOPE = 1,
  VAR_DEF_SCOPE = 2,

} ScopeType;


typedef struct listitem_S listitem_T;

struct listitem_S {
  listitem_T *li_next;
  listitem_T *li_prev;
  typval_T li_tv;
};


typedef struct listwatch_S listwatch_T;

struct listwatch_S {
  listitem_T *lw_item;
  listwatch_T *lw_next;
};



struct listvar_S {
  listitem_T *lv_first;
  listitem_T *lv_last;
  listwatch_T *lv_watch;
  listitem_T *lv_idx_item;
  list_T *lv_copylist;
  list_T *lv_used_next;
  list_T *lv_used_prev;
  int lv_refcount;
  int lv_len;
  int lv_idx;
  int lv_copyID;
  VarLockStatus lv_lock;

  LuaRef lua_table_ref;
};


typedef struct {
  list_T sl_list;
  listitem_T sl_items[10];
} staticList10_T;
# 224 "/home/jesmith/neovim/src/nvim/eval/typval.h"
typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[1]; } ScopeDictDictItem;






typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[]; } dictitem_T;


typedef enum {
  DI_FLAGS_RO = 1,
  DI_FLAGS_RO_SBX = 2,
  DI_FLAGS_FIX = 4,
  DI_FLAGS_LOCK = 8,
  DI_FLAGS_ALLOC = 16,
} DictItemFlags;


struct dictvar_S {
  VarLockStatus dv_lock;
  ScopeType dv_scope;

  int dv_refcount;
  int dv_copyID;
  hashtab_T dv_hashtab;
  dict_T *dv_copydict;
  dict_T *dv_used_next;
  dict_T *dv_used_prev;
  QUEUE watchers;

  LuaRef lua_table_ref;
};


struct blobvar_S {
  garray_T bv_ga;
  int bv_refcount;
  VarLockStatus bv_lock;
};


typedef int scid_T;
# 276 "/home/jesmith/neovim/src/nvim/eval/typval.h"
typedef struct {
  scid_T sc_sid;
  int sc_seq;
  linenr_T sc_lnum;
} sctx_T;
# 291 "/home/jesmith/neovim/src/nvim/eval/typval.h"
typedef int (*cfunc_T)(int argcount, typval_T *argvars, typval_T *rettv, void *state);

typedef void (*cfunc_free_T)(void *state);


typedef struct funccall_S funccall_T;

struct funccall_S {
  ufunc_T *func;
  int linenr;
  int returned;

  struct { typval_T di_tv; uint8_t di_flags; char_u di_key[20 + 1]; } fixvar[12];
  dict_T l_vars;
  ScopeDictDictItem l_vars_var;
  dict_T l_avars;
  ScopeDictDictItem l_avars_var;
  list_T l_varlist;
  listitem_T l_listitems[20];
  typval_T *rettv;
  linenr_T breakpoint;
  int dbg_tick;
  int level;
  proftime_T prof_child;
  funccall_T *caller;

  int fc_refcount;
  int fc_copyID;
  garray_T fc_funcs;
};


struct ufunc {
  int uf_varargs;
  int uf_flags;
  int uf_calls;
  
# 327 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 327 "/home/jesmith/neovim/src/nvim/eval/typval.h"
      uf_cleared;
  garray_T uf_args;
  garray_T uf_def_args;
  garray_T uf_lines;
  int uf_profiling;
  int uf_prof_initialized;

  cfunc_T uf_cb;
  cfunc_free_T uf_cb_free;
  void *uf_cb_state;

  int uf_tm_count;
  proftime_T uf_tm_total;
  proftime_T uf_tm_self;
  proftime_T uf_tm_children;

  int *uf_tml_count;
  proftime_T *uf_tml_total;
  proftime_T *uf_tml_self;
  proftime_T uf_tml_start;
  proftime_T uf_tml_children;
  proftime_T uf_tml_wait;
  int uf_tml_idx;
  int uf_tml_execed;
  sctx_T uf_script_ctx;

  int uf_refcount;
  funccall_T *uf_scoped;
  char_u uf_name[];


};

struct partial_S {
  int pt_refcount;
  char_u *pt_name;
  ufunc_T *pt_func;

  
# 365 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
 _Bool 
# 365 "/home/jesmith/neovim/src/nvim/eval/typval.h"
      pt_auto;

  int pt_argc;
  typval_T *pt_argv;
  dict_T *pt_dict;
};


typedef struct ht_stack_S {
  hashtab_T *ht;
  struct ht_stack_S *prev;
} ht_stack_T;


typedef struct list_stack_S {
  list_T *list;
  struct list_stack_S *prev;
} list_stack_T;


typedef struct {
  listitem_T *item;
  int idx;
} ListSortItem;

typedef int (*ListSorter)(const void *, const void *);
# 487 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline void tv_list_ref(list_T *const l)
  __attribute__((always_inline));






static inline void tv_list_ref(list_T *const l)
{
  if (l == 
# 497 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 497 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    return;
  }
  l->lv_refcount++;
}

static inline void tv_list_set_ret(typval_T *const tv, list_T *const l)
  __attribute__((always_inline)) __attribute__((nonnull(1)));





static inline void tv_list_set_ret(typval_T *const tv, list_T *const l)
{
  tv->v_type = VAR_LIST;
  tv->vval.v_list = l;
  tv_list_ref(l);
}

static inline VarLockStatus tv_list_locked(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline VarLockStatus tv_list_locked(const list_T *const l)
{
  if (l == 
# 527 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 527 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    return VAR_FIXED;
  }
  return l->lv_lock;
}







static inline void tv_list_set_lock(list_T *const l, const VarLockStatus lock)
{
  if (l == 
# 541 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 541 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    
# 542 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
   ((void) (0))
# 542 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                            ;
    return;
  }
  l->lv_lock = lock;
}







static inline void tv_list_set_copyid(list_T *const l, const int copyid)
  FUNC_ATTR_NONNULL_ALL
{
  l->lv_copyID = copyid;
}

static inline int tv_list_len(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));




static inline int tv_list_len(const list_T *const l)
{
  ;
  if (l == 
# 569 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 569 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    return 0;
  }
  return l->lv_len;
}

static inline int tv_list_copyid(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));






static inline int tv_list_copyid(const list_T *const l)
{
  return l->lv_copyID;
}

static inline list_T *tv_list_latest_copy(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));
# 598 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline list_T *tv_list_latest_copy(const list_T *const l)
{
  return l->lv_copylist;
}

static inline int tv_list_uidx(const list_T *const l, int n)
  __attribute__ ((pure)) __attribute__((warn_unused_result));







static inline int tv_list_uidx(const list_T *const l, int n)
{

  if (n < 0) {
    n += tv_list_len(l);
  }


  if (n < 0 || n >= tv_list_len(l)) {
    return -1;
  }
  return n;
}

static inline 
# 626 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 626 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_list_has_watchers(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));
# 636 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline 
# 636 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 636 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_list_has_watchers(const list_T *const l)
{
  return l && l->lv_watch;
}

static inline listitem_T *tv_list_first(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline listitem_T *tv_list_first(const list_T *const l)
{
  if (l == 
# 651 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 651 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    ;
    return 
# 653 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 653 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ;
  }
  ;
  return l->lv_first;
}

static inline listitem_T *tv_list_last(const list_T *const l)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline listitem_T *tv_list_last(const list_T *const l)
{
  if (l == 
# 669 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 669 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    ;
    return 
# 671 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 671 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ;
  }
  ;
  return l->lv_last;
}

static inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)
  __attribute__((always_inline)) __attribute__((nonnull(1)));





static inline void tv_dict_set_ret(typval_T *const tv, dict_T *const d)
{
  tv->v_type = VAR_DICT;
  tv->vval.v_dict = d;
  if (d != 
# 688 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 688 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    d->dv_refcount++;
  }
}

static inline long tv_dict_len(const dict_T *const d)
  __attribute__ ((pure)) __attribute__((warn_unused_result));




static inline long tv_dict_len(const dict_T *const d)
{
  if (d == 
# 701 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 701 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    return 0L;
  }
  return (long)d->dv_hashtab.ht_used;
}

static inline 
# 707 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 707 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_dict_is_watched(const dict_T *const d)
  __attribute__ ((pure)) __attribute__((warn_unused_result));






static inline 
# 715 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 715 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_dict_is_watched(const dict_T *const d)
{
  return d && !QUEUE_EMPTY(&d->watchers);
}

static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)
  __attribute__((always_inline)) __attribute__((nonnull(1)));







static inline void tv_blob_set_ret(typval_T *const tv, blob_T *const b)
{
  tv->v_type = VAR_BLOB;
  tv->vval.v_blob = b;
  if (b != 
# 733 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 733 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    b->bv_refcount++;
  }
}

static inline int tv_blob_len(const blob_T *const b)
  __attribute__ ((pure)) __attribute__((warn_unused_result));




static inline int tv_blob_len(const blob_T *const b)
{
  if (b == 
# 746 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          ((void *)0)
# 746 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ) {
    return 0;
  }
  return b->bv_ga.ga_len;
}

static inline char_u tv_blob_get(const blob_T *const b, int idx)
  __attribute__((always_inline)) __attribute__((nonnull)) __attribute__((warn_unused_result));







static inline char_u tv_blob_get(const blob_T *const b, int idx)
{
  return ((char_u *)b->bv_ga.ga_data)[idx];
}

static inline void tv_blob_set(blob_T *const b, int idx, char_u c)
  __attribute__((always_inline)) __attribute__((nonnull));






static inline void tv_blob_set(blob_T *const b, int idx, char_u c)
{
  ((char_u *)b->bv_ga.ga_data)[idx] = c;
}






static inline void tv_init(typval_T *const tv)
{
  if (tv != 
# 786 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
           ((void *)0)
# 786 "/home/jesmith/neovim/src/nvim/eval/typval.h"
               ) {
    memset(tv, 0, sizeof(*tv));
  }
}
# 801 "/home/jesmith/neovim/src/nvim/eval/typval.h"
extern const char *const tv_empty_string;


extern 
# 804 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
      _Bool 
# 804 "/home/jesmith/neovim/src/nvim/eval/typval.h"
           tv_in_free_unref_items;
# 891 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline 
# 891 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 891 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_get_float_chk(const typval_T *const tv,
                                    float_T *const ret_f)
  __attribute__((nonnull)) __attribute__((warn_unused_result));



# 896 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
_Bool 
# 896 "/home/jesmith/neovim/src/nvim/eval/typval.h"
    semsg(const char *const fmt, ...);
# 906 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline 
# 906 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 906 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_get_float_chk(const typval_T *const tv, float_T *const ret_f)
{
  if (tv->v_type == VAR_FLOAT) {
    *ret_f = tv->vval.v_float;
    return 
# 910 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          1
# 910 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ;
  }
  if (tv->v_type == VAR_NUMBER) {
    *ret_f = (float_T)tv->vval.v_number;
    return 
# 914 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
          1
# 914 "/home/jesmith/neovim/src/nvim/eval/typval.h"
              ;
  }
  semsg("%s", 
# 916 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             dcgettext (((void *)0), 
# 916 "/home/jesmith/neovim/src/nvim/eval/typval.h"
             (char *)("E808: Number or Float required")
# 916 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             , 5)
# 916 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                                                );
  return 
# 917 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
        0
# 917 "/home/jesmith/neovim/src/nvim/eval/typval.h"
             ;
}

static inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)
  __attribute__((nonnull)) __attribute__((returns_nonnull)) __attribute__ ((pure))
  __attribute__((warn_unused_result)) __attribute__((always_inline));





static inline DictWatcher *tv_dict_watcher_node_data(QUEUE *q)
{
  return ((DictWatcher *)((char *)(q) - 
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
        __builtin_offsetof (
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h"
        DictWatcher
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
        , 
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h"
        node
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
        )
# 930 "/home/jesmith/neovim/src/nvim/eval/typval.h"
        ));
}

static inline 
# 933 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 933 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_is_func(const typval_T tv)
  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_CONST;
# 943 "/home/jesmith/neovim/src/nvim/eval/typval.h"
static inline 
# 943 "/home/jesmith/neovim/src/nvim/eval/typval.h" 3 4
             _Bool 
# 943 "/home/jesmith/neovim/src/nvim/eval/typval.h"
                  tv_is_func(const typval_T tv)
{
  return tv.v_type == VAR_FUNC || tv.v_type == VAR_PARTIAL;
}
# 6 "/home/jesmith/neovim/src/nvim/api/private/converter.h" 2
# 8 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/api/private/helpers.h" 1




# 1 "/home/jesmith/neovim/src/nvim/decoration.h" 1



# 1 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 1
# 9 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct file_buffer buf_T;



typedef struct {
  buf_T *br_buf;
  int br_fnum;
  int br_buf_free_count;
} bufref_T;






# 1 "/home/jesmith/neovim/src/nvim/highlight_defs.h" 1
# 9 "/home/jesmith/neovim/src/nvim/highlight_defs.h"
typedef int32_t RgbValue;




typedef enum {
  HL_INVERSE = 0x01,
  HL_BOLD = 0x02,
  HL_ITALIC = 0x04,
  HL_UNDERLINE = 0x08,
  HL_UNDERCURL = 0x10,
  HL_STANDOUT = 0x20,
  HL_STRIKETHROUGH = 0x40,
  HL_NOCOMBINE = 0x80,
  HL_BG_INDEXED = 0x0100,
  HL_FG_INDEXED = 0x0200,
  HL_DEFAULT = 0x0400,
  HL_GLOBAL = 0x0800,
} HlAttrFlags;



typedef struct attr_entry {
  int16_t rgb_ae_attr, cterm_ae_attr;
  RgbValue rgb_fg_color, rgb_bg_color, rgb_sp_color;
  int cterm_fg_color, cterm_bg_color;
  int hl_blend;
} HlAttrs;
# 51 "/home/jesmith/neovim/src/nvim/highlight_defs.h"
typedef enum {
  HLF_8 = 0,

  HLF_EOB,
  HLF_TERM,
  HLF_TERMNC,
  HLF_AT,
  HLF_D,
  HLF_E,
  HLF_I,
  HLF_L,
  HLF_M,
  HLF_CM,
  HLF_N,
  HLF_LNA,
  HLF_LNB,
  HLF_CLN,
  HLF_R,
  HLF_S,
  HLF_SNC,
  HLF_C,
  HLF_T,
  HLF_V,
  HLF_VNC,
  HLF_W,
  HLF_WM,
  HLF_FL,
  HLF_FC,
  HLF_ADD,
  HLF_CHD,
  HLF_DED,
  HLF_TXD,
  HLF_SC,
  HLF_CONCEAL,
  HLF_SPB,
  HLF_SPC,
  HLF_SPR,
  HLF_SPL,
  HLF_PNI,
  HLF_PSI,
  HLF_PSB,
  HLF_PST,
  HLF_TP,
  HLF_TPS,
  HLF_TPF,
  HLF_CUC,
  HLF_CUL,
  HLF_MC,
  HLF_QFL,
  HLF_0,
  HLF_INACTIVE,
  HLF_MSGSEP,
  HLF_NFLOAT,
  HLF_MSG,
  HLF_BORDER,
  HLF_COUNT,
} hlf_T;

extern const char *hlf_names[]
# 163 "/home/jesmith/neovim/src/nvim/highlight_defs.h"
  ;


extern int highlight_attr[HLF_COUNT];
extern int highlight_attr_last[HLF_COUNT];
extern int highlight_user[9];
extern int highlight_stlnc[9];
extern int cterm_normal_fg_color ;
extern int cterm_normal_bg_color ;
extern RgbValue normal_fg ;
extern RgbValue normal_bg ;
extern RgbValue normal_sp ;

typedef enum {
  kHlUnknown,
  kHlUI,
  kHlSyntax,
  kHlTerminal,
  kHlCombine,
  kHlBlend,
  kHlBlendThrough,
} HlKind;

typedef struct {
  HlAttrs attr;
  HlKind kind;
  int id1;
  int id2;
  int winid;
} HlEntry;

typedef struct {
  int ns_id;
  int syn_id;
} ColorKey;


typedef struct {
  int attr_id;
  int link_id;
  int version;
  
# 204 "/home/jesmith/neovim/src/nvim/highlight_defs.h" 3 4
 _Bool 
# 204 "/home/jesmith/neovim/src/nvim/highlight_defs.h"
      is_default;
} ColorItem;
# 25 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2



# 1 "/home/jesmith/neovim/src/nvim/option_defs.h" 1



# 1 "/home/jesmith/neovim/src/nvim/eval/typval.h" 1
# 5 "/home/jesmith/neovim/src/nvim/option_defs.h" 2
# 159 "/home/jesmith/neovim/src/nvim/option_defs.h"
enum {
  SHM_RO = 'r',
  SHM_MOD = 'm',
  SHM_FILE = 'f',
  SHM_LAST = 'i',
  SHM_TEXT = 'x',
  SHM_LINES = 'l',
  SHM_NEW = 'n',
  SHM_WRI = 'w',
  SHM_ABBREVIATIONS = 'a',
  SHM_WRITE = 'W',
  SHM_TRUNC = 't',
  SHM_TRUNCALL = 'T',
  SHM_OVER = 'o',
  SHM_OVERALL = 'O',
  SHM_SEARCH = 's',
  SHM_ATTENTION = 'A',
  SHM_INTRO = 'I',
  SHM_COMPLETIONMENU = 'c',
  SHM_RECORDING = 'q',
  SHM_FILEINFO = 'F',
  SHM_SEARCHCOUNT = 'S',
};
# 228 "/home/jesmith/neovim/src/nvim/option_defs.h"
enum {
  STL_FILEPATH = 'f',
  STL_FULLPATH = 'F',
  STL_FILENAME = 't',
  STL_COLUMN = 'c',
  STL_VIRTCOL = 'v',
  STL_VIRTCOL_ALT = 'V',
  STL_LINE = 'l',
  STL_NUMLINES = 'L',
  STL_BUFNO = 'n',
  STL_KEYMAP = 'k',
  STL_OFFSET = 'o',
  STL_OFFSET_X = 'O',
  STL_BYTEVAL = 'b',
  STL_BYTEVAL_X = 'B',
  STL_ROFLAG = 'r',
  STL_ROFLAG_ALT = 'R',
  STL_HELPFLAG = 'h',
  STL_HELPFLAG_ALT = 'H',
  STL_FILETYPE = 'y',
  STL_FILETYPE_ALT = 'Y',
  STL_PREVIEWFLAG = 'w',
  STL_PREVIEWFLAG_ALT = 'W',
  STL_MODIFIED = 'm',
  STL_MODIFIED_ALT = 'M',
  STL_QUICKFIX = 'q',
  STL_PERCENTAGE = 'p',
  STL_ALTPERCENT = 'P',
  STL_ARGLISTSTAT = 'a',
  STL_PAGENUM = 'N',
  STL_VIM_EXPR = '{',
  STL_SEPARATE = '=',
  STL_TRUNCMARK = '<',
  STL_USER_HL = '*',
  STL_HIGHLIGHT = '#',
  STL_TABPAGENR = 'T',
  STL_TABCLOSENR = 'X',
  STL_CLICK_FUNC = '@',
};
# 308 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern long p_aleph;
extern int p_acd;
extern char_u *p_ambw;
extern int p_ar;
extern int p_aw;
extern int p_awa;
extern char_u *p_bs;
extern char_u *p_bg;
extern int p_bk;
extern char_u *p_bkc;
extern unsigned int bkc_flags;
# 328 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern char_u *p_bdir;
extern char_u *p_bex;
extern char_u *p_bo;
extern char breakat_flags[256];
extern unsigned bo_flags;
# 362 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern char_u *p_bsk;
extern char_u *p_breakat;
extern char_u *p_cmp;
extern unsigned cmp_flags;





extern char_u *p_enc;
extern int p_deco;
extern char_u *p_ccv;
extern char_u *p_cedit;
extern char_u *p_cb;
extern unsigned cb_flags;






extern long p_cwh;
extern long p_ch;
extern long p_columns;
extern int p_confirm;
extern char_u *p_cot;



extern long p_pb;
extern long p_ph;
extern long p_pw;
extern char_u *p_cpo;
extern char_u *p_csprg;
extern int p_csre;
extern char_u *p_csqf;


extern int p_cst;
extern long p_csto;
extern long p_cspc;
extern int p_csverbose;
extern char_u *p_debug;
extern char_u *p_def;
extern char_u *p_inc;
extern char_u *p_dip;
extern char_u *p_dex;
extern char_u *p_dict;
extern int p_dg;
extern char_u *p_dir;
extern char_u *p_dy;
extern unsigned dy_flags;
# 423 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern int p_ed;
extern int p_emoji;
extern char_u *p_ead;
extern int p_ea;
extern char_u *p_ep;
extern int p_eb;
extern char_u *p_ef;
extern char_u *p_efm;
extern char_u *p_gefm;
extern char_u *p_gp;
extern char_u *p_ei;
extern int p_exrc;
extern char_u *p_fencs;
extern char_u *p_ffs;
extern int p_fic;
extern char_u *p_fcl;
extern long p_fdls;
extern char_u *p_fdo;
extern unsigned fdo_flags;
# 458 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern char_u *p_fp;
extern int p_fs;
extern int p_gd;
extern char_u *p_pdev;
extern char_u *p_penc;
extern char_u *p_pexpr;
extern char_u *p_pmfn;
extern char_u *p_pmcs;
extern char_u *p_pfn;
extern char_u *p_popt;
extern char_u *p_header;
extern char_u *p_guicursor;
extern char_u *p_guifont;
extern char_u *p_guifontwide;
extern char_u *p_hf;
extern long p_hh;
extern char_u *p_hlg;
extern int p_hid;
extern char_u *p_hl;
extern int p_hls;
extern long p_hi;
extern int p_hkmap;
extern int p_hkmapp;
extern int p_arshape;
extern int p_icon;
extern char_u *p_iconstring;
extern int p_ic;
extern int p_is;
extern char_u *p_icm;
extern int p_im;
extern char_u *p_isf;
extern char_u *p_isi;
extern char_u *p_isp;
extern int p_js;
extern char_u *p_jop;
extern unsigned jop_flags;




extern char_u *p_kp;
extern char_u *p_km;
extern char_u *p_langmap;
extern int p_lnr;
extern int p_lrm;
extern char_u *p_lm;
extern long p_lines;
extern long p_linespace;
extern char_u *p_lispwords;
extern long p_ls;
extern long p_stal;
extern char_u *p_lcs;

extern int p_lz;
extern int p_lpl;
extern int p_magic;
extern char_u *p_menc;
extern char_u *p_mef;
extern char_u *p_mp;
extern char_u *p_cc;
extern int p_cc_cols[256];
extern long p_mat;
extern long p_mco;
extern long p_mfd;
extern long p_mmd;
extern long p_mmp;
extern long p_mis;
extern char_u *p_msm;
extern long p_mle;
extern long p_mls;
extern char_u *p_mouse;
extern char_u *p_mousem;
extern long p_mousef;
extern long p_mouset;
extern int p_more;
extern char_u *p_opfunc;
extern char_u *p_para;
extern int p_paste;
extern char_u *p_pt;
extern char_u *p_pex;
extern char_u *p_pm;
extern char_u *p_path;
extern char_u *p_cdpath;
extern long p_pyx;
extern char_u *p_rdb;
extern unsigned rdb_flags;
# 558 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern long p_rdt;
extern int p_remap;
extern long p_re;
extern long p_report;
extern long p_pvh;
extern int p_ari;
extern int p_ri;
extern int p_ru;
extern char_u *p_ruf;
extern char_u *p_pp;
extern char_u *p_qftf;
extern char_u *p_rtp;
extern long p_scbk;
extern long p_sj;
extern long p_so;
extern char_u *p_sbo;
extern char_u *p_sections;
extern int p_secure;
extern char_u *p_sel;
extern char_u *p_slm;
extern char_u *p_ssop;
extern unsigned ssop_flags;
# 608 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern char_u *p_sh;
extern char_u *p_shcf;
extern char_u *p_sp;
extern char_u *p_shq;
extern char_u *p_sxq;
extern char_u *p_sxe;
extern char_u *p_srr;
extern int p_stmp;



extern char_u *p_stl;
extern int p_sr;
extern char_u *p_shm;
extern char_u *p_sbr;
extern int p_sc;
extern int p_sft;
extern int p_sm;
extern int p_smd;
extern long p_ss;
extern long p_siso;
extern int p_scs;
extern int p_sta;
extern int p_sb;
extern long p_tpm;
extern char_u *p_tal;
extern char_u *p_tpf;
extern unsigned int tpf_flags;
# 647 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern char_u *p_sps;
extern int p_spr;
extern int p_sol;
extern char_u *p_su;
extern char_u *p_swb;
extern unsigned swb_flags;
# 663 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern int p_tbs;
extern char_u *p_tc;
extern unsigned tc_flags;
# 675 "/home/jesmith/neovim/src/nvim/option_defs.h"
extern long p_tl;
extern int p_tr;
extern char_u *p_tags;
extern int p_tgst;
extern int p_tbidi;
extern int p_terse;
extern int p_to;
extern int p_timeout;
extern long p_tm;
extern int p_title;
extern long p_titlelen;
extern char_u *p_titleold;
extern char_u *p_titlestring;
extern char_u *p_tsr;
extern char_u *p_tsrfu;
extern int p_tgc;
extern int p_ttimeout;
extern long p_ttm;
extern char_u *p_udir;
extern long p_ul;
extern long p_ur;
extern long p_uc;
extern long p_ut;
extern char_u *p_fcs;
extern char_u *p_shada;
extern char *p_shadafile;
extern char_u *p_vdir;
extern char_u *p_vop;
extern unsigned vop_flags;
extern int p_vb;
extern char_u *p_ve;
extern unsigned ve_flags;







extern long p_verbose;



extern char_u *p_vfile;

extern int p_warn;
extern char_u *p_wop;
extern unsigned wop_flags;





extern long p_window;
extern char_u *p_wak;
extern char_u *p_wig;
extern char_u *p_ww;
extern long p_wc;
extern long p_wcm;
extern int p_wic;
extern char_u *p_wim;
extern int p_wmnu;
extern long p_wh;
extern long p_wmh;
extern long p_wmw;
extern long p_wiw;
extern int p_ws;
extern int p_write;
extern int p_wa;
extern int p_wb;
extern long p_wd;

extern int p_force_on;
extern int p_force_off;






enum {
  BV_AI = 0,
  BV_AR,
  BV_BH,
  BV_BKC,
  BV_BT,
  BV_EFM,
  BV_GP,
  BV_MP,
  BV_BIN,
  BV_BL,
  BV_BOMB,
  BV_CHANNEL,
  BV_CI,
  BV_CIN,
  BV_CINK,
  BV_CINO,
  BV_CINW,
  BV_CM,
  BV_CMS,
  BV_COM,
  BV_CPT,
  BV_DICT,
  BV_TSR,
  BV_CSL,
  BV_CFU,
  BV_DEF,
  BV_INC,
  BV_EOL,
  BV_FIXEOL,
  BV_EP,
  BV_ET,
  BV_FENC,
  BV_FP,
  BV_BEXPR,
  BV_FEX,
  BV_FF,
  BV_FLP,
  BV_FO,
  BV_FT,
  BV_IMI,
  BV_IMS,
  BV_INDE,
  BV_INDK,
  BV_INEX,
  BV_INF,
  BV_ISK,
  BV_KMAP,
  BV_KP,
  BV_LISP,
  BV_LW,
  BV_MENC,
  BV_MA,
  BV_ML,
  BV_MOD,
  BV_MPS,
  BV_NF,
  BV_OFU,
  BV_PATH,
  BV_PI,
  BV_QE,
  BV_RO,
  BV_SCBK,
  BV_SI,
  BV_SMC,
  BV_SYN,
  BV_SPC,
  BV_SPF,
  BV_SPL,
  BV_SPO,
  BV_STS,
  BV_SUA,
  BV_SW,
  BV_SWF,
  BV_TFU,
  BV_TSRFU,
  BV_TAGS,
  BV_TC,
  BV_TS,
  BV_TW,
  BV_TX,
  BV_UDF,
  BV_UL,
  BV_WM,
  BV_VSTS,
  BV_VTS,
  BV_COUNT,
};






enum {
  WV_LIST = 0,
  WV_ARAB,
  WV_COCU,
  WV_COLE,
  WV_CRBIND,
  WV_BRI,
  WV_BRIOPT,
  WV_DIFF,
  WV_FDC,
  WV_FEN,
  WV_FDI,
  WV_FDL,
  WV_FDM,
  WV_FML,
  WV_FDN,
  WV_FDE,
  WV_FDT,
  WV_FMR,
  WV_LBR,
  WV_NU,
  WV_RNU,
  WV_NUW,
  WV_PVW,
  WV_RL,
  WV_RLC,
  WV_SCBIND,
  WV_SCROLL,
  WV_SISO,
  WV_SO,
  WV_SPELL,
  WV_CUC,
  WV_CUL,
  WV_CULOPT,
  WV_CC,
  WV_SBR,
  WV_STL,
  WV_WFH,
  WV_WFW,
  WV_WRAP,
  WV_SCL,
  WV_WINHL,
  WV_FCS,
  WV_LCS,
  WV_WINBL,
  WV_COUNT,
};







typedef struct {
  sctx_T script_ctx;
  uint64_t channel_id;
} LastSet;
# 29 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/jesmith/neovim/src/nvim/mark_defs.h" 1




# 1 "/home/jesmith/neovim/src/nvim/os/time.h" 1







typedef uint64_t Timestamp;
# 6 "/home/jesmith/neovim/src/nvim/mark_defs.h" 2
# 35 "/home/jesmith/neovim/src/nvim/mark_defs.h"
typedef struct filemark {
  pos_T mark;
  int fnum;
  Timestamp timestamp;
  dict_T *additional_data;
} fmark_T;


typedef struct xfilemark {
  fmark_T fmark;
  char_u *fname;
} xfmark_T;
# 31 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/jesmith/neovim/src/nvim/undo_defs.h" 1





# 1 "/home/jesmith/neovim/src/nvim/extmark_defs.h" 1






typedef struct Decoration Decoration;

typedef struct {
  char *text;
  int hl_id;
} VirtTextChunk;


typedef struct {
  uint64_t ns_id;
  uint64_t mark_id;



  Decoration *decor;
} ExtmarkItem;

typedef struct undo_object ExtmarkUndoObject;
typedef struct { size_t size; size_t capacity; ExtmarkUndoObject *items; } extmark_undo_vec_t;



typedef enum {
  kExtmarkNOOP,
  kExtmarkUndo,
  kExtmarkNoUndo,
  kExtmarkUndoNoRedo,
} ExtmarkOp;

typedef enum {
  kDecorLevelNone = 0,
  kDecorLevelVisible = 1,
  kDecorLevelVirtLine = 2,
} DecorLevel;
# 7 "/home/jesmith/neovim/src/nvim/undo_defs.h" 2



typedef struct u_header u_header_T;


typedef struct {
  pos_T vi_start;
  pos_T vi_end;
  int vi_mode;
  colnr_T vi_curswant;
} visualinfo_T;

# 1 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 1
# 21 "/home/jesmith/neovim/src/nvim/undo_defs.h" 2

typedef struct u_entry u_entry_T;
struct u_entry {
  u_entry_T *ue_next;
  linenr_T ue_top;
  linenr_T ue_bot;
  linenr_T ue_lcount;
  char_u **ue_array;
  long ue_size;



};

struct u_header {


  union {
    u_header_T *ptr;
    long seq;
  } uh_next;
  union {
    u_header_T *ptr;
    long seq;
  } uh_prev;
  union {
    u_header_T *ptr;
    long seq;
  } uh_alt_next;
  union {
    u_header_T *ptr;
    long seq;
  } uh_alt_prev;
  long uh_seq;
  int uh_walk;
  u_entry_T *uh_entry;
  u_entry_T *uh_getbot_entry;
  pos_T uh_cursor;
  long uh_cursor_vcol;
  int uh_flags;
  fmark_T uh_namedm[('z' - 'a' + 1)];
  extmark_undo_vec_t uh_extmark;
  visualinfo_T uh_visual;
  time_t uh_time;
  long uh_save_nr;




};







typedef struct {
  buf_T *bi_buf;
  FILE *bi_fp;
} bufinfo_T;
# 33 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2
# 42 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
# 1 "/home/jesmith/neovim/src/nvim/map.h" 1






# 1 "/home/jesmith/neovim/src/nvim/api/private/dispatch.h" 1





typedef Object (*ApiDispatchWrapper)(uint64_t channel_id,
                                     Array args,
                                     Error *error);



typedef struct {
  ApiDispatchWrapper fn;
  
# 14 "/home/jesmith/neovim/src/nvim/api/private/dispatch.h" 3 4
 _Bool 
# 14 "/home/jesmith/neovim/src/nvim/api/private/dispatch.h"
      fast;



} MsgpackRpcRequestHandler;
# 8 "/home/jesmith/neovim/src/nvim/map.h" 2


# 1 "/home/jesmith/neovim/src/nvim/map_defs.h" 1



# 1 "/home/jesmith/neovim/src/nvim/lib/khash.h" 1
# 128 "/home/jesmith/neovim/src/nvim/lib/khash.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 129 "/home/jesmith/neovim/src/nvim/lib/khash.h" 2




# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 134 "/home/jesmith/neovim/src/nvim/lib/khash.h" 2





typedef unsigned int khint32_t;





typedef unsigned long khint64_t;
# 156 "/home/jesmith/neovim/src/nvim/lib/khash.h"
typedef khint32_t khint_t;
typedef khint_t khiter_t;
# 458 "/home/jesmith/neovim/src/nvim/lib/khash.h"
static inline khint_t __ac_X31_hash_string(const char *s)
{
  khint_t h = (khint_t)*s;
  if (h) {
    for (++s; *s; ++s) { h = (h << 5) - h + (uint8_t)*s; }
  }
  return h;
}
# 477 "/home/jesmith/neovim/src/nvim/lib/khash.h"
static inline khint_t __ac_Wang_hash(khint_t key)
{
  key += ~(key << 15);
  key ^= (key >> 10);
  key += (key << 3);
  key ^= (key >> 6);
  key += ~(key << 11);
  key ^= (key >> 16);
  return key;
}
# 701 "/home/jesmith/neovim/src/nvim/lib/khash.h"
typedef const char *kh_cstr_t;
# 5 "/home/jesmith/neovim/src/nvim/map_defs.h" 2

typedef const char *cstr_t;
typedef void *ptr_t;
# 11 "/home/jesmith/neovim/src/nvim/map.h" 2
# 36 "/home/jesmith/neovim/src/nvim/map.h"
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; int *keys; int *vals; } kh_int_int_map_t; extern kh_int_int_map_t *kh_init_int_int_map(void); extern void kh_dealloc_int_int_map(kh_int_int_map_t *h); extern void kh_destroy_int_int_map(kh_int_int_map_t *h); extern void kh_clear_int_int_map(kh_int_int_map_t *h); extern khint_t kh_get_int_int_map(const kh_int_int_map_t *h, int key); extern void kh_resize_int_int_map(kh_int_int_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_int_int_map(kh_int_int_map_t *h, int key, int *ret); extern void kh_del_int_int_map(kh_int_int_map_t *h, khint_t x); typedef struct { kh_int_int_map_t table; } Map_int_int; Map_int_int *map_int_int_new(void); void map_int_int_free(Map_int_int *map); void map_int_int_destroy(Map_int_int *map); int map_int_int_get(Map_int_int *map, int key); 
# 36 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 36 "/home/jesmith/neovim/src/nvim/map.h"
map_int_int_has(Map_int_int *map, int key); int map_int_int_key(Map_int_int *map, int key); int map_int_int_put(Map_int_int *map, int key, int value); int *map_int_int_ref(Map_int_int *map, int key, 
# 36 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 36 "/home/jesmith/neovim/src/nvim/map.h"
put); int map_int_int_del(Map_int_int *map, int key); void map_int_int_clear(Map_int_int *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; cstr_t *keys; ptr_t *vals; } kh_cstr_t_ptr_t_map_t; extern kh_cstr_t_ptr_t_map_t *kh_init_cstr_t_ptr_t_map(void); extern void kh_dealloc_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern void kh_destroy_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern void kh_clear_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h); extern khint_t kh_get_cstr_t_ptr_t_map(const kh_cstr_t_ptr_t_map_t *h, cstr_t key); extern void kh_resize_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, cstr_t key, int *ret); extern void kh_del_cstr_t_ptr_t_map(kh_cstr_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_cstr_t_ptr_t_map_t table; } Map_cstr_t_ptr_t; Map_cstr_t_ptr_t *map_cstr_t_ptr_t_new(void); void map_cstr_t_ptr_t_free(Map_cstr_t_ptr_t *map); void map_cstr_t_ptr_t_destroy(Map_cstr_t_ptr_t *map); ptr_t map_cstr_t_ptr_t_get(Map_cstr_t_ptr_t *map, cstr_t key); 
# 37 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 37 "/home/jesmith/neovim/src/nvim/map.h"
map_cstr_t_ptr_t_has(Map_cstr_t_ptr_t *map, cstr_t key); cstr_t map_cstr_t_ptr_t_key(Map_cstr_t_ptr_t *map, cstr_t key); ptr_t map_cstr_t_ptr_t_put(Map_cstr_t_ptr_t *map, cstr_t key, ptr_t value); ptr_t *map_cstr_t_ptr_t_ref(Map_cstr_t_ptr_t *map, cstr_t key, 
# 37 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 37 "/home/jesmith/neovim/src/nvim/map.h"
put); ptr_t map_cstr_t_ptr_t_del(Map_cstr_t_ptr_t *map, cstr_t key); void map_cstr_t_ptr_t_clear(Map_cstr_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; cstr_t *keys; int *vals; } kh_cstr_t_int_map_t; extern kh_cstr_t_int_map_t *kh_init_cstr_t_int_map(void); extern void kh_dealloc_cstr_t_int_map(kh_cstr_t_int_map_t *h); extern void kh_destroy_cstr_t_int_map(kh_cstr_t_int_map_t *h); extern void kh_clear_cstr_t_int_map(kh_cstr_t_int_map_t *h); extern khint_t kh_get_cstr_t_int_map(const kh_cstr_t_int_map_t *h, cstr_t key); extern void kh_resize_cstr_t_int_map(kh_cstr_t_int_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_cstr_t_int_map(kh_cstr_t_int_map_t *h, cstr_t key, int *ret); extern void kh_del_cstr_t_int_map(kh_cstr_t_int_map_t *h, khint_t x); typedef struct { kh_cstr_t_int_map_t table; } Map_cstr_t_int; Map_cstr_t_int *map_cstr_t_int_new(void); void map_cstr_t_int_free(Map_cstr_t_int *map); void map_cstr_t_int_destroy(Map_cstr_t_int *map); int map_cstr_t_int_get(Map_cstr_t_int *map, cstr_t key); 
# 38 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 38 "/home/jesmith/neovim/src/nvim/map.h"
map_cstr_t_int_has(Map_cstr_t_int *map, cstr_t key); cstr_t map_cstr_t_int_key(Map_cstr_t_int *map, cstr_t key); int map_cstr_t_int_put(Map_cstr_t_int *map, cstr_t key, int value); int *map_cstr_t_int_ref(Map_cstr_t_int *map, cstr_t key, 
# 38 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 38 "/home/jesmith/neovim/src/nvim/map.h"
put); int map_cstr_t_int_del(Map_cstr_t_int *map, cstr_t key); void map_cstr_t_int_clear(Map_cstr_t_int *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; ptr_t *keys; ptr_t *vals; } kh_ptr_t_ptr_t_map_t; extern kh_ptr_t_ptr_t_map_t *kh_init_ptr_t_ptr_t_map(void); extern void kh_dealloc_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern void kh_destroy_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern void kh_clear_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h); extern khint_t kh_get_ptr_t_ptr_t_map(const kh_ptr_t_ptr_t_map_t *h, ptr_t key); extern void kh_resize_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, ptr_t key, int *ret); extern void kh_del_ptr_t_ptr_t_map(kh_ptr_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_ptr_t_ptr_t_map_t table; } Map_ptr_t_ptr_t; Map_ptr_t_ptr_t *map_ptr_t_ptr_t_new(void); void map_ptr_t_ptr_t_free(Map_ptr_t_ptr_t *map); void map_ptr_t_ptr_t_destroy(Map_ptr_t_ptr_t *map); ptr_t map_ptr_t_ptr_t_get(Map_ptr_t_ptr_t *map, ptr_t key); 
# 39 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 39 "/home/jesmith/neovim/src/nvim/map.h"
map_ptr_t_ptr_t_has(Map_ptr_t_ptr_t *map, ptr_t key); ptr_t map_ptr_t_ptr_t_key(Map_ptr_t_ptr_t *map, ptr_t key); ptr_t map_ptr_t_ptr_t_put(Map_ptr_t_ptr_t *map, ptr_t key, ptr_t value); ptr_t *map_ptr_t_ptr_t_ref(Map_ptr_t_ptr_t *map, ptr_t key, 
# 39 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 39 "/home/jesmith/neovim/src/nvim/map.h"
put); ptr_t map_ptr_t_ptr_t_del(Map_ptr_t_ptr_t *map, ptr_t key); void map_ptr_t_ptr_t_clear(Map_ptr_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ptr_t *vals; } kh_uint64_t_ptr_t_map_t; extern kh_uint64_t_ptr_t_map_t *kh_init_uint64_t_ptr_t_map(void); extern void kh_dealloc_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern void kh_destroy_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern void kh_clear_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h); extern khint_t kh_get_uint64_t_ptr_t_map(const kh_uint64_t_ptr_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ptr_t_map(kh_uint64_t_ptr_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_ptr_t_map_t table; } Map_uint64_t_ptr_t; Map_uint64_t_ptr_t *map_uint64_t_ptr_t_new(void); void map_uint64_t_ptr_t_free(Map_uint64_t_ptr_t *map); void map_uint64_t_ptr_t_destroy(Map_uint64_t_ptr_t *map); ptr_t map_uint64_t_ptr_t_get(Map_uint64_t_ptr_t *map, uint64_t key); 
# 40 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 40 "/home/jesmith/neovim/src/nvim/map.h"
map_uint64_t_ptr_t_has(Map_uint64_t_ptr_t *map, uint64_t key); uint64_t map_uint64_t_ptr_t_key(Map_uint64_t_ptr_t *map, uint64_t key); ptr_t map_uint64_t_ptr_t_put(Map_uint64_t_ptr_t *map, uint64_t key, ptr_t value); ptr_t *map_uint64_t_ptr_t_ref(Map_uint64_t_ptr_t *map, uint64_t key, 
# 40 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 40 "/home/jesmith/neovim/src/nvim/map.h"
put); ptr_t map_uint64_t_ptr_t_del(Map_uint64_t_ptr_t *map, uint64_t key); void map_uint64_t_ptr_t_clear(Map_uint64_t_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ssize_t *vals; } kh_uint64_t_ssize_t_map_t; extern kh_uint64_t_ssize_t_map_t *kh_init_uint64_t_ssize_t_map(void); extern void kh_dealloc_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern void kh_destroy_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern void kh_clear_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h); extern khint_t kh_get_uint64_t_ssize_t_map(const kh_uint64_t_ssize_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ssize_t_map(kh_uint64_t_ssize_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_ssize_t_map_t table; } Map_uint64_t_ssize_t; Map_uint64_t_ssize_t *map_uint64_t_ssize_t_new(void); void map_uint64_t_ssize_t_free(Map_uint64_t_ssize_t *map); void map_uint64_t_ssize_t_destroy(Map_uint64_t_ssize_t *map); ssize_t map_uint64_t_ssize_t_get(Map_uint64_t_ssize_t *map, uint64_t key); 
# 41 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 41 "/home/jesmith/neovim/src/nvim/map.h"
map_uint64_t_ssize_t_has(Map_uint64_t_ssize_t *map, uint64_t key); uint64_t map_uint64_t_ssize_t_key(Map_uint64_t_ssize_t *map, uint64_t key); ssize_t map_uint64_t_ssize_t_put(Map_uint64_t_ssize_t *map, uint64_t key, ssize_t value); ssize_t *map_uint64_t_ssize_t_ref(Map_uint64_t_ssize_t *map, uint64_t key, 
# 41 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 41 "/home/jesmith/neovim/src/nvim/map.h"
put); ssize_t map_uint64_t_ssize_t_del(Map_uint64_t_ssize_t *map, uint64_t key); void map_uint64_t_ssize_t_clear(Map_uint64_t_ssize_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; uint64_t *vals; } kh_uint64_t_uint64_t_map_t; extern kh_uint64_t_uint64_t_map_t *kh_init_uint64_t_uint64_t_map(void); extern void kh_dealloc_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern void kh_destroy_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern void kh_clear_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h); extern khint_t kh_get_uint64_t_uint64_t_map(const kh_uint64_t_uint64_t_map_t *h, uint64_t key); extern void kh_resize_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_uint64_t_map(kh_uint64_t_uint64_t_map_t *h, khint_t x); typedef struct { kh_uint64_t_uint64_t_map_t table; } Map_uint64_t_uint64_t; Map_uint64_t_uint64_t *map_uint64_t_uint64_t_new(void); void map_uint64_t_uint64_t_free(Map_uint64_t_uint64_t *map); void map_uint64_t_uint64_t_destroy(Map_uint64_t_uint64_t *map); uint64_t map_uint64_t_uint64_t_get(Map_uint64_t_uint64_t *map, uint64_t key); 
# 42 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 42 "/home/jesmith/neovim/src/nvim/map.h"
map_uint64_t_uint64_t_has(Map_uint64_t_uint64_t *map, uint64_t key); uint64_t map_uint64_t_uint64_t_key(Map_uint64_t_uint64_t *map, uint64_t key); uint64_t map_uint64_t_uint64_t_put(Map_uint64_t_uint64_t *map, uint64_t key, uint64_t value); uint64_t *map_uint64_t_uint64_t_ref(Map_uint64_t_uint64_t *map, uint64_t key, 
# 42 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 42 "/home/jesmith/neovim/src/nvim/map.h"
put); uint64_t map_uint64_t_uint64_t_del(Map_uint64_t_uint64_t *map, uint64_t key); void map_uint64_t_uint64_t_clear(Map_uint64_t_uint64_t *map);



typedef struct ExtmarkNs {
  Map_uint64_t_uint64_t map[1];
  uint64_t free_id;
} ExtmarkNs;

typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ExtmarkNs *vals; } kh_uint64_t_ExtmarkNs_map_t; extern kh_uint64_t_ExtmarkNs_map_t *kh_init_uint64_t_ExtmarkNs_map(void); extern void kh_dealloc_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern void kh_destroy_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern void kh_clear_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h); extern khint_t kh_get_uint64_t_ExtmarkNs_map(const kh_uint64_t_ExtmarkNs_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ExtmarkNs_map(kh_uint64_t_ExtmarkNs_map_t *h, khint_t x); typedef struct { kh_uint64_t_ExtmarkNs_map_t table; } Map_uint64_t_ExtmarkNs; Map_uint64_t_ExtmarkNs *map_uint64_t_ExtmarkNs_new(void); void map_uint64_t_ExtmarkNs_free(Map_uint64_t_ExtmarkNs *map); void map_uint64_t_ExtmarkNs_destroy(Map_uint64_t_ExtmarkNs *map); ExtmarkNs map_uint64_t_ExtmarkNs_get(Map_uint64_t_ExtmarkNs *map, uint64_t key); 
# 51 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 51 "/home/jesmith/neovim/src/nvim/map.h"
map_uint64_t_ExtmarkNs_has(Map_uint64_t_ExtmarkNs *map, uint64_t key); uint64_t map_uint64_t_ExtmarkNs_key(Map_uint64_t_ExtmarkNs *map, uint64_t key); ExtmarkNs map_uint64_t_ExtmarkNs_put(Map_uint64_t_ExtmarkNs *map, uint64_t key, ExtmarkNs value); ExtmarkNs *map_uint64_t_ExtmarkNs_ref(Map_uint64_t_ExtmarkNs *map, uint64_t key, 
# 51 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 51 "/home/jesmith/neovim/src/nvim/map.h"
put); ExtmarkNs map_uint64_t_ExtmarkNs_del(Map_uint64_t_ExtmarkNs *map, uint64_t key); void map_uint64_t_ExtmarkNs_clear(Map_uint64_t_ExtmarkNs *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; uint64_t *keys; ExtmarkItem *vals; } kh_uint64_t_ExtmarkItem_map_t; extern kh_uint64_t_ExtmarkItem_map_t *kh_init_uint64_t_ExtmarkItem_map(void); extern void kh_dealloc_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern void kh_destroy_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern void kh_clear_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h); extern khint_t kh_get_uint64_t_ExtmarkItem_map(const kh_uint64_t_ExtmarkItem_map_t *h, uint64_t key); extern void kh_resize_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, uint64_t key, int *ret); extern void kh_del_uint64_t_ExtmarkItem_map(kh_uint64_t_ExtmarkItem_map_t *h, khint_t x); typedef struct { kh_uint64_t_ExtmarkItem_map_t table; } Map_uint64_t_ExtmarkItem; Map_uint64_t_ExtmarkItem *map_uint64_t_ExtmarkItem_new(void); void map_uint64_t_ExtmarkItem_free(Map_uint64_t_ExtmarkItem *map); void map_uint64_t_ExtmarkItem_destroy(Map_uint64_t_ExtmarkItem *map); ExtmarkItem map_uint64_t_ExtmarkItem_get(Map_uint64_t_ExtmarkItem *map, uint64_t key); 
# 52 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 52 "/home/jesmith/neovim/src/nvim/map.h"
map_uint64_t_ExtmarkItem_has(Map_uint64_t_ExtmarkItem *map, uint64_t key); uint64_t map_uint64_t_ExtmarkItem_key(Map_uint64_t_ExtmarkItem *map, uint64_t key); ExtmarkItem map_uint64_t_ExtmarkItem_put(Map_uint64_t_ExtmarkItem *map, uint64_t key, ExtmarkItem value); ExtmarkItem *map_uint64_t_ExtmarkItem_ref(Map_uint64_t_ExtmarkItem *map, uint64_t key, 
# 52 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 52 "/home/jesmith/neovim/src/nvim/map.h"
put); ExtmarkItem map_uint64_t_ExtmarkItem_del(Map_uint64_t_ExtmarkItem *map, uint64_t key); void map_uint64_t_ExtmarkItem_clear(Map_uint64_t_ExtmarkItem *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; handle_T *keys; ptr_t *vals; } kh_handle_T_ptr_t_map_t; extern kh_handle_T_ptr_t_map_t *kh_init_handle_T_ptr_t_map(void); extern void kh_dealloc_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern void kh_destroy_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern void kh_clear_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h); extern khint_t kh_get_handle_T_ptr_t_map(const kh_handle_T_ptr_t_map_t *h, handle_T key); extern void kh_resize_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, handle_T key, int *ret); extern void kh_del_handle_T_ptr_t_map(kh_handle_T_ptr_t_map_t *h, khint_t x); typedef struct { kh_handle_T_ptr_t_map_t table; } Map_handle_T_ptr_t; Map_handle_T_ptr_t *map_handle_T_ptr_t_new(void); void map_handle_T_ptr_t_free(Map_handle_T_ptr_t *map); void map_handle_T_ptr_t_destroy(Map_handle_T_ptr_t *map); ptr_t map_handle_T_ptr_t_get(Map_handle_T_ptr_t *map, handle_T key); 
# 53 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 53 "/home/jesmith/neovim/src/nvim/map.h"
map_handle_T_ptr_t_has(Map_handle_T_ptr_t *map, handle_T key); handle_T map_handle_T_ptr_t_key(Map_handle_T_ptr_t *map, handle_T key); ptr_t map_handle_T_ptr_t_put(Map_handle_T_ptr_t *map, handle_T key, ptr_t value); ptr_t *map_handle_T_ptr_t_ref(Map_handle_T_ptr_t *map, handle_T key, 
# 53 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 53 "/home/jesmith/neovim/src/nvim/map.h"
put); ptr_t map_handle_T_ptr_t_del(Map_handle_T_ptr_t *map, handle_T key); void map_handle_T_ptr_t_clear(Map_handle_T_ptr_t *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; String *keys; MsgpackRpcRequestHandler *vals; } kh_String_MsgpackRpcRequestHandler_map_t; extern kh_String_MsgpackRpcRequestHandler_map_t *kh_init_String_MsgpackRpcRequestHandler_map(void); extern void kh_dealloc_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern void kh_destroy_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern void kh_clear_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h); extern khint_t kh_get_String_MsgpackRpcRequestHandler_map(const kh_String_MsgpackRpcRequestHandler_map_t *h, String key); extern void kh_resize_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, String key, int *ret); extern void kh_del_String_MsgpackRpcRequestHandler_map(kh_String_MsgpackRpcRequestHandler_map_t *h, khint_t x); typedef struct { kh_String_MsgpackRpcRequestHandler_map_t table; } Map_String_MsgpackRpcRequestHandler; Map_String_MsgpackRpcRequestHandler *map_String_MsgpackRpcRequestHandler_new(void); void map_String_MsgpackRpcRequestHandler_free(Map_String_MsgpackRpcRequestHandler *map); void map_String_MsgpackRpcRequestHandler_destroy(Map_String_MsgpackRpcRequestHandler *map); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_get(Map_String_MsgpackRpcRequestHandler *map, String key); 
# 54 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 54 "/home/jesmith/neovim/src/nvim/map.h"
map_String_MsgpackRpcRequestHandler_has(Map_String_MsgpackRpcRequestHandler *map, String key); String map_String_MsgpackRpcRequestHandler_key(Map_String_MsgpackRpcRequestHandler *map, String key); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_put(Map_String_MsgpackRpcRequestHandler *map, String key, MsgpackRpcRequestHandler value); MsgpackRpcRequestHandler *map_String_MsgpackRpcRequestHandler_ref(Map_String_MsgpackRpcRequestHandler *map, String key, 
# 54 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 54 "/home/jesmith/neovim/src/nvim/map.h"
put); MsgpackRpcRequestHandler map_String_MsgpackRpcRequestHandler_del(Map_String_MsgpackRpcRequestHandler *map, String key); void map_String_MsgpackRpcRequestHandler_clear(Map_String_MsgpackRpcRequestHandler *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; HlEntry *keys; int *vals; } kh_HlEntry_int_map_t; extern kh_HlEntry_int_map_t *kh_init_HlEntry_int_map(void); extern void kh_dealloc_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern void kh_destroy_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern void kh_clear_HlEntry_int_map(kh_HlEntry_int_map_t *h); extern khint_t kh_get_HlEntry_int_map(const kh_HlEntry_int_map_t *h, HlEntry key); extern void kh_resize_HlEntry_int_map(kh_HlEntry_int_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_HlEntry_int_map(kh_HlEntry_int_map_t *h, HlEntry key, int *ret); extern void kh_del_HlEntry_int_map(kh_HlEntry_int_map_t *h, khint_t x); typedef struct { kh_HlEntry_int_map_t table; } Map_HlEntry_int; Map_HlEntry_int *map_HlEntry_int_new(void); void map_HlEntry_int_free(Map_HlEntry_int *map); void map_HlEntry_int_destroy(Map_HlEntry_int *map); int map_HlEntry_int_get(Map_HlEntry_int *map, HlEntry key); 
# 55 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 55 "/home/jesmith/neovim/src/nvim/map.h"
map_HlEntry_int_has(Map_HlEntry_int *map, HlEntry key); HlEntry map_HlEntry_int_key(Map_HlEntry_int *map, HlEntry key); int map_HlEntry_int_put(Map_HlEntry_int *map, HlEntry key, int value); int *map_HlEntry_int_ref(Map_HlEntry_int *map, HlEntry key, 
# 55 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 55 "/home/jesmith/neovim/src/nvim/map.h"
put); int map_HlEntry_int_del(Map_HlEntry_int *map, HlEntry key); void map_HlEntry_int_clear(Map_HlEntry_int *map);
typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; String *keys; handle_T *vals; } kh_String_handle_T_map_t; extern kh_String_handle_T_map_t *kh_init_String_handle_T_map(void); extern void kh_dealloc_String_handle_T_map(kh_String_handle_T_map_t *h); extern void kh_destroy_String_handle_T_map(kh_String_handle_T_map_t *h); extern void kh_clear_String_handle_T_map(kh_String_handle_T_map_t *h); extern khint_t kh_get_String_handle_T_map(const kh_String_handle_T_map_t *h, String key); extern void kh_resize_String_handle_T_map(kh_String_handle_T_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_String_handle_T_map(kh_String_handle_T_map_t *h, String key, int *ret); extern void kh_del_String_handle_T_map(kh_String_handle_T_map_t *h, khint_t x); typedef struct { kh_String_handle_T_map_t table; } Map_String_handle_T; Map_String_handle_T *map_String_handle_T_new(void); void map_String_handle_T_free(Map_String_handle_T *map); void map_String_handle_T_destroy(Map_String_handle_T *map); handle_T map_String_handle_T_get(Map_String_handle_T *map, String key); 
# 56 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 56 "/home/jesmith/neovim/src/nvim/map.h"
map_String_handle_T_has(Map_String_handle_T *map, String key); String map_String_handle_T_key(Map_String_handle_T *map, String key); handle_T map_String_handle_T_put(Map_String_handle_T *map, String key, handle_T value); handle_T *map_String_handle_T_ref(Map_String_handle_T *map, String key, 
# 56 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 56 "/home/jesmith/neovim/src/nvim/map.h"
put); handle_T map_String_handle_T_del(Map_String_handle_T *map, String key); void map_String_handle_T_clear(Map_String_handle_T *map);

typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; ColorKey *keys; ColorItem *vals; } kh_ColorKey_ColorItem_map_t; extern kh_ColorKey_ColorItem_map_t *kh_init_ColorKey_ColorItem_map(void); extern void kh_dealloc_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h); extern void kh_destroy_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h); extern void kh_clear_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h); extern khint_t kh_get_ColorKey_ColorItem_map(const kh_ColorKey_ColorItem_map_t *h, ColorKey key); extern void kh_resize_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h, khint_t new_n_buckets); extern khint_t kh_put_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h, ColorKey key, int *ret); extern void kh_del_ColorKey_ColorItem_map(kh_ColorKey_ColorItem_map_t *h, khint_t x); typedef struct { kh_ColorKey_ColorItem_map_t table; } Map_ColorKey_ColorItem; Map_ColorKey_ColorItem *map_ColorKey_ColorItem_new(void); void map_ColorKey_ColorItem_free(Map_ColorKey_ColorItem *map); void map_ColorKey_ColorItem_destroy(Map_ColorKey_ColorItem *map); ColorItem map_ColorKey_ColorItem_get(Map_ColorKey_ColorItem *map, ColorKey key); 
# 58 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 58 "/home/jesmith/neovim/src/nvim/map.h"
map_ColorKey_ColorItem_has(Map_ColorKey_ColorItem *map, ColorKey key); ColorKey map_ColorKey_ColorItem_key(Map_ColorKey_ColorItem *map, ColorKey key); ColorItem map_ColorKey_ColorItem_put(Map_ColorKey_ColorItem *map, ColorKey key, ColorItem value); ColorItem *map_ColorKey_ColorItem_ref(Map_ColorKey_ColorItem *map, ColorKey key, 
# 58 "/home/jesmith/neovim/src/nvim/map.h" 3 4
_Bool 
# 58 "/home/jesmith/neovim/src/nvim/map.h"
put); ColorItem map_ColorKey_ColorItem_del(Map_ColorKey_ColorItem *map, ColorKey key); void map_ColorKey_ColorItem_clear(Map_ColorKey_ColorItem *map);
# 91 "/home/jesmith/neovim/src/nvim/map.h"
void pmap_del2(Map_cstr_t_ptr_t *map, const char *key);
# 43 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2



# 1 "/home/jesmith/neovim/src/nvim/marktree.h" 1
# 13 "/home/jesmith/neovim/src/nvim/marktree.h"
typedef struct {
  int32_t row;
  int32_t col;
} mtpos_t;

typedef struct {
  int32_t row;
  int32_t col;
  uint64_t id;
  
# 22 "/home/jesmith/neovim/src/nvim/marktree.h" 3 4
 _Bool 
# 22 "/home/jesmith/neovim/src/nvim/marktree.h"
      right_gravity;
} mtmark_t;

typedef struct mtnode_s mtnode_t;
typedef struct {
  int oldcol;
  int i;
} iterstate_t;

typedef struct {
  mtpos_t pos;
  int lvl;
  mtnode_t *node;
  int i;
  iterstate_t s[20];
} MarkTreeIter;






typedef struct {
  mtpos_t pos;
  uint64_t id;
} mtkey_t;

struct mtnode_s {
  int32_t n;
  int32_t level;


  mtnode_t *parent;
  mtkey_t key[2 * 10 - 1];
  mtnode_t *ptr[];
};



typedef struct {
  mtnode_t *root;
  size_t n_keys, n_nodes;
  uint64_t next_id;


  Map_uint64_t_ptr_t id2node[1];
} MarkTree;
# 82 "/home/jesmith/neovim/src/nvim/marktree.h"
static inline uint8_t marktree_decor_level(uint64_t id)
{
  return (uint8_t)((id&(((uint64_t)(4 -1)) << 61)) >> 61);
}
# 47 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2
# 99 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct window_S win_T;
typedef struct wininfo_S wininfo_T;
typedef struct frame_S frame_T;
typedef uint64_t disptick_T;


# 1 "/home/jesmith/neovim/src/nvim/memline_defs.h" 1



# 1 "/home/jesmith/neovim/src/nvim/memfile_defs.h" 1
# 16 "/home/jesmith/neovim/src/nvim/memfile_defs.h"
typedef int64_t blocknr_T;
# 25 "/home/jesmith/neovim/src/nvim/memfile_defs.h"
typedef struct mf_hashitem {
  struct mf_hashitem *mhi_next;
  struct mf_hashitem *mhi_prev;
  blocknr_T mhi_key;
} mf_hashitem_T;
# 40 "/home/jesmith/neovim/src/nvim/memfile_defs.h"
typedef struct mf_hashtab {
  size_t mht_mask;

  size_t mht_count;
  mf_hashitem_T **mht_buckets;


  mf_hashitem_T *mht_small_buckets[64];
} mf_hashtab_T;
# 63 "/home/jesmith/neovim/src/nvim/memfile_defs.h"
typedef struct bhdr {
  mf_hashitem_T bh_hashitem;


  struct bhdr *bh_next;
  struct bhdr *bh_prev;
  void *bh_data;
  unsigned bh_page_count;



  unsigned bh_flags;
} bhdr_T;







typedef struct mf_blocknr_trans_item {
  mf_hashitem_T nt_hashitem;

  blocknr_T nt_new_bnum;
} mf_blocknr_trans_item_T;


typedef struct memfile {
  char_u *mf_fname;
  char_u *mf_ffname;
  int mf_fd;
  bhdr_T *mf_free_first;
  bhdr_T *mf_used_first;
  bhdr_T *mf_used_last;
  mf_hashtab_T mf_hash;
  mf_hashtab_T mf_trans;
  blocknr_T mf_blocknr_max;
  blocknr_T mf_blocknr_min;
  blocknr_T mf_neg_count;
  blocknr_T mf_infile_count;
  unsigned mf_page_size;
  
# 104 "/home/jesmith/neovim/src/nvim/memfile_defs.h" 3 4
 _Bool 
# 104 "/home/jesmith/neovim/src/nvim/memfile_defs.h"
      mf_dirty;
} memfile_T;
# 5 "/home/jesmith/neovim/src/nvim/memline_defs.h" 2






typedef struct info_pointer {
  blocknr_T ip_bnum;
  linenr_T ip_low;
  linenr_T ip_high;
  int ip_index;
} infoptr_T;

typedef struct ml_chunksize {
  int mlcs_numlines;
  long mlcs_totalsize;
} chunksize_T;
# 43 "/home/jesmith/neovim/src/nvim/memline_defs.h"
typedef struct memline {
  linenr_T ml_line_count;

  memfile_T *ml_mfp;

  infoptr_T *ml_stack;
  int ml_stack_top;
  int ml_stack_size;





  int ml_flags;

  linenr_T ml_line_lnum;
  char_u *ml_line_ptr;
  size_t ml_line_offset;
  int ml_line_offset_ff;

  bhdr_T *ml_locked;
  linenr_T ml_locked_low;
  linenr_T ml_locked_high;
  int ml_locked_lineadd;
  chunksize_T *ml_chunksize;
  int ml_numchunks;
  int ml_usedchunks;
} memline_T;
# 106 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2




# 1 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 1
# 45 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
typedef struct regengine regengine_T;
typedef struct regprog regprog_T;
typedef struct reg_extmatch reg_extmatch_T;







typedef struct {
  regprog_T *regprog;
  lpos_T startpos[10];
  lpos_T endpos[10];
  int rmm_ic;
  colnr_T rmm_maxcol;
} regmmatch_T;
# 70 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
struct regprog {
  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;
  
# 75 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 3 4
 _Bool 
# 75 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
      re_in_use;
};






typedef struct {

  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;
  
# 89 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 3 4
 _Bool 
# 89 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
      re_in_use;

  int regstart;
  char_u reganch;
  char_u *regmust;
  int regmlen;
  char_u reghasz;
  char_u program[1];
} bt_regprog_T;



typedef struct nfa_state nfa_state_T;
struct nfa_state {
  int c;
  nfa_state_T *out;
  nfa_state_T *out1;
  int id;
  int lastlist[2];
  int val;
};




typedef struct {

  regengine_T *engine;
  unsigned regflags;
  unsigned re_engine;
  unsigned re_flags;
  
# 120 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 3 4
 _Bool 
# 120 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
      re_in_use;

  nfa_state_T *start;

  int reganch;
  int regstart;
  char_u *match_text;

  int has_zend;
  int has_backref;
  int reghasz;
  char_u *pattern;
  int nsubexp;
  int nstate;
  nfa_state_T state[1];
} nfa_regprog_T;






typedef struct {
  regprog_T *regprog;
  char_u *startp[10];
  char_u *endp[10];
  
# 146 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 3 4
 _Bool 
# 146 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
      rm_ic;
} regmatch_T;






struct reg_extmatch {
  int16_t refcnt;
  char_u *matches[10];
};

struct regengine {
  regprog_T *(*regcomp)(char_u *, int);
  void (*regfree)(regprog_T *);
  int (*regexec_nl)(regmatch_T *, char_u *, colnr_T, 
# 162 "/home/jesmith/neovim/src/nvim/regexp_defs.h" 3 4
                                                    _Bool
# 162 "/home/jesmith/neovim/src/nvim/regexp_defs.h"
                                                        );
  long (*regexec_multi)(regmmatch_T *, win_T *, buf_T *, linenr_T, colnr_T,
                        proftime_T *, int *);
  char_u *expr;
};
# 111 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/jesmith/neovim/src/nvim/syntax_defs.h" 1
# 12 "/home/jesmith/neovim/src/nvim/syntax_defs.h"
typedef struct syn_state synstate_T;





struct sp_syn {
  int inc_tag;
  int16_t id;
  int16_t *cont_in_list;
};




typedef struct keyentry keyentry_T;

struct keyentry {
  keyentry_T *ke_next;
  struct sp_syn k_syn;
  int16_t *next_list;
  int flags;
  int k_char;
  char_u keyword[1];
};




typedef struct buf_state {
  int bs_idx;
  int bs_flags;
  int bs_seqnr;
  int bs_cchar;
  reg_extmatch_T *bs_extmatch;
} bufstate_T;





struct syn_state {
  synstate_T *sst_next;
  linenr_T sst_lnum;
  union {
    bufstate_T sst_stack[7];
    garray_T sst_ga;
  } sst_union;
  int sst_next_flags;
  int sst_stacksize;
  int16_t *sst_next_list;

  disptick_T sst_tick;
  linenr_T sst_change_lnum;

};
# 113 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2

# 1 "/home/jesmith/neovim/src/nvim/os/fs_defs.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/uv.h" 1
# 52 "/home/jesmith/neovim/.deps/usr/include/uv.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/uv/errno.h" 1
# 53 "/home/jesmith/neovim/.deps/usr/include/uv.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/uv/version.h" 1
# 54 "/home/jesmith/neovim/.deps/usr/include/uv.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 55 "/home/jesmith/neovim/.deps/usr/include/uv.h" 2
# 66 "/home/jesmith/neovim/.deps/usr/include/uv.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 1
# 27 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h"
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4

# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;

    __off_t l_start;
    __off_t l_len;




    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 353 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 354 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 392 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 447 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 61 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 148 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 157 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 168 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 178 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 192 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 203 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 214 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 260 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 272 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 282 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 293 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);







# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h" 3 4
extern int __open_2 (const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open_alias (const char *__path, int __oflag, ...) __asm__ ("" "open")
               __attribute__ ((__nonnull__ (1)));






extern void __open_too_many_args (void) __attribute__((__error__ ("open can be called either with 2 or 3 arguments, not more")))
                                                                  ;
extern void __open_missing_mode (void) __attribute__((__error__ ("open with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 0200000)) == (020000000 | 0200000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open_missing_mode ();
   return __open_2 (__path, __oflag);
 }
      return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (__path, __oflag);

  return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
}



extern int __open64_2 (const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open64_alias (const char *__path, int __oflag, ...) __asm__ ("" "open64")
                   __attribute__ ((__nonnull__ (1)));
extern void __open64_too_many_args (void) __attribute__((__error__ ("open64 can be called either with 2 or 3 arguments, not more")))
                                                                    ;
extern void __open64_missing_mode (void) __attribute__((__error__ ("open64 with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open64 (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 0200000)) == (020000000 | 0200000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open64_missing_mode ();
   return __open64_2 (__path, __oflag);
 }
      return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open64_2 (__path, __oflag);

  return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
}





extern int __openat_2 (int __fd, const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat")

     __attribute__ ((__nonnull__ (2)));
# 111 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h" 3 4
extern void __openat_too_many_args (void) __attribute__((__error__ ("openat can be called either with 3 or 4 arguments, not more")))
                                                                    ;
extern void __openat_missing_mode (void) __attribute__((__error__ ("openat with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                             ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 0200000)) == (020000000 | 0200000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat_missing_mode ();
   return __openat_2 (__fd, __path, __oflag);
 }
      return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat_2 (__fd, __path, __oflag);

  return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}



extern int __openat64_2 (int __fd, const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat64_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));
extern void __openat64_too_many_args (void) __attribute__((__error__ ("openat64 can be called either with 3 or 4 arguments, not more")))
                                                                      ;
extern void __openat64_missing_mode (void) __attribute__((__error__ ("openat64 with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                               ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat64 (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 0200000)) == (020000000 | 0200000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat64_missing_mode ();
   return __openat64_2 (__fd, __path, __oflag);
 }
      return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat64_2 (__fd, __path, __oflag);

  return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}
# 302 "/usr/include/fcntl.h" 2 3 4



# 28 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/dirent.h" 1 3 4
# 27 "/usr/include/dirent.h" 3 4

# 61 "/usr/include/dirent.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h" 3 4
struct dirent
  {

    __ino_t d_ino;
    __off_t d_off;




    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };


struct dirent64
  {
    __ino64_t d_ino;
    __off64_t d_off;
    unsigned short int d_reclen;
    unsigned char d_type;
    char d_name[256];
  };
# 62 "/usr/include/dirent.h" 2 3 4
# 97 "/usr/include/dirent.h" 3 4
enum
  {
    DT_UNKNOWN = 0,

    DT_FIFO = 1,

    DT_CHR = 2,

    DT_DIR = 4,

    DT_BLK = 6,

    DT_REG = 8,

    DT_LNK = 10,

    DT_SOCK = 12,

    DT_WHT = 14

  };
# 127 "/usr/include/dirent.h" 3 4
typedef struct __dirstream DIR;






extern DIR *opendir (const char *__name) __attribute__ ((__nonnull__ (1)));






extern DIR *fdopendir (int __fd);







extern int closedir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 162 "/usr/include/dirent.h" 3 4
extern struct dirent *readdir (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 173 "/usr/include/dirent.h" 3 4
extern struct dirent64 *readdir64 (DIR *__dirp) __attribute__ ((__nonnull__ (1)));
# 183 "/usr/include/dirent.h" 3 4
extern int readdir_r (DIR *__restrict __dirp,
        struct dirent *__restrict __entry,
        struct dirent **__restrict __result)
     __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));
# 201 "/usr/include/dirent.h" 3 4
extern int readdir64_r (DIR *__restrict __dirp,
   struct dirent64 *__restrict __entry,
   struct dirent64 **__restrict __result)
  __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__deprecated__));




extern void rewinddir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void seekdir (DIR *__dirp, long int __pos) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int telldir (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int dirfd (DIR *__dirp) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/dirent.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 246 "/usr/include/dirent.h" 2 3 4
# 255 "/usr/include/dirent.h" 3 4
extern int scandir (const char *__restrict __dir,
      struct dirent ***__restrict __namelist,
      int (*__selector) (const struct dirent *),
      int (*__cmp) (const struct dirent **,
      const struct dirent **))
     __attribute__ ((__nonnull__ (1, 2)));
# 278 "/usr/include/dirent.h" 3 4
extern int scandir64 (const char *__restrict __dir,
        struct dirent64 ***__restrict __namelist,
        int (*__selector) (const struct dirent64 *),
        int (*__cmp) (const struct dirent64 **,
        const struct dirent64 **))
     __attribute__ ((__nonnull__ (1, 2)));
# 293 "/usr/include/dirent.h" 3 4
extern int scandirat (int __dfd, const char *__restrict __dir,
        struct dirent ***__restrict __namelist,
        int (*__selector) (const struct dirent *),
        int (*__cmp) (const struct dirent **,
        const struct dirent **))
     __attribute__ ((__nonnull__ (2, 3)));
# 315 "/usr/include/dirent.h" 3 4
extern int scandirat64 (int __dfd, const char *__restrict __dir,
   struct dirent64 ***__restrict __namelist,
   int (*__selector) (const struct dirent64 *),
   int (*__cmp) (const struct dirent64 **,
          const struct dirent64 **))
     __attribute__ ((__nonnull__ (2, 3)));




extern int alphasort (const struct dirent **__e1,
        const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/dirent.h" 3 4
extern int alphasort64 (const struct dirent64 **__e1,
   const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 353 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries (int __fd, char *__restrict __buf,
    size_t __nbytes,
    __off_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));
# 370 "/usr/include/dirent.h" 3 4
extern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,
      size_t __nbytes,
      __off64_t *__restrict __basep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));






extern int versionsort (const struct dirent **__e1,
   const struct dirent **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 396 "/usr/include/dirent.h" 3 4
extern int versionsort64 (const struct dirent64 **__e1,
     const struct dirent64 **__e2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





# 1 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/dirent_ext.h" 3 4






extern __ssize_t getdents64 (int __fd, void *__buffer, size_t __length)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 405 "/usr/include/dirent.h" 2 3 4
# 29 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/socket.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 175 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 176 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 191 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_BATCH = 0x40000,

    MSG_ZEROCOPY = 0x4000000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 305 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__nothrow__ , __leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};




# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4





# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 7 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 355 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4






struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 34 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h" 1 3 4





struct osockaddr
{
  unsigned short int sa_family;
  unsigned char sa_data[14];
};
# 37 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 79 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));





struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 126 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);



extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);
# 163 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 232 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 250 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/socket2.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h" 3 4
extern ssize_t __recv_chk (int __fd, void *__buf, size_t __n, size_t __buflen,
      int __flags);
extern ssize_t __recv_alias (int __fd, void *__buf, size_t __n, int __flags) __asm__ ("" "recv")
                          ;
extern ssize_t __recv_chk_warn (int __fd, void *__buf, size_t __n, size_t __buflen, int __flags) __asm__ ("" "__recv_chk")


     __attribute__((__warning__ ("recv called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) ssize_t
recv (int __fd, void *__buf, size_t __n, int __flags)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __recv_chk (__fd, __buf, __n, __builtin_object_size (__buf, 0), __flags);

      if (__n > __builtin_object_size (__buf, 0))
 return __recv_chk_warn (__fd, __buf, __n, __builtin_object_size (__buf, 0), __flags);
    }
  return __recv_alias (__fd, __buf, __n, __flags);
}

extern ssize_t __recvfrom_chk (int __fd, void *__restrict __buf, size_t __n,
          size_t __buflen, int __flags,
          __SOCKADDR_ARG __addr,
          socklen_t *__restrict __addr_len);
extern ssize_t __recvfrom_alias (int __fd, void *__restrict __buf, size_t __n, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) __asm__ ("" "recvfrom")


                                                   ;
extern ssize_t __recvfrom_chk_warn (int __fd, void *__restrict __buf, size_t __n, size_t __buflen, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) __asm__ ("" "__recvfrom_chk")




     __attribute__((__warning__ ("recvfrom called with bigger length than size of " "destination buffer")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) ssize_t
recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
   __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len)
{
  if (__builtin_object_size (__buf, 0) != (size_t) -1)
    {
      if (!__builtin_constant_p (__n))
 return __recvfrom_chk (__fd, __buf, __n, __builtin_object_size (__buf, 0), __flags,
          __addr, __addr_len);
      if (__n > __builtin_object_size (__buf, 0))
 return __recvfrom_chk_warn (__fd, __buf, __n, __builtin_object_size (__buf, 0), __flags,
        __addr, __addr_len);
    }
  return __recvfrom_alias (__fd, __buf, __n, __flags, __addr, __addr_len);
}
# 270 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4



# 31 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
# 27 "/usr/include/netinet/in.h" 3 4



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/in.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_MPLS = 137,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 212 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];
 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];
      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 238 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr)
      - (sizeof (unsigned short int))
      - sizeof (in_port_t)
      - sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 375 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 387 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 388 "/usr/include/netinet/in.h" 2 3 4
# 503 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 533 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));



extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 32 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netinet/tcp.h" 1 3 4
# 93 "/usr/include/netinet/tcp.h" 3 4
typedef uint32_t tcp_seq;




struct tcphdr
  {
    __extension__ union
    {
      struct
      {
 uint16_t th_sport;
 uint16_t th_dport;
 tcp_seq th_seq;
 tcp_seq th_ack;

 uint8_t th_x2:4;
 uint8_t th_off:4;





 uint8_t th_flags;






 uint16_t th_win;
 uint16_t th_sum;
 uint16_t th_urp;
      };
      struct
      {
 uint16_t source;
 uint16_t dest;
 uint32_t seq;
 uint32_t ack_seq;

 uint16_t res1:4;
 uint16_t doff:4;
 uint16_t fin:1;
 uint16_t syn:1;
 uint16_t rst:1;
 uint16_t psh:1;
 uint16_t ack:1;
 uint16_t urg:1;
 uint16_t res2:2;
# 156 "/usr/include/netinet/tcp.h" 3 4
 uint16_t window;
 uint16_t check;
 uint16_t urg_ptr;
      };
    };
};

enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING
};
# 217 "/usr/include/netinet/tcp.h" 3 4
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  uint8_t tcpi_state;
  uint8_t tcpi_ca_state;
  uint8_t tcpi_retransmits;
  uint8_t tcpi_probes;
  uint8_t tcpi_backoff;
  uint8_t tcpi_options;
  uint8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  uint32_t tcpi_rto;
  uint32_t tcpi_ato;
  uint32_t tcpi_snd_mss;
  uint32_t tcpi_rcv_mss;

  uint32_t tcpi_unacked;
  uint32_t tcpi_sacked;
  uint32_t tcpi_lost;
  uint32_t tcpi_retrans;
  uint32_t tcpi_fackets;


  uint32_t tcpi_last_data_sent;
  uint32_t tcpi_last_ack_sent;
  uint32_t tcpi_last_data_recv;
  uint32_t tcpi_last_ack_recv;


  uint32_t tcpi_pmtu;
  uint32_t tcpi_rcv_ssthresh;
  uint32_t tcpi_rtt;
  uint32_t tcpi_rttvar;
  uint32_t tcpi_snd_ssthresh;
  uint32_t tcpi_snd_cwnd;
  uint32_t tcpi_advmss;
  uint32_t tcpi_reordering;

  uint32_t tcpi_rcv_rtt;
  uint32_t tcpi_rcv_space;

  uint32_t tcpi_total_retrans;
};
# 276 "/usr/include/netinet/tcp.h" 3 4
struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr;
  uint8_t tcpm_flags;
  uint8_t tcpm_prefixlen;
  uint16_t tcpm_keylen;
  uint32_t __tcpm_pad;
  uint8_t tcpm_key[80];
};


struct tcp_repair_opt
{
  uint32_t opt_code;
  uint32_t opt_val;
};


enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};
# 319 "/usr/include/netinet/tcp.h" 3 4
struct tcp_cookie_transactions
{
  uint16_t tcpct_flags;
  uint8_t __tcpct_pad1;
  uint8_t tcpct_cookie_desired;
  uint16_t tcpct_s_data_desired;
  uint16_t tcpct_used;
  uint8_t tcpct_value[536U];
};


struct tcp_repair_window
{
  uint32_t snd_wl1;
  uint32_t snd_wnd;
  uint32_t max_window;
  uint32_t rcv_wnd;
  uint32_t rcv_wup;
};


struct tcp_zerocopy_receive
{
  uint64_t address;
  uint32_t length;
  uint32_t recv_skip_hint;
};
# 33 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 30 "/usr/include/arpa/inet.h" 3 4




extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 34 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/netdb.h" 1 3 4
# 32 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ , __leaf__));
extern void endrpcent (void) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ , __leaf__));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ , __leaf__));



# 33 "/usr/include/netdb.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 41 "/usr/include/netdb.h" 2 3 4
# 51 "/usr/include/netdb.h" 3 4








extern int *__h_errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 90 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) __attribute__ ((__nothrow__ , __leaf__));


extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ , __leaf__));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 153 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 165 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 196 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 235 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 306 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 372 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 393 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 410 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 421 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 449 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 461 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 477 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 489 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 503 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 513 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 526 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 537 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 549 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 558 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __glibc_reserved[5];
};
# 660 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ , __leaf__));


extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ , __leaf__));





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 690 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[__restrict],
     int __ent, struct sigevent *__restrict __sig);
# 701 "/usr/include/netdb.h" 3 4
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) __attribute__ ((__nothrow__ , __leaf__));


extern int gai_cancel (struct gaicb *__gaicbp) __attribute__ ((__nothrow__ , __leaf__));



# 35 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2

# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/termios.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

# 1 "/usr/include/x86_64-linux-gnu/bits/termios-struct.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/termios-struct.h" 3 4
struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 28 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-c_cc.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-c_iflag.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-c_oflag.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/termios.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-baud.h" 1 3 4
# 54 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/termios-c_cflag.h" 1 3 4
# 56 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-c_lflag.h" 1 3 4
# 57 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 74 "/usr/include/x86_64-linux-gnu/bits/termios.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/termios-tcflow.h" 1 3 4
# 75 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/termios-misc.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/termios.h" 2 3 4
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4



# 37 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 1 "/usr/include/pwd.h" 1 3 4
# 27 "/usr/include/pwd.h" 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 33 "/usr/include/pwd.h" 2 3 4
# 49 "/usr/include/pwd.h" 3 4
struct passwd
{
  char *pw_name;
  char *pw_passwd;

  __uid_t pw_uid;
  __gid_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};
# 72 "/usr/include/pwd.h" 3 4
extern void setpwent (void);





extern void endpwent (void);





extern struct passwd *getpwent (void);
# 94 "/usr/include/pwd.h" 3 4
extern struct passwd *fgetpwent (FILE *__stream) __attribute__ ((__nonnull__ (1)));







extern int putpwent (const struct passwd *__restrict __p,
       FILE *__restrict __f);






extern struct passwd *getpwuid (__uid_t __uid);





extern struct passwd *getpwnam (const char *__name) __attribute__ ((__nonnull__ (1)));
# 139 "/usr/include/pwd.h" 3 4
extern int getpwent_r (struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 4)));


extern int getpwuid_r (__uid_t __uid,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (2, 3, 5)));

extern int getpwnam_r (const char *__restrict __name,
         struct passwd *__restrict __resultbuf,
         char *__restrict __buffer, size_t __buflen,
         struct passwd **__restrict __result)
         __attribute__ ((__nonnull__ (1, 2, 3, 5)));
# 166 "/usr/include/pwd.h" 3 4
extern int fgetpwent_r (FILE *__restrict __stream,
   struct passwd *__restrict __resultbuf,
   char *__restrict __buffer, size_t __buflen,
   struct passwd **__restrict __result)
   __attribute__ ((__nonnull__ (1, 2, 3, 5)));
# 184 "/usr/include/pwd.h" 3 4
extern int getpw (__uid_t __uid, char *__buffer);



# 38 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/usr/include/semaphore.h" 1 3 4
# 28 "/usr/include/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h" 3 4
typedef union
{
  char __size[32];
  long int __align;
} sem_t;
# 29 "/usr/include/semaphore.h" 2 3 4






extern int sem_init (sem_t *__sem, int __pshared, unsigned int __value)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_destroy (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern sem_t *sem_open (const char *__name, int __oflag, ...)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_close (sem_t *__sem) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sem_unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int sem_wait (sem_t *__sem) __attribute__ ((__nonnull__ (1)));






extern int sem_timedwait (sem_t *__restrict __sem,
     const struct timespec *__restrict __abstime)
  __attribute__ ((__nonnull__ (1, 2)));



extern int sem_clockwait (sem_t *__restrict __sem,
     clockid_t clock,
     const struct timespec *__restrict __abstime)
  __attribute__ ((__nonnull__ (1, 3)));



extern int sem_trywait (sem_t *__sem) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sem_post (sem_t *__sem) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int sem_getvalue (sem_t *__restrict __sem, int *__restrict __sval)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



# 41 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getcpu (unsigned int *, unsigned int *) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));



# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 45 "/usr/include/sched.h" 2 3 4









extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 23 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4




enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 100 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 120 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 155 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 193 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 238 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));







extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 470 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 482 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 516 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 656 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 668 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 691 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;
# 704 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 789 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 997 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1010 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));





extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1056 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1123 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1157 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
{
  return __thread1 == __thread2;
}



# 44 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/uv/threadpool.h" 1
# 30 "/home/jesmith/neovim/.deps/usr/include/uv/threadpool.h"

# 30 "/home/jesmith/neovim/.deps/usr/include/uv/threadpool.h"
struct uv__work {
  void (*work)(struct uv__work *w);
  void (*done)(struct uv__work *w, int status);
  struct uv_loop_s* loop;
  void* wq[2];
};
# 47 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/uv/linux.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h" 2
# 88 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h"
struct uv__io_s;
struct uv_loop_s;

typedef void (*uv__io_cb)(struct uv_loop_s* loop,
                          struct uv__io_s* w,
                          unsigned int events);
typedef struct uv__io_s uv__io_t;

struct uv__io_s {
  uv__io_cb cb;
  void* pending_queue[2];
  void* watcher_queue[2];
  unsigned int pevents;
  unsigned int events;
  int fd;
 
};
# 123 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h"
typedef struct uv_buf_t {
  char* base;
  size_t len;
} uv_buf_t;

typedef int uv_file;
typedef int uv_os_sock_t;
typedef int uv_os_fd_t;
typedef pid_t uv_pid_t;



typedef pthread_once_t uv_once_t;
typedef pthread_t uv_thread_t;
typedef pthread_mutex_t uv_mutex_t;
typedef pthread_rwlock_t uv_rwlock_t;
typedef sem_t uv_sem_t;
typedef pthread_cond_t uv_cond_t;
typedef pthread_key_t uv_key_t;
# 164 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h"
typedef pthread_barrier_t uv_barrier_t;



typedef gid_t uv_gid_t;
typedef uid_t uv_uid_t;

typedef struct dirent uv__dirent_t;
# 218 "/home/jesmith/neovim/.deps/usr/include/uv/unix.h"
typedef struct {
  void* handle;
  char* errmsg;
} uv_lib_t;
# 67 "/home/jesmith/neovim/.deps/usr/include/uv.h" 2
# 184 "/home/jesmith/neovim/.deps/usr/include/uv.h"
typedef enum {

  UV_E2BIG = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 7
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EACCES = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 13
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EADDRINUSE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 98
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EADDRNOTAVAIL = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 99
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EAFNOSUPPORT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 97
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EAGAIN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 11
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EAI_ADDRFAMILY = (-3000), UV_EAI_AGAIN = (-3001), UV_EAI_BADFLAGS = (-3002), UV_EAI_BADHINTS = (-3013), UV_EAI_CANCELED = (-3003), UV_EAI_FAIL = (-3004), UV_EAI_FAMILY = (-3005), UV_EAI_MEMORY = (-3006), UV_EAI_NODATA = (-3007), UV_EAI_NONAME = (-3008), UV_EAI_OVERFLOW = (-3009), UV_EAI_PROTOCOL = (-3014), UV_EAI_SERVICE = (-3010), UV_EAI_SOCKTYPE = (-3011), UV_EALREADY = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 114
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EBADF = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 9
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EBUSY = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 16
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ECANCELED = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 125
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ECHARSET = (-4080), UV_ECONNABORTED = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 103
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ECONNREFUSED = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 111
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ECONNRESET = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 104
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EDESTADDRREQ = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 89
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EEXIST = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 17
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EFAULT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 14
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EFBIG = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 27
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EHOSTUNREACH = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 113
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EINTR = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 4
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EINVAL = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 22
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EIO = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 5
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EISCONN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 106
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EISDIR = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 21
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ELOOP = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 40
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EMFILE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 24
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EMSGSIZE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 90
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENAMETOOLONG = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 36
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENETDOWN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 100
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENETUNREACH = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 101
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENFILE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 23
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOBUFS = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 105
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENODEV = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 19
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOENT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 2
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOMEM = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 12
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENONET = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 64
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOPROTOOPT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 92
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOSPC = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 28
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOSYS = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 38
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTCONN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 107
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTDIR = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 20
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTEMPTY = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 39
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTSOCK = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 88
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTSUP = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 95
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EOVERFLOW = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 75
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EPERM = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 1
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EPIPE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 32
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTO = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 71
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTONOSUPPORT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 93
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EPROTOTYPE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 91
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ERANGE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 34
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EROFS = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 30
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ESHUTDOWN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 108
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ESPIPE = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 29
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ESRCH = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 3
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ETIMEDOUT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 110
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ETXTBSY = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 26
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EXDEV = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 18
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_UNKNOWN = (-4094), UV_EOF = (-4095), UV_ENXIO = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 6
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EMLINK = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 31
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EHOSTDOWN = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 112
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EREMOTEIO = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 121
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ENOTTY = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 25
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_EFTYPE = (-4028), UV_EILSEQ = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 84
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )), UV_ESOCKTNOSUPPORT = (-(
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 94
# 186 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 )),

  UV_ERRNO_MAX = (-4095) - 1
} uv_errno_t;

typedef enum {
  UV_UNKNOWN_HANDLE = 0,

  UV_ASYNC, UV_CHECK, UV_FS_EVENT, UV_FS_POLL, UV_HANDLE, UV_IDLE, UV_NAMED_PIPE, UV_POLL, UV_PREPARE, UV_PROCESS, UV_STREAM, UV_TCP, UV_TIMER, UV_TTY, UV_UDP, UV_SIGNAL,

  UV_FILE,
  UV_HANDLE_TYPE_MAX
} uv_handle_type;

typedef enum {
  UV_UNKNOWN_REQ = 0,

  UV_REQ, UV_CONNECT, UV_WRITE, UV_SHUTDOWN, UV_UDP_SEND, UV_FS, UV_WORK, UV_GETADDRINFO, UV_GETNAMEINFO, UV_RANDOM,

 
  UV_REQ_TYPE_MAX
} uv_req_type;



typedef struct uv_loop_s uv_loop_t;
typedef struct uv_handle_s uv_handle_t;
typedef struct uv_dir_s uv_dir_t;
typedef struct uv_stream_s uv_stream_t;
typedef struct uv_tcp_s uv_tcp_t;
typedef struct uv_udp_s uv_udp_t;
typedef struct uv_pipe_s uv_pipe_t;
typedef struct uv_tty_s uv_tty_t;
typedef struct uv_poll_s uv_poll_t;
typedef struct uv_timer_s uv_timer_t;
typedef struct uv_prepare_s uv_prepare_t;
typedef struct uv_check_s uv_check_t;
typedef struct uv_idle_s uv_idle_t;
typedef struct uv_async_s uv_async_t;
typedef struct uv_process_s uv_process_t;
typedef struct uv_fs_event_s uv_fs_event_t;
typedef struct uv_fs_poll_s uv_fs_poll_t;
typedef struct uv_signal_s uv_signal_t;


typedef struct uv_req_s uv_req_t;
typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;
typedef struct uv_getnameinfo_s uv_getnameinfo_t;
typedef struct uv_shutdown_s uv_shutdown_t;
typedef struct uv_write_s uv_write_t;
typedef struct uv_connect_s uv_connect_t;
typedef struct uv_udp_send_s uv_udp_send_t;
typedef struct uv_fs_s uv_fs_t;
typedef struct uv_work_s uv_work_t;
typedef struct uv_random_s uv_random_t;


typedef struct uv_env_item_s uv_env_item_t;
typedef struct uv_cpu_info_s uv_cpu_info_t;
typedef struct uv_interface_address_s uv_interface_address_t;
typedef struct uv_dirent_s uv_dirent_t;
typedef struct uv_passwd_s uv_passwd_t;
typedef struct uv_utsname_s uv_utsname_t;
typedef struct uv_statfs_s uv_statfs_t;

typedef enum {
  UV_LOOP_BLOCK_SIGNAL = 0,
  UV_METRICS_IDLE_TIME
} uv_loop_option;

typedef enum {
  UV_RUN_DEFAULT = 0,
  UV_RUN_ONCE,
  UV_RUN_NOWAIT
} uv_run_mode;


__attribute__((visibility("default"))) unsigned int uv_version(void);
__attribute__((visibility("default"))) const char* uv_version_string(void);

typedef void* (*uv_malloc_func)(size_t size);
typedef void* (*uv_realloc_func)(void* ptr, size_t size);
typedef void* (*uv_calloc_func)(size_t count, size_t size);
typedef void (*uv_free_func)(void* ptr);

__attribute__((visibility("default"))) void uv_library_shutdown(void);

__attribute__((visibility("default"))) int uv_replace_allocator(uv_malloc_func malloc_func,
                                   uv_realloc_func realloc_func,
                                   uv_calloc_func calloc_func,
                                   uv_free_func free_func);

__attribute__((visibility("default"))) uv_loop_t* uv_default_loop(void);
__attribute__((visibility("default"))) int uv_loop_init(uv_loop_t* loop);
__attribute__((visibility("default"))) int uv_loop_close(uv_loop_t* loop);





__attribute__((visibility("default"))) uv_loop_t* uv_loop_new(void);





__attribute__((visibility("default"))) void uv_loop_delete(uv_loop_t*);
__attribute__((visibility("default"))) size_t uv_loop_size(void);
__attribute__((visibility("default"))) int uv_loop_alive(const uv_loop_t* loop);
__attribute__((visibility("default"))) int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);
__attribute__((visibility("default"))) int uv_loop_fork(uv_loop_t* loop);

__attribute__((visibility("default"))) int uv_run(uv_loop_t*, uv_run_mode mode);
__attribute__((visibility("default"))) void uv_stop(uv_loop_t*);

__attribute__((visibility("default"))) void uv_ref(uv_handle_t*);
__attribute__((visibility("default"))) void uv_unref(uv_handle_t*);
__attribute__((visibility("default"))) int uv_has_ref(const uv_handle_t*);

__attribute__((visibility("default"))) void uv_update_time(uv_loop_t*);
__attribute__((visibility("default"))) uint64_t uv_now(const uv_loop_t*);

__attribute__((visibility("default"))) int uv_backend_fd(const uv_loop_t*);
__attribute__((visibility("default"))) int uv_backend_timeout(const uv_loop_t*);

typedef void (*uv_alloc_cb)(uv_handle_t* handle,
                            size_t suggested_size,
                            uv_buf_t* buf);
typedef void (*uv_read_cb)(uv_stream_t* stream,
                           ssize_t nread,
                           const uv_buf_t* buf);
typedef void (*uv_write_cb)(uv_write_t* req, int status);
typedef void (*uv_connect_cb)(uv_connect_t* req, int status);
typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);
typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
typedef void (*uv_close_cb)(uv_handle_t* handle);
typedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);
typedef void (*uv_timer_cb)(uv_timer_t* handle);
typedef void (*uv_async_cb)(uv_async_t* handle);
typedef void (*uv_prepare_cb)(uv_prepare_t* handle);
typedef void (*uv_check_cb)(uv_check_t* handle);
typedef void (*uv_idle_cb)(uv_idle_t* handle);
typedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);
typedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);
typedef void (*uv_fs_cb)(uv_fs_t* req);
typedef void (*uv_work_cb)(uv_work_t* req);
typedef void (*uv_after_work_cb)(uv_work_t* req, int status);
typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,
                                  int status,
                                  struct addrinfo* res);
typedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,
                                  int status,
                                  const char* hostname,
                                  const char* service);
typedef void (*uv_random_cb)(uv_random_t* req,
                             int status,
                             void* buf,
                             size_t buflen);

typedef struct {
  long tv_sec;
  long tv_nsec;
} uv_timespec_t;


typedef struct {
  uint64_t st_dev;
  uint64_t st_mode;
  uint64_t st_nlink;
  uint64_t st_uid;
  uint64_t st_gid;
  uint64_t st_rdev;
  uint64_t st_ino;
  uint64_t st_size;
  uint64_t st_blksize;
  uint64_t st_blocks;
  uint64_t st_flags;
  uint64_t st_gen;
  uv_timespec_t st_atim;
  uv_timespec_t st_mtim;
  uv_timespec_t st_ctim;
  uv_timespec_t st_birthtim;
} uv_stat_t;


typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,
                               const char* filename,
                               int events,
                               int status);

typedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,
                              int status,
                              const uv_stat_t* prev,
                              const uv_stat_t* curr);

typedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);


typedef enum {
  UV_LEAVE_GROUP = 0,
  UV_JOIN_GROUP
} uv_membership;


__attribute__((visibility("default"))) int uv_translate_sys_error(int sys_errno);

__attribute__((visibility("default"))) const char* uv_strerror(int err);
__attribute__((visibility("default"))) char* uv_strerror_r(int err, char* buf, size_t buflen);

__attribute__((visibility("default"))) const char* uv_err_name(int err);
__attribute__((visibility("default"))) char* uv_err_name_r(int err, char* buf, size_t buflen);
# 409 "/home/jesmith/neovim/.deps/usr/include/uv.h"
struct uv_req_s {
  void* data; uv_req_type type; void* reserved[6];
};






__attribute__((visibility("default"))) int uv_shutdown(uv_shutdown_t* req,
                          uv_stream_t* handle,
                          uv_shutdown_cb cb);

struct uv_shutdown_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_stream_t* handle;
  uv_shutdown_cb cb;
 
};
# 446 "/home/jesmith/neovim/.deps/usr/include/uv.h"
struct uv_handle_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
};

__attribute__((visibility("default"))) size_t uv_handle_size(uv_handle_type type);
__attribute__((visibility("default"))) uv_handle_type uv_handle_get_type(const uv_handle_t* handle);
__attribute__((visibility("default"))) const char* uv_handle_type_name(uv_handle_type type);
__attribute__((visibility("default"))) void* uv_handle_get_data(const uv_handle_t* handle);
__attribute__((visibility("default"))) uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);
__attribute__((visibility("default"))) void uv_handle_set_data(uv_handle_t* handle, void* data);

__attribute__((visibility("default"))) size_t uv_req_size(uv_req_type type);
__attribute__((visibility("default"))) void* uv_req_get_data(const uv_req_t* req);
__attribute__((visibility("default"))) void uv_req_set_data(uv_req_t* req, void* data);
__attribute__((visibility("default"))) uv_req_type uv_req_get_type(const uv_req_t* req);
__attribute__((visibility("default"))) const char* uv_req_type_name(uv_req_type type);

__attribute__((visibility("default"))) int uv_is_active(const uv_handle_t* handle);

__attribute__((visibility("default"))) void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);


__attribute__((visibility("default"))) void uv_print_all_handles(uv_loop_t* loop, FILE* stream);
__attribute__((visibility("default"))) void uv_print_active_handles(uv_loop_t* loop, FILE* stream);

__attribute__((visibility("default"))) void uv_close(uv_handle_t* handle, uv_close_cb close_cb);

__attribute__((visibility("default"))) int uv_send_buffer_size(uv_handle_t* handle, int* value);
__attribute__((visibility("default"))) int uv_recv_buffer_size(uv_handle_t* handle, int* value);

__attribute__((visibility("default"))) int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);

__attribute__((visibility("default"))) uv_buf_t uv_buf_init(char* base, unsigned int len);

__attribute__((visibility("default"))) int uv_pipe(uv_file fds[2], int read_flags, int write_flags);
__attribute__((visibility("default"))) int uv_socketpair(int type,
                            int protocol,
                            uv_os_sock_t socket_vector[2],
                            int flags0,
                            int flags1);
# 502 "/home/jesmith/neovim/.deps/usr/include/uv.h"
struct uv_stream_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
};

__attribute__((visibility("default"))) size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);

__attribute__((visibility("default"))) int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);
__attribute__((visibility("default"))) int uv_accept(uv_stream_t* server, uv_stream_t* client);

__attribute__((visibility("default"))) int uv_read_start(uv_stream_t*,
                            uv_alloc_cb alloc_cb,
                            uv_read_cb read_cb);
__attribute__((visibility("default"))) int uv_read_stop(uv_stream_t*);

__attribute__((visibility("default"))) int uv_write(uv_write_t* req,
                       uv_stream_t* handle,
                       const uv_buf_t bufs[],
                       unsigned int nbufs,
                       uv_write_cb cb);
__attribute__((visibility("default"))) int uv_write2(uv_write_t* req,
                        uv_stream_t* handle,
                        const uv_buf_t bufs[],
                        unsigned int nbufs,
                        uv_stream_t* send_handle,
                        uv_write_cb cb);
__attribute__((visibility("default"))) int uv_try_write(uv_stream_t* handle,
                           const uv_buf_t bufs[],
                           unsigned int nbufs);
__attribute__((visibility("default"))) int uv_try_write2(uv_stream_t* handle,
                            const uv_buf_t bufs[],
                            unsigned int nbufs,
                            uv_stream_t* send_handle);


struct uv_write_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_write_cb cb;
  uv_stream_t* send_handle;
  uv_stream_t* handle;
  void* queue[2]; unsigned int write_index; uv_buf_t* bufs; unsigned int nbufs; int error; uv_buf_t bufsml[4];
};


__attribute__((visibility("default"))) int uv_is_readable(const uv_stream_t* handle);
__attribute__((visibility("default"))) int uv_is_writable(const uv_stream_t* handle);

__attribute__((visibility("default"))) int uv_stream_set_blocking(uv_stream_t* handle, int blocking);

__attribute__((visibility("default"))) int uv_is_closing(const uv_handle_t* handle);







struct uv_tcp_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
 
};

__attribute__((visibility("default"))) int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);
__attribute__((visibility("default"))) int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);
__attribute__((visibility("default"))) int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);
__attribute__((visibility("default"))) int uv_tcp_nodelay(uv_tcp_t* handle, int enable);
__attribute__((visibility("default"))) int uv_tcp_keepalive(uv_tcp_t* handle,
                               int enable,
                               unsigned int delay);
__attribute__((visibility("default"))) int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);

enum uv_tcp_flags {

  UV_TCP_IPV6ONLY = 1
};

__attribute__((visibility("default"))) int uv_tcp_bind(uv_tcp_t* handle,
                          const struct sockaddr* addr,
                          unsigned int flags);
__attribute__((visibility("default"))) int uv_tcp_getsockname(const uv_tcp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_tcp_getpeername(const uv_tcp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb);
__attribute__((visibility("default"))) int uv_tcp_connect(uv_connect_t* req,
                             uv_tcp_t* handle,
                             const struct sockaddr* addr,
                             uv_connect_cb cb);


struct uv_connect_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_connect_cb cb;
  uv_stream_t* handle;
  void* queue[2];
};






enum uv_udp_flags {

  UV_UDP_IPV6ONLY = 1,




  UV_UDP_PARTIAL = 2,
# 623 "/home/jesmith/neovim/.deps/usr/include/uv.h"
  UV_UDP_REUSEADDR = 4,




  UV_UDP_MMSG_CHUNK = 8,





  UV_UDP_MMSG_FREE = 16,







  UV_UDP_LINUX_RECVERR = 32,



  UV_UDP_RECVMMSG = 256
};

typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);
typedef void (*uv_udp_recv_cb)(uv_udp_t* handle,
                               ssize_t nread,
                               const uv_buf_t* buf,
                               const struct sockaddr* addr,
                               unsigned flags);


struct uv_udp_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;





  size_t send_queue_size;



  size_t send_queue_count;
  uv_alloc_cb alloc_cb; uv_udp_recv_cb recv_cb; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2];
};


struct uv_udp_send_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_udp_t* handle;
  uv_udp_send_cb cb;
  void* queue[2]; struct sockaddr_storage addr; unsigned int nbufs; uv_buf_t* bufs; ssize_t status; uv_udp_send_cb send_cb; uv_buf_t bufsml[4];
};

__attribute__((visibility("default"))) int uv_udp_init(uv_loop_t*, uv_udp_t* handle);
__attribute__((visibility("default"))) int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);
__attribute__((visibility("default"))) int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);
__attribute__((visibility("default"))) int uv_udp_bind(uv_udp_t* handle,
                          const struct sockaddr* addr,
                          unsigned int flags);
__attribute__((visibility("default"))) int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr);

__attribute__((visibility("default"))) int uv_udp_getpeername(const uv_udp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_udp_getsockname(const uv_udp_t* handle,
                                 struct sockaddr* name,
                                 int* namelen);
__attribute__((visibility("default"))) int uv_udp_set_membership(uv_udp_t* handle,
                                    const char* multicast_addr,
                                    const char* interface_addr,
                                    uv_membership membership);
__attribute__((visibility("default"))) int uv_udp_set_source_membership(uv_udp_t* handle,
                                           const char* multicast_addr,
                                           const char* interface_addr,
                                           const char* source_addr,
                                           uv_membership membership);
__attribute__((visibility("default"))) int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);
__attribute__((visibility("default"))) int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);
__attribute__((visibility("default"))) int uv_udp_set_multicast_interface(uv_udp_t* handle,
                                             const char* interface_addr);
__attribute__((visibility("default"))) int uv_udp_set_broadcast(uv_udp_t* handle, int on);
__attribute__((visibility("default"))) int uv_udp_set_ttl(uv_udp_t* handle, int ttl);
__attribute__((visibility("default"))) int uv_udp_send(uv_udp_send_t* req,
                          uv_udp_t* handle,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          const struct sockaddr* addr,
                          uv_udp_send_cb send_cb);
__attribute__((visibility("default"))) int uv_udp_try_send(uv_udp_t* handle,
                              const uv_buf_t bufs[],
                              unsigned int nbufs,
                              const struct sockaddr* addr);
__attribute__((visibility("default"))) int uv_udp_recv_start(uv_udp_t* handle,
                                uv_alloc_cb alloc_cb,
                                uv_udp_recv_cb recv_cb);
__attribute__((visibility("default"))) int uv_udp_using_recvmmsg(const uv_udp_t* handle);
__attribute__((visibility("default"))) int uv_udp_recv_stop(uv_udp_t* handle);
__attribute__((visibility("default"))) size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);
__attribute__((visibility("default"))) size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);







struct uv_tty_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
  struct termios orig_termios; int mode;
};

typedef enum {

  UV_TTY_MODE_NORMAL,

  UV_TTY_MODE_RAW,

  UV_TTY_MODE_IO
} uv_tty_mode_t;

typedef enum {




  UV_TTY_SUPPORTED,



  UV_TTY_UNSUPPORTED
} uv_tty_vtermstate_t;


__attribute__((visibility("default"))) int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);
__attribute__((visibility("default"))) int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);
__attribute__((visibility("default"))) int uv_tty_reset_mode(void);
__attribute__((visibility("default"))) int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);
__attribute__((visibility("default"))) void uv_tty_set_vterm_state(uv_tty_vtermstate_t state);
__attribute__((visibility("default"))) int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state);
# 778 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) uv_handle_type uv_guess_handle(uv_file file);







struct uv_pipe_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  size_t write_queue_size; uv_alloc_cb alloc_cb; uv_read_cb read_cb; uv_connect_t *connect_req; uv_shutdown_t *shutdown_req; uv__io_t io_watcher; void* write_queue[2]; void* write_completed_queue[2]; uv_connection_cb connection_cb; int delayed_error; int accepted_fd; void* queued_fds;
  int ipc;
  const char* pipe_fname;
};

__attribute__((visibility("default"))) int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);
__attribute__((visibility("default"))) int uv_pipe_open(uv_pipe_t*, uv_file file);
__attribute__((visibility("default"))) int uv_pipe_bind(uv_pipe_t* handle, const char* name);
__attribute__((visibility("default"))) void uv_pipe_connect(uv_connect_t* req,
                               uv_pipe_t* handle,
                               const char* name,
                               uv_connect_cb cb);
__attribute__((visibility("default"))) int uv_pipe_getsockname(const uv_pipe_t* handle,
                                  char* buffer,
                                  size_t* size);
__attribute__((visibility("default"))) int uv_pipe_getpeername(const uv_pipe_t* handle,
                                  char* buffer,
                                  size_t* size);
__attribute__((visibility("default"))) void uv_pipe_pending_instances(uv_pipe_t* handle, int count);
__attribute__((visibility("default"))) int uv_pipe_pending_count(uv_pipe_t* handle);
__attribute__((visibility("default"))) uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);
__attribute__((visibility("default"))) int uv_pipe_chmod(uv_pipe_t* handle, int flags);


struct uv_poll_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_poll_cb poll_cb;
  uv__io_t io_watcher;
};

enum uv_poll_event {
  UV_READABLE = 1,
  UV_WRITABLE = 2,
  UV_DISCONNECT = 4,
  UV_PRIORITIZED = 8
};

__attribute__((visibility("default"))) int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);
__attribute__((visibility("default"))) int uv_poll_init_socket(uv_loop_t* loop,
                                  uv_poll_t* handle,
                                  uv_os_sock_t socket);
__attribute__((visibility("default"))) int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);
__attribute__((visibility("default"))) int uv_poll_stop(uv_poll_t* handle);


struct uv_prepare_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_prepare_cb prepare_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);
__attribute__((visibility("default"))) int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);
__attribute__((visibility("default"))) int uv_prepare_stop(uv_prepare_t* prepare);


struct uv_check_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_check_cb check_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_check_init(uv_loop_t*, uv_check_t* check);
__attribute__((visibility("default"))) int uv_check_start(uv_check_t* check, uv_check_cb cb);
__attribute__((visibility("default"))) int uv_check_stop(uv_check_t* check);


struct uv_idle_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_idle_cb idle_cb; void* queue[2];
};

__attribute__((visibility("default"))) int uv_idle_init(uv_loop_t*, uv_idle_t* idle);
__attribute__((visibility("default"))) int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);
__attribute__((visibility("default"))) int uv_idle_stop(uv_idle_t* idle);


struct uv_async_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_async_cb async_cb; void* queue[2]; int pending;
};

__attribute__((visibility("default"))) int uv_async_init(uv_loop_t*,
                            uv_async_t* async,
                            uv_async_cb async_cb);
__attribute__((visibility("default"))) int uv_async_send(uv_async_t* async);







struct uv_timer_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_timer_cb timer_cb; void* heap_node[3]; uint64_t timeout; uint64_t repeat; uint64_t start_id;
};

__attribute__((visibility("default"))) int uv_timer_init(uv_loop_t*, uv_timer_t* handle);
__attribute__((visibility("default"))) int uv_timer_start(uv_timer_t* handle,
                             uv_timer_cb cb,
                             uint64_t timeout,
                             uint64_t repeat);
__attribute__((visibility("default"))) int uv_timer_stop(uv_timer_t* handle);
__attribute__((visibility("default"))) int uv_timer_again(uv_timer_t* handle);
__attribute__((visibility("default"))) void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);
__attribute__((visibility("default"))) uint64_t uv_timer_get_repeat(const uv_timer_t* handle);
__attribute__((visibility("default"))) uint64_t uv_timer_get_due_in(const uv_timer_t* handle);







struct uv_getaddrinfo_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  struct uv__work work_req; uv_getaddrinfo_cb cb; struct addrinfo* hints; char* hostname; char* service; struct addrinfo* addrinfo; int retcode;
};


__attribute__((visibility("default"))) int uv_getaddrinfo(uv_loop_t* loop,
                             uv_getaddrinfo_t* req,
                             uv_getaddrinfo_cb getaddrinfo_cb,
                             const char* node,
                             const char* service,
                             const struct addrinfo* hints);
__attribute__((visibility("default"))) void uv_freeaddrinfo(struct addrinfo* ai);







struct uv_getnameinfo_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  struct uv__work work_req; uv_getnameinfo_cb getnameinfo_cb; struct sockaddr_storage storage; int flags; char host[
# 929 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 1025
# 929 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 ]; char service[
# 929 "/home/jesmith/neovim/.deps/usr/include/uv.h" 3 4
 32
# 929 "/home/jesmith/neovim/.deps/usr/include/uv.h"
 ]; int retcode;
};

__attribute__((visibility("default"))) int uv_getnameinfo(uv_loop_t* loop,
                             uv_getnameinfo_t* req,
                             uv_getnameinfo_cb getnameinfo_cb,
                             const struct sockaddr* addr,
                             int flags);



typedef enum {
  UV_IGNORE = 0x00,
  UV_CREATE_PIPE = 0x01,
  UV_INHERIT_FD = 0x02,
  UV_INHERIT_STREAM = 0x04,






  UV_READABLE_PIPE = 0x10,
  UV_WRITABLE_PIPE = 0x20,







  UV_NONBLOCK_PIPE = 0x40,
  UV_OVERLAPPED_PIPE = 0x40
} uv_stdio_flags;

typedef struct uv_stdio_container_s {
  uv_stdio_flags flags;

  union {
    uv_stream_t* stream;
    int fd;
  } data;
} uv_stdio_container_t;

typedef struct uv_process_options_s {
  uv_exit_cb exit_cb;
  const char* file;






  char** args;




  char** env;




  const char* cwd;




  unsigned int flags;
# 1007 "/home/jesmith/neovim/.deps/usr/include/uv.h"
  int stdio_count;
  uv_stdio_container_t* stdio;





  uv_uid_t uid;
  uv_gid_t gid;
} uv_process_options_t;




enum uv_process_flags {





  UV_PROCESS_SETUID = (1 << 0),





  UV_PROCESS_SETGID = (1 << 1),





  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),







  UV_PROCESS_DETACHED = (1 << 3),




  UV_PROCESS_WINDOWS_HIDE = (1 << 4),





  UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 << 5),





  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)
};




struct uv_process_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_exit_cb exit_cb;
  int pid;
  void* queue[2]; int status;
};

__attribute__((visibility("default"))) int uv_spawn(uv_loop_t* loop,
                       uv_process_t* handle,
                       const uv_process_options_t* options);
__attribute__((visibility("default"))) int uv_process_kill(uv_process_t*, int signum);
__attribute__((visibility("default"))) int uv_kill(int pid, int signum);
__attribute__((visibility("default"))) uv_pid_t uv_process_get_pid(const uv_process_t*);





struct uv_work_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_loop_t* loop;
  uv_work_cb work_cb;
  uv_after_work_cb after_work_cb;
  struct uv__work work_req;
};

__attribute__((visibility("default"))) int uv_queue_work(uv_loop_t* loop,
                            uv_work_t* req,
                            uv_work_cb work_cb,
                            uv_after_work_cb after_work_cb);

__attribute__((visibility("default"))) int uv_cancel(uv_req_t* req);


struct uv_cpu_times_s {
  uint64_t user;
  uint64_t nice;
  uint64_t sys;
  uint64_t idle;
  uint64_t irq;
};

struct uv_cpu_info_s {
  char* model;
  int speed;
  struct uv_cpu_times_s cpu_times;
};

struct uv_interface_address_s {
  char* name;
  char phys_addr[6];
  int is_internal;
  union {
    struct sockaddr_in address4;
    struct sockaddr_in6 address6;
  } address;
  union {
    struct sockaddr_in netmask4;
    struct sockaddr_in6 netmask6;
  } netmask;
};

struct uv_passwd_s {
  char* username;
  long uid;
  long gid;
  char* shell;
  char* homedir;
};

struct uv_utsname_s {
  char sysname[256];
  char release[256];
  char version[256];
  char machine[256];



};

struct uv_statfs_s {
  uint64_t f_type;
  uint64_t f_bsize;
  uint64_t f_blocks;
  uint64_t f_bfree;
  uint64_t f_bavail;
  uint64_t f_files;
  uint64_t f_ffree;
  uint64_t f_spare[4];
};

typedef enum {
  UV_DIRENT_UNKNOWN,
  UV_DIRENT_FILE,
  UV_DIRENT_DIR,
  UV_DIRENT_LINK,
  UV_DIRENT_FIFO,
  UV_DIRENT_SOCKET,
  UV_DIRENT_CHAR,
  UV_DIRENT_BLOCK
} uv_dirent_type_t;

struct uv_dirent_s {
  const char* name;
  uv_dirent_type_t type;
};

__attribute__((visibility("default"))) char** uv_setup_args(int argc, char** argv);
__attribute__((visibility("default"))) int uv_get_process_title(char* buffer, size_t size);
__attribute__((visibility("default"))) int uv_set_process_title(const char* title);
__attribute__((visibility("default"))) int uv_resident_set_memory(size_t* rss);
__attribute__((visibility("default"))) int uv_uptime(double* uptime);
__attribute__((visibility("default"))) uv_os_fd_t uv_get_osfhandle(int fd);
__attribute__((visibility("default"))) int uv_open_osfhandle(uv_os_fd_t os_fd);

typedef struct {
  long tv_sec;
  long tv_usec;
} uv_timeval_t;

typedef struct {
  int64_t tv_sec;
  int32_t tv_usec;
} uv_timeval64_t;

typedef struct {
   uv_timeval_t ru_utime;
   uv_timeval_t ru_stime;
   uint64_t ru_maxrss;
   uint64_t ru_ixrss;
   uint64_t ru_idrss;
   uint64_t ru_isrss;
   uint64_t ru_minflt;
   uint64_t ru_majflt;
   uint64_t ru_nswap;
   uint64_t ru_inblock;
   uint64_t ru_oublock;
   uint64_t ru_msgsnd;
   uint64_t ru_msgrcv;
   uint64_t ru_nsignals;
   uint64_t ru_nvcsw;
   uint64_t ru_nivcsw;
} uv_rusage_t;

__attribute__((visibility("default"))) int uv_getrusage(uv_rusage_t* rusage);

__attribute__((visibility("default"))) int uv_os_homedir(char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_tmpdir(char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_get_passwd(uv_passwd_t* pwd);
__attribute__((visibility("default"))) void uv_os_free_passwd(uv_passwd_t* pwd);
__attribute__((visibility("default"))) uv_pid_t uv_os_getpid(void);
__attribute__((visibility("default"))) uv_pid_t uv_os_getppid(void);
# 1240 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_os_getpriority(uv_pid_t pid, int* priority);
__attribute__((visibility("default"))) int uv_os_setpriority(uv_pid_t pid, int priority);

__attribute__((visibility("default"))) int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);
__attribute__((visibility("default"))) void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);

__attribute__((visibility("default"))) int uv_interface_addresses(uv_interface_address_t** addresses,
                                     int* count);
__attribute__((visibility("default"))) void uv_free_interface_addresses(uv_interface_address_t* addresses,
                                           int count);

struct uv_env_item_s {
  char* name;
  char* value;
};

__attribute__((visibility("default"))) int uv_os_environ(uv_env_item_t** envitems, int* count);
__attribute__((visibility("default"))) void uv_os_free_environ(uv_env_item_t* envitems, int count);
__attribute__((visibility("default"))) int uv_os_getenv(const char* name, char* buffer, size_t* size);
__attribute__((visibility("default"))) int uv_os_setenv(const char* name, const char* value);
__attribute__((visibility("default"))) int uv_os_unsetenv(const char* name);
# 1273 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_os_gethostname(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_os_uname(uv_utsname_t* buffer);

__attribute__((visibility("default"))) uint64_t uv_metrics_idle_time(uv_loop_t* loop);

typedef enum {
  UV_FS_UNKNOWN = -1,
  UV_FS_CUSTOM,
  UV_FS_OPEN,
  UV_FS_CLOSE,
  UV_FS_READ,
  UV_FS_WRITE,
  UV_FS_SENDFILE,
  UV_FS_STAT,
  UV_FS_LSTAT,
  UV_FS_FSTAT,
  UV_FS_FTRUNCATE,
  UV_FS_UTIME,
  UV_FS_FUTIME,
  UV_FS_ACCESS,
  UV_FS_CHMOD,
  UV_FS_FCHMOD,
  UV_FS_FSYNC,
  UV_FS_FDATASYNC,
  UV_FS_UNLINK,
  UV_FS_RMDIR,
  UV_FS_MKDIR,
  UV_FS_MKDTEMP,
  UV_FS_RENAME,
  UV_FS_SCANDIR,
  UV_FS_LINK,
  UV_FS_SYMLINK,
  UV_FS_READLINK,
  UV_FS_CHOWN,
  UV_FS_FCHOWN,
  UV_FS_REALPATH,
  UV_FS_COPYFILE,
  UV_FS_LCHOWN,
  UV_FS_OPENDIR,
  UV_FS_READDIR,
  UV_FS_CLOSEDIR,
  UV_FS_STATFS,
  UV_FS_MKSTEMP,
  UV_FS_LUTIME
} uv_fs_type;

struct uv_dir_s {
  uv_dirent_t* dirents;
  size_t nentries;
  void* reserved[4];
  DIR* dir;
};


struct uv_fs_s {
  void* data; uv_req_type type; void* reserved[6];
  uv_fs_type fs_type;
  uv_loop_t* loop;
  uv_fs_cb cb;
  ssize_t result;
  void* ptr;
  const char* path;
  uv_stat_t statbuf;
  const char *new_path; uv_file file; int flags; mode_t mode; unsigned int nbufs; uv_buf_t* bufs; off_t off; uv_uid_t uid; uv_gid_t gid; double atime; double mtime; struct uv__work work_req; uv_buf_t bufsml[4];
};

__attribute__((visibility("default"))) uv_fs_type uv_fs_get_type(const uv_fs_t*);
__attribute__((visibility("default"))) ssize_t uv_fs_get_result(const uv_fs_t*);
__attribute__((visibility("default"))) int uv_fs_get_system_error(const uv_fs_t*);
__attribute__((visibility("default"))) void* uv_fs_get_ptr(const uv_fs_t*);
__attribute__((visibility("default"))) const char* uv_fs_get_path(const uv_fs_t*);
__attribute__((visibility("default"))) uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);

__attribute__((visibility("default"))) void uv_fs_req_cleanup(uv_fs_t* req);
__attribute__((visibility("default"))) int uv_fs_close(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_open(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         int flags,
                         int mode,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_read(uv_loop_t* loop,
                         uv_fs_t* req,
                         uv_file file,
                         const uv_buf_t bufs[],
                         unsigned int nbufs,
                         int64_t offset,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_unlink(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_write(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          const uv_buf_t bufs[],
                          unsigned int nbufs,
                          int64_t offset,
                          uv_fs_cb cb);
# 1394 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_fs_copyfile(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             const char* new_path,
                             int flags,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkdir(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          int mode,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkdtemp(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* tpl,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_mkstemp(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* tpl,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_rmdir(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_scandir(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            int flags,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_scandir_next(uv_fs_t* req,
                                 uv_dirent_t* ent);
__attribute__((visibility("default"))) int uv_fs_opendir(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_readdir(uv_loop_t* loop,
                            uv_fs_t* req,
                            uv_dir_t* dir,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_closedir(uv_loop_t* loop,
                             uv_fs_t* req,
                             uv_dir_t* dir,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_stat(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fstat(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_rename(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           const char* new_path,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fsync(uv_loop_t* loop,
                          uv_fs_t* req,
                          uv_file file,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fdatasync(uv_loop_t* loop,
                              uv_fs_t* req,
                              uv_file file,
                              uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_ftruncate(uv_loop_t* loop,
                              uv_fs_t* req,
                              uv_file file,
                              int64_t offset,
                              uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_sendfile(uv_loop_t* loop,
                             uv_fs_t* req,
                             uv_file out_fd,
                             uv_file in_fd,
                             int64_t in_offset,
                             size_t length,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_access(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           int mode,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_chmod(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          int mode,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_utime(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          double atime,
                          double mtime,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_futime(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           double atime,
                           double mtime,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_lutime(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           double atime,
                           double mtime,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_lstat(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_link(uv_loop_t* loop,
                         uv_fs_t* req,
                         const char* path,
                         const char* new_path,
                         uv_fs_cb cb);
# 1519 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_fs_symlink(uv_loop_t* loop,
                            uv_fs_t* req,
                            const char* path,
                            const char* new_path,
                            int flags,
                            uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_readlink(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_realpath(uv_loop_t* loop,
                             uv_fs_t* req,
                             const char* path,
                             uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fchmod(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           int mode,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_chown(uv_loop_t* loop,
                          uv_fs_t* req,
                          const char* path,
                          uv_uid_t uid,
                          uv_gid_t gid,
                          uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_fchown(uv_loop_t* loop,
                           uv_fs_t* req,
                           uv_file file,
                           uv_uid_t uid,
                           uv_gid_t gid,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_lchown(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_uid_t uid,
                           uv_gid_t gid,
                           uv_fs_cb cb);
__attribute__((visibility("default"))) int uv_fs_statfs(uv_loop_t* loop,
                           uv_fs_t* req,
                           const char* path,
                           uv_fs_cb cb);


enum uv_fs_event {
  UV_RENAME = 1,
  UV_CHANGE = 2
};


struct uv_fs_event_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;

  char* path;
  uv_fs_event_cb cb; void* watchers[2]; int wd;
};





struct uv_fs_poll_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;

  void* poll_ctx;
};

__attribute__((visibility("default"))) int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);
__attribute__((visibility("default"))) int uv_fs_poll_start(uv_fs_poll_t* handle,
                               uv_fs_poll_cb poll_cb,
                               const char* path,
                               unsigned int interval);
__attribute__((visibility("default"))) int uv_fs_poll_stop(uv_fs_poll_t* handle);
__attribute__((visibility("default"))) int uv_fs_poll_getpath(uv_fs_poll_t* handle,
                                 char* buffer,
                                 size_t* size);


struct uv_signal_s {
  void* data; uv_loop_t* loop; uv_handle_type type; uv_close_cb close_cb; void* handle_queue[2]; union { int fd; void* reserved[4]; } u; uv_handle_t* next_closing; unsigned int flags;
  uv_signal_cb signal_cb;
  int signum;
  struct { struct uv_signal_s* rbe_left; struct uv_signal_s* rbe_right; struct uv_signal_s* rbe_parent; int rbe_color; } tree_entry; unsigned int caught_signals; unsigned int dispatched_signals;
};

__attribute__((visibility("default"))) int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);
__attribute__((visibility("default"))) int uv_signal_start(uv_signal_t* handle,
                              uv_signal_cb signal_cb,
                              int signum);
__attribute__((visibility("default"))) int uv_signal_start_oneshot(uv_signal_t* handle,
                                      uv_signal_cb signal_cb,
                                      int signum);
__attribute__((visibility("default"))) int uv_signal_stop(uv_signal_t* handle);

__attribute__((visibility("default"))) void uv_loadavg(double avg[3]);





enum uv_fs_event_flags {







  UV_FS_EVENT_WATCH_ENTRY = 1,
# 1635 "/home/jesmith/neovim/.deps/usr/include/uv.h"
  UV_FS_EVENT_STAT = 2,






  UV_FS_EVENT_RECURSIVE = 4
};


__attribute__((visibility("default"))) int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);
__attribute__((visibility("default"))) int uv_fs_event_start(uv_fs_event_t* handle,
                                uv_fs_event_cb cb,
                                const char* path,
                                unsigned int flags);
__attribute__((visibility("default"))) int uv_fs_event_stop(uv_fs_event_t* handle);
__attribute__((visibility("default"))) int uv_fs_event_getpath(uv_fs_event_t* handle,
                                  char* buffer,
                                  size_t* size);

__attribute__((visibility("default"))) int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);
__attribute__((visibility("default"))) int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);

__attribute__((visibility("default"))) int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);
__attribute__((visibility("default"))) int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);

__attribute__((visibility("default"))) int uv_inet_ntop(int af, const void* src, char* dst, size_t size);
__attribute__((visibility("default"))) int uv_inet_pton(int af, const char* src, void* dst);


struct uv_random_s {
  void* data; uv_req_type type; void* reserved[6];

  uv_loop_t* loop;

  int status;
  void* buf;
  size_t buflen;
  uv_random_cb cb;
  struct uv__work work_req;
};

__attribute__((visibility("default"))) int uv_random(uv_loop_t* loop,
                        uv_random_t* req,
                        void *buf,
                        size_t buflen,
                        unsigned flags,
                        uv_random_cb cb);
# 1693 "/home/jesmith/neovim/.deps/usr/include/uv.h"
__attribute__((visibility("default"))) int uv_if_indextoname(unsigned int ifindex,
                                char* buffer,
                                size_t* size);
__attribute__((visibility("default"))) int uv_if_indextoiid(unsigned int ifindex,
                               char* buffer,
                               size_t* size);

__attribute__((visibility("default"))) int uv_exepath(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_cwd(char* buffer, size_t* size);

__attribute__((visibility("default"))) int uv_chdir(const char* dir);

__attribute__((visibility("default"))) uint64_t uv_get_free_memory(void);
__attribute__((visibility("default"))) uint64_t uv_get_total_memory(void);
__attribute__((visibility("default"))) uint64_t uv_get_constrained_memory(void);

__attribute__((visibility("default"))) uint64_t uv_hrtime(void);
__attribute__((visibility("default"))) void uv_sleep(unsigned int msec);

__attribute__((visibility("default"))) void uv_disable_stdio_inheritance(void);

__attribute__((visibility("default"))) int uv_dlopen(const char* filename, uv_lib_t* lib);
__attribute__((visibility("default"))) void uv_dlclose(uv_lib_t* lib);
__attribute__((visibility("default"))) int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);
__attribute__((visibility("default"))) const char* uv_dlerror(const uv_lib_t* lib);

__attribute__((visibility("default"))) int uv_mutex_init(uv_mutex_t* handle);
__attribute__((visibility("default"))) int uv_mutex_init_recursive(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_destroy(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_lock(uv_mutex_t* handle);
__attribute__((visibility("default"))) int uv_mutex_trylock(uv_mutex_t* handle);
__attribute__((visibility("default"))) void uv_mutex_unlock(uv_mutex_t* handle);

__attribute__((visibility("default"))) int uv_rwlock_init(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_destroy(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);
__attribute__((visibility("default"))) void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);

__attribute__((visibility("default"))) int uv_sem_init(uv_sem_t* sem, unsigned int value);
__attribute__((visibility("default"))) void uv_sem_destroy(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_post(uv_sem_t* sem);
__attribute__((visibility("default"))) void uv_sem_wait(uv_sem_t* sem);
__attribute__((visibility("default"))) int uv_sem_trywait(uv_sem_t* sem);

__attribute__((visibility("default"))) int uv_cond_init(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_destroy(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_signal(uv_cond_t* cond);
__attribute__((visibility("default"))) void uv_cond_broadcast(uv_cond_t* cond);

__attribute__((visibility("default"))) int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);
__attribute__((visibility("default"))) void uv_barrier_destroy(uv_barrier_t* barrier);
__attribute__((visibility("default"))) int uv_barrier_wait(uv_barrier_t* barrier);

__attribute__((visibility("default"))) void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);
__attribute__((visibility("default"))) int uv_cond_timedwait(uv_cond_t* cond,
                                uv_mutex_t* mutex,
                                uint64_t timeout);

__attribute__((visibility("default"))) void uv_once(uv_once_t* guard, void (*callback)(void));

__attribute__((visibility("default"))) int uv_key_create(uv_key_t* key);
__attribute__((visibility("default"))) void uv_key_delete(uv_key_t* key);
__attribute__((visibility("default"))) void* uv_key_get(uv_key_t* key);
__attribute__((visibility("default"))) void uv_key_set(uv_key_t* key, void* value);

__attribute__((visibility("default"))) int uv_gettimeofday(uv_timeval64_t* tv);

typedef void (*uv_thread_cb)(void* arg);

__attribute__((visibility("default"))) int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);

typedef enum {
  UV_THREAD_NO_FLAGS = 0x00,
  UV_THREAD_HAS_STACK_SIZE = 0x01
} uv_thread_create_flags;

struct uv_thread_options_s {
  unsigned int flags;
  size_t stack_size;

};

typedef struct uv_thread_options_s uv_thread_options_t;

__attribute__((visibility("default"))) int uv_thread_create_ex(uv_thread_t* tid,
                                  const uv_thread_options_t* params,
                                  uv_thread_cb entry,
                                  void* arg);
__attribute__((visibility("default"))) uv_thread_t uv_thread_self(void);
__attribute__((visibility("default"))) int uv_thread_join(uv_thread_t *tid);
__attribute__((visibility("default"))) int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);



union uv_any_handle {
  uv_async_t async; uv_check_t check; uv_fs_event_t fs_event; uv_fs_poll_t fs_poll; uv_handle_t handle; uv_idle_t idle; uv_pipe_t pipe; uv_poll_t poll; uv_prepare_t prepare; uv_process_t process; uv_stream_t stream; uv_tcp_t tcp; uv_timer_t timer; uv_tty_t tty; uv_udp_t udp; uv_signal_t signal;
};

union uv_any_req {
  uv_req_t req; uv_connect_t connect; uv_write_t write; uv_shutdown_t shutdown; uv_udp_send_t udp_send; uv_fs_t fs; uv_work_t work; uv_getaddrinfo_t getaddrinfo; uv_getnameinfo_t getnameinfo; uv_random_t random;
};



struct uv_loop_s {

  void* data;

  unsigned int active_handles;
  void* handle_queue[2];
  union {
    void* unused;
    unsigned int count;
  } active_reqs;

  void* internal_fields;

  unsigned int stop_flag;
  unsigned long flags; int backend_fd; void* pending_queue[2]; void* watcher_queue[2]; uv__io_t** watchers; unsigned int nwatchers; unsigned int nfds; void* wq[2]; uv_mutex_t wq_mutex; uv_async_t wq_async; uv_rwlock_t cloexec_lock; uv_handle_t* closing_handles; void* process_handles[2]; void* prepare_handles[2]; void* check_handles[2]; void* idle_handles[2]; void* async_handles[2]; void (*async_unused)(void); uv__io_t async_io_watcher; int async_wfd; struct { void* min; unsigned int nelts; } timer_heap; uint64_t timer_counter; uint64_t time; int signal_pipefd[2]; uv__io_t signal_io_watcher; uv_signal_t child_watcher; int emfile_fd; uv__io_t inotify_read_watcher; void* inotify_watchers; int inotify_fd;
};

__attribute__((visibility("default"))) void* uv_loop_get_data(const uv_loop_t*);
__attribute__((visibility("default"))) void uv_loop_set_data(uv_loop_t*, void* data);
# 5 "/home/jesmith/neovim/src/nvim/os/fs_defs.h" 2


typedef struct {
  uv_stat_t stat;
} FileInfo;


typedef struct {
  uint64_t inode;
  uint64_t device_id;
} FileID;



typedef struct {
  uv_fs_t request;
  uv_dirent_t ent;
} Directory;
# 115 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2
# 1 "/home/jesmith/neovim/src/nvim/sign_defs.h" 1
# 12 "/home/jesmith/neovim/src/nvim/sign_defs.h"
typedef struct signgroup_S {
  uint16_t sg_refcount;
  int sg_next_sign_id;
  char_u sg_name[1];
} signgroup_T;





typedef struct sign_entry sign_entry_T;

struct sign_entry {
  int se_id;
  int se_typenr;
  int se_priority;
  
# 28 "/home/jesmith/neovim/src/nvim/sign_defs.h" 3 4
 _Bool 
# 28 "/home/jesmith/neovim/src/nvim/sign_defs.h"
      se_has_text_or_icon;
  linenr_T se_lnum;
  signgroup_T *se_group;
  sign_entry_T *se_next;
  sign_entry_T *se_prev;
};


typedef struct sign_attrs_S {
  int sat_typenr;
  char_u *sat_text;
  int sat_texthl;
  int sat_linehl;
  int sat_numhl;
} sign_attrs_T;







typedef enum {
  SIGN_LINEHL,
  SIGN_NUMHL,
  SIGN_TEXT,
} SignType;
# 116 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2
# 1 "/home/jesmith/neovim/src/nvim/terminal.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/terminal.h" 2


typedef struct terminal Terminal;
typedef void (*terminal_write_cb)(char *buffer, size_t size, void *data);
typedef void (*terminal_resize_cb)(uint16_t width, uint16_t height, void *data);
typedef void (*terminal_close_cb)(void *data);



typedef struct {
  void *data;
  uint16_t width, height;
  terminal_write_cb write_cb;
  terminal_resize_cb resize_cb;
  terminal_close_cb close_cb;
} TerminalOptions;
# 117 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 2




typedef struct taggy {
  char_u *tagname;
  fmark_T fmark;
  int cur_match;
  int cur_fnum;
  char_u *user_data;
} taggy_T;

typedef struct buffblock buffblock_T;
typedef struct buffheader buffheader_T;




struct buffblock {
  buffblock_T *b_next;
  char_u b_str[1];
};




struct buffheader {
  buffblock_T bh_first;
  buffblock_T *bh_curr;
  size_t bh_index;
  size_t bh_space;
};

typedef struct {
  buffheader_T sr_redobuff;
  buffheader_T sr_old_redobuff;
} save_redo_T;






typedef struct {
  int wo_arab;

  int wo_bri;

  char_u *wo_briopt;

  int wo_diff;

  char_u *wo_fdc;

  char_u *wo_fdc_save;

  int wo_fen;

  int wo_fen_save;


  char_u *wo_fdi;

  long wo_fdl;

  int wo_fdl_save;


  char_u *wo_fdm;

  char_u *wo_fdm_save;

  long wo_fml;

  long wo_fdn;

  char_u *wo_fde;

  char_u *wo_fdt;

  char_u *wo_fmr;

  int wo_lbr;

  int wo_list;

  int wo_nu;

  int wo_rnu;

  long wo_nuw;

  int wo_wfh;

  int wo_wfw;

  int wo_pvw;

  int wo_rl;

  char_u *wo_rlc;

  long wo_scr;

  int wo_spell;

  int wo_cuc;

  int wo_cul;

  char_u *wo_culopt;

  char_u *wo_cc;

  char_u *wo_sbr;

  char_u *wo_stl;

  int wo_scb;

  int wo_diff_saved;

  int wo_scb_save;

  int wo_wrap;

  int wo_wrap_save;

  char_u *wo_cocu;

  long wo_cole;

  int wo_crb;

  int wo_crb_save;

  char_u *wo_scl;

  char_u *wo_winhl;

  char_u *wo_fcs;

  char_u *wo_lcs;

  long wo_winbl;


  LastSet wo_script_ctx[WV_COUNT];

} winopt_T;
# 278 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
struct wininfo_S {
  wininfo_T *wi_next;
  wininfo_T *wi_prev;
  win_T *wi_win;
  pos_T wi_fpos;
  
# 283 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 283 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      wi_optset;
  winopt_T wi_opt;
  
# 285 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 285 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      wi_fold_manual;
  garray_T wi_folds;
};







typedef struct arglist {
  garray_T al_ga;
  int al_refcount;
  int id;
} alist_T;






typedef struct argentry {
  char_u *ae_fname;
  int ae_fnum;
} aentry_T;
# 323 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct {
  char_u *tb_buf;
  char_u *tb_noremap;
  int tb_buflen;
  int tb_off;
  int tb_len;
  int tb_maplen;
  int tb_silent;
  int tb_no_abbr_cnt;
  int tb_change_cnt;
} typebuf_T;


typedef struct {
  typebuf_T save_typebuf;
  
# 338 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 338 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      typebuf_valid;
  int old_char;
  int old_mod_mask;
  buffheader_T save_readbuf1;
  buffheader_T save_readbuf2;
  String save_inputbuf;
} tasave_T;




typedef struct mapblock mapblock_T;
struct mapblock {
  mapblock_T *m_next;
  char_u *m_keys;
  char_u *m_str;
  char_u *m_orig_str;
  int m_keylen;
  int m_mode;
  int m_noremap;
  char m_silent;
  char m_nowait;
  char m_expr;
  sctx_T m_script_ctx;
};


typedef struct stl_hlrec stl_hlrec_t;
struct stl_hlrec {
  char_u *start;
  int userhl;
};


typedef struct stl_item stl_item_t;
struct stl_item {

  char_u *start;

  char *cmd;

  int minwid;

  int maxwid;
  enum {
    Normal,
    Empty,
    Group,
    Separate,
    Highlight,
    TabPage,
    ClickFunc,
    Trunc,
  } type;
};
# 406 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct qf_info_S qf_info_T;




typedef struct {
  proftime_T total;
  proftime_T slowest;
  long count;
  long match;
} syn_time_T;





typedef struct {
  hashtab_T b_keywtab;
  hashtab_T b_keywtab_ic;
  int b_syn_error;
  
# 426 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 426 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_syn_slow;
  int b_syn_ic;
  int b_syn_foldlevel;
  int b_syn_spell;
  garray_T b_syn_patterns;
  garray_T b_syn_clusters;
  int b_spell_cluster_id;
  int b_nospell_cluster_id;
  int b_syn_containedin;

  int b_syn_sync_flags;
  int16_t b_syn_sync_id;
  long b_syn_sync_minlines;
  long b_syn_sync_maxlines;
  long b_syn_sync_linebreaks;
  char_u *b_syn_linecont_pat;
  regprog_T *b_syn_linecont_prog;
  syn_time_T b_syn_linecont_time;
  int b_syn_linecont_ic;
  int b_syn_topgrp;
  int b_syn_conceal;
  int b_syn_folditems;
# 461 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
  synstate_T *b_sst_array;
  int b_sst_len;
  synstate_T *b_sst_first;
  synstate_T *b_sst_firstfree;
  int b_sst_freecount;
  linenr_T b_sst_check_lnum;
  disptick_T b_sst_lasttick;


  garray_T b_langp;
  
# 471 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 471 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_spell_ismw[256];
  char_u *b_spell_ismw_mb;
  char_u *b_p_spc;
  regprog_T *b_cap_prog;
  char_u *b_p_spf;
  char_u *b_p_spl;
  char_u *b_p_spo;
  int b_cjk;
  char_u b_syn_chartab[32];
  char_u *b_syn_isk;
} synblock_T;




typedef struct { typval_T di_tv; uint8_t di_flags; char_u di_key[sizeof("changedtick")]; } ChangedtickDictItem;

typedef struct {
  LuaRef on_lines;
  LuaRef on_bytes;
  LuaRef on_changedtick;
  LuaRef on_detach;
  LuaRef on_reload;
  
# 494 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 494 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      utf_sizes;
  
# 495 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 495 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      preview;
} BufUpdateCallbacks;



extern int curbuf_splice_pending ;
# 516 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
struct file_buffer {
  handle_T handle;


  memline_T b_ml;

  buf_T *b_next;
  buf_T *b_prev;

  int b_nwindows;

  int b_flags;
  int b_locked;

  int b_ro_locked;
# 539 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
  char_u *b_ffname;
  char_u *b_sfname;

  char_u *b_fname;


  
# 545 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 545 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      file_id_valid;
  FileID file_id;

  int b_changed;

  
# 550 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 550 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_changed_invalid;






  ChangedtickDictItem changedtick_di;

  varnumber_T b_last_changedtick;

  varnumber_T b_last_changedtick_pum;


  
# 564 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 564 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_saving;






  
# 571 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 571 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_mod_set;

  linenr_T b_mod_top;
  linenr_T b_mod_bot;

  long b_mod_xlines;

  wininfo_T *b_wininfo;
  disptick_T b_mod_tick_syn;
  disptick_T b_mod_tick_decor;


  long b_mtime;
  long b_mtime_read;
  uint64_t b_orig_size;
  int b_orig_mode;
  time_t b_last_used;


  fmark_T b_namedm[('z' - 'a' + 1)];


  visualinfo_T b_visual;
  int b_visual_mode_eval;

  fmark_T b_last_cursor;

  fmark_T b_last_insert;
  fmark_T b_last_change;




  fmark_T b_changelist[100];
  int b_changelistlen;
  
# 606 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 606 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_new_change;





  uint64_t b_chartab[4];


  mapblock_T *(b_maphash[256]);


  mapblock_T *b_first_abbr;

  garray_T b_ucmds;



  pos_T b_op_start;
  pos_T b_op_start_orig;
  pos_T b_op_end;

  
# 628 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 628 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_marks_read;




  u_header_T *b_u_oldhead;
  u_header_T *b_u_newhead;

  u_header_T *b_u_curhead;
  int b_u_numhead;
  
# 638 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 638 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_u_synced;
  long b_u_seq_last;
  long b_u_save_nr_last;
  long b_u_seq_cur;
  time_t b_u_time_cur;
  long b_u_save_nr_cur;




  char_u *b_u_line_ptr;
  linenr_T b_u_line_lnum;
  colnr_T b_u_line_colnr;

  
# 652 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 652 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_scanned;


  long b_p_iminsert;
  long b_p_imsearch;





  int16_t b_kmap_state;


  garray_T b_kmap_ga;






  
# 672 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 672 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_p_initialized;

  LastSet b_p_script_ctx[BV_COUNT];

  int b_p_ai;
  int b_p_ai_nopaste;
  char_u *b_p_bkc;
  unsigned int b_bkc_flags;
  int b_p_ci;
  int b_p_bin;
  int b_p_bomb;
  char_u *b_p_bh;
  char_u *b_p_bt;
  int b_has_qf_entry;
  int b_p_bl;
  long b_p_channel;
  int b_p_cin;
  char_u *b_p_cino;
  char_u *b_p_cink;
  char_u *b_p_cinw;
  char_u *b_p_com;
  char_u *b_p_cms;
  char_u *b_p_cpt;



  char_u *b_p_cfu;
  char_u *b_p_ofu;
  char_u *b_p_tfu;
  int b_p_eol;
  int b_p_fixeol;
  int b_p_et;
  int b_p_et_nobin;
  int b_p_et_nopaste;
  char_u *b_p_fenc;
  char_u *b_p_ff;
  char_u *b_p_ft;
  char_u *b_p_fo;
  char_u *b_p_flp;
  int b_p_inf;
  char_u *b_p_isk;
  char_u *b_p_def;
  char_u *b_p_inc;
  char_u *b_p_inex;
  uint32_t b_p_inex_flags;
  char_u *b_p_inde;
  uint32_t b_p_inde_flags;
  char_u *b_p_indk;
  char_u *b_p_fp;
  char_u *b_p_fex;
  uint32_t b_p_fex_flags;
  char_u *b_p_kp;
  int b_p_lisp;
  char_u *b_p_menc;
  char_u *b_p_mps;
  int b_p_ml;
  int b_p_ml_nobin;
  int b_p_ma;
  char_u *b_p_nf;
  int b_p_pi;
  char_u *b_p_qe;
  int b_p_ro;
  long b_p_sw;
  long b_p_scbk;
  int b_p_si;
  long b_p_sts;
  long b_p_sts_nopaste;
  char_u *b_p_sua;
  int b_p_swf;
  long b_p_smc;
  char_u *b_p_syn;
  long b_p_ts;
  long b_p_tw;
  long b_p_tw_nobin;
  long b_p_tw_nopaste;
  long b_p_wm;
  long b_p_wm_nobin;
  long b_p_wm_nopaste;
  char_u *b_p_vsts;
  long *b_p_vsts_array;
  char_u *b_p_vsts_nopaste;
  char_u *b_p_vts;
  long *b_p_vts_array;
  char_u *b_p_keymap;


  char_u *b_p_gp;
  char_u *b_p_mp;
  char_u *b_p_efm;
  char_u *b_p_ep;
  char_u *b_p_path;
  int b_p_ar;
  char_u *b_p_tags;
  char_u *b_p_tc;
  unsigned b_tc_flags;
  char_u *b_p_dict;
  char_u *b_p_tsr;
  char_u *b_p_tsrfu;
  long b_p_ul;
  int b_p_udf;
  char_u *b_p_lw;




  int b_ind_level;
  int b_ind_open_imag;
  int b_ind_no_brace;
  int b_ind_first_open;
  int b_ind_open_extra;
  int b_ind_close_extra;
  int b_ind_open_left_imag;
  int b_ind_jump_label;
  int b_ind_case;
  int b_ind_case_code;
  int b_ind_case_break;
  int b_ind_param;
  int b_ind_func_type;
  int b_ind_comment;
  int b_ind_in_comment;
  int b_ind_in_comment2;
  int b_ind_cpp_baseclass;
  int b_ind_continuation;
  int b_ind_unclosed;
  int b_ind_unclosed2;
  int b_ind_unclosed_noignore;
  int b_ind_unclosed_wrapped;
  int b_ind_unclosed_whiteok;
  int b_ind_matching_paren;
  int b_ind_paren_prev;
  int b_ind_maxparen;
  int b_ind_maxcomment;
  int b_ind_scopedecl;
  int b_ind_scopedecl_code;
  int b_ind_java;
  int b_ind_js;
  int b_ind_keep_case_label;
  int b_ind_hash_comment;
  int b_ind_cpp_namespace;
  int b_ind_if_for_while;
  int b_ind_cpp_extern_c;
  int b_ind_pragma;

  linenr_T b_no_eol_lnum;


  int b_start_eol;
  int b_start_ffc;
  char_u *b_start_fenc;
  int b_bad_char;
  int b_start_bomb;

  ScopeDictDictItem b_bufvar;
  dict_T *b_vars;





  
# 831 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 831 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_may_swap;
  
# 832 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 832 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_did_warn;







  
# 840 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 840 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_help;

  
# 842 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 842 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_spell;



  char_u *b_prompt_text;
  Callback b_prompt_callback;
  Callback b_prompt_interrupt;
  int b_prompt_insert;


  synblock_T b_s;



  sign_entry_T *b_signlist;
  int b_signcols;
  
# 858 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 858 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      b_signcols_valid;

  Terminal *terminal;

  dict_T *additional_data;

  int b_mapped_ctrl_c;

  MarkTree b_marktree[1];
  Map_uint64_t_ExtmarkItem b_extmark_index[1];
  Map_uint64_t_ExtmarkNs b_extmark_ns[1];
  size_t b_virt_line_blocks;



  struct { size_t size; size_t capacity; uint64_t *items; } update_channels;

  struct { size_t size; size_t capacity; BufUpdateCallbacks *items; } update_callbacks;


  
# 878 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 878 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      update_need_codepoints;





  size_t deleted_bytes;
  size_t deleted_bytes2;
  size_t deleted_codepoints;
  size_t deleted_codeunits;


  int flush_count;

  int b_diff_failed;
};
# 914 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct diffblock_S diff_T;
struct diffblock_S {
  diff_T *df_next;
  linenr_T df_lnum[8];
  linenr_T df_count[8];
};
# 929 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct tabpage_S tabpage_T;
struct tabpage_S {
  handle_T handle;
  tabpage_T *tp_next;
  frame_T *tp_topframe;
  win_T *tp_curwin;
  win_T *tp_prevwin;
  win_T *tp_firstwin;
  win_T *tp_lastwin;
  long tp_old_Rows;
  long tp_old_Columns;
  long tp_ch_used;


  diff_T *tp_first_diff;
  buf_T *(tp_diffbuf[8]);
  int tp_diff_invalid;
  int tp_diff_update;
  frame_T *(tp_snapshot[2]);
  ScopeDictDictItem tp_winvar;
  dict_T *tp_vars;
  char_u *tp_localdir;
  char_u *tp_prevdir;
};
# 966 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct w_line {
  linenr_T wl_lnum;
  uint16_t wl_size;
  char wl_valid;
  char wl_folded;
  linenr_T wl_lastlnum;
} wline_T;





struct frame_S {
  char fr_layout;
  int fr_width;
  int fr_newwidth;
  int fr_height;
  int fr_newheight;
  frame_T *fr_parent;
  frame_T *fr_next;

  frame_T *fr_prev;


  frame_T *fr_child;
  win_T *fr_win;
};
# 1004 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct {
  regmmatch_T rm;

  buf_T *buf;
  linenr_T lnum;
  int attr;
  int attr_cur;
  linenr_T first_lnum;
  colnr_T startcol;
  colnr_T endcol;
  
# 1014 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1014 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      is_addpos;
  proftime_T tm;
} match_T;





typedef struct {
  linenr_T lnum;
  colnr_T col;
  int len;
} llpos_T;



typedef struct posmatch posmatch_T;
struct posmatch {
  llpos_T pos[8];
  int cur;
  linenr_T toplnum;
  linenr_T botlnum;
};





typedef struct matchitem matchitem_T;
struct matchitem {
  matchitem_T *next;
  int id;
  int priority;
  char_u *pattern;
  regmmatch_T match;
  posmatch_T pos;
  match_T hl;
  int hlg_id;
  int conceal_char;
};

typedef int FloatAnchor;

enum {
  kFloatAnchorEast = 1,
  kFloatAnchorSouth = 2,
};





extern const char *const float_anchor_str[] ;

typedef enum {
  kFloatRelativeEditor = 0,
  kFloatRelativeWindow = 1,
  kFloatRelativeCursor = 2,
} FloatRelative;

extern const char *const float_relative_str[]
                                                                  ;

typedef enum {
  kWinStyleUnused = 0,
  kWinStyleMinimal,
} WinStyle;

typedef struct {
  Window window;
  lpos_T bufpos;
  int height, width;
  double row, col;
  FloatAnchor anchor;
  FloatRelative relative;
  
# 1089 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1089 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      external;
  
# 1090 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1090 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      focusable;
  int zindex;
  WinStyle style;
  
# 1093 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1093 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      border;
  
# 1094 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1094 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      shadow;
  schar_T border_chars[8];
  int border_hl_ids[8];
  int border_attr[8];
  
# 1098 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1098 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      noautocmd;
} FloatConfig;
# 1112 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
typedef struct {
  int w_topline_save;
  int w_topline_corr;
  pos_T w_cursor_save;
  pos_T w_cursor_corr;
} pos_save_T;


typedef struct {
  
# 1121 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1121 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      sve_did_save;
  hashtab_T sve_hashtab;
} save_v_event_T;




enum {
  MENU_INDEX_INVALID = -1,
  MENU_INDEX_NORMAL = 0,
  MENU_INDEX_VISUAL = 1,
  MENU_INDEX_SELECT = 2,
  MENU_INDEX_OP_PENDING = 3,
  MENU_INDEX_INSERT = 4,
  MENU_INDEX_CMDLINE = 5,
  MENU_INDEX_TIP = 6,
  MENU_MODES = 7,
};

typedef struct VimMenu vimmenu_T;

struct VimMenu {
  int modes;
  int enabled;
  char_u *name;
  char_u *dname;
  char_u *en_name;

  char_u *en_dname;
  int mnemonic;
  char_u *actext;
  long priority;
  char_u *strings[MENU_MODES];
  int noremap[MENU_MODES];
  
# 1155 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1155 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      silent[MENU_MODES];
  vimmenu_T *children;
  vimmenu_T *parent;
  vimmenu_T *next;
};




struct window_S {
  handle_T handle;

  buf_T *w_buffer;


  synblock_T *w_s;

  int w_hl_id_normal;
  int w_hl_attr_normal;

  int w_hl_ids[HLF_COUNT];
  int w_hl_attrs[HLF_COUNT];

  int w_hl_needs_update;

  win_T *w_prev;
  win_T *w_next;
  
# 1182 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1182 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_closing;


  frame_T *w_frame;

  pos_T w_cursor;

  colnr_T w_curswant;



  int w_set_curswant;



  linenr_T w_last_cursorline;
  pos_T w_last_cursormoved;


  char w_old_visual_mode;
  linenr_T w_old_cursor_lnum;
  colnr_T w_old_cursor_fcol;
  colnr_T w_old_cursor_lcol;
  linenr_T w_old_visual_lnum;
  colnr_T w_old_visual_col;
  colnr_T w_old_curswant;


  struct {
    int eol;
    int ext;
    int prec;
    int nbsp;
    int space;
    int tab1;
    int tab2;
    int tab3;
    int lead;
    int trail;
    int *multispace;
    int conceal;
  } w_p_lcs_chars;


  struct {
    int stl;
    int stlnc;
    int vert;
    int fold;
    int foldopen;
    int foldclosed;
    int foldsep;
    int diff;
    int msgsep;
    int eob;
  } w_p_fcs_chars;





  linenr_T w_topline;

  char w_topline_was_set;

  int w_topfill;
  int w_old_topfill;
  
# 1249 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1249 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_botfill;

  
# 1251 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1251 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_old_botfill;
  colnr_T w_leftcol;


  colnr_T w_skipcol;




  linenr_T w_last_topline;
  colnr_T w_last_leftcol;
  int w_last_width;
  int w_last_height;





  int w_winrow;
  int w_height;

  int w_status_height;
  int w_wincol;
  int w_width;
  int w_vsep_width;
  pos_save_T w_save_cursor;


  int w_height_inner;
  int w_width_inner;

  int w_height_request;
  int w_width_request;

  int w_border_adj[4];

  int w_height_outer;
  int w_width_outer;
# 1299 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
  int w_valid;
  pos_T w_valid_cursor;

  colnr_T w_valid_leftcol;

  
# 1304 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1304 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_viewport_invalid;





  int w_cline_height;
  
# 1311 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1311 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_cline_folded;

  int w_cline_row;

  colnr_T w_virtcol;
# 1327 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
  int w_wrow, w_wcol;

  linenr_T w_botline;

  int w_empty_rows;
  int w_filler_rows;
# 1345 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
  int w_lines_valid;
  wline_T *w_lines;

  garray_T w_folds;
  
# 1349 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1349 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_fold_manual;

  
# 1351 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1351 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_foldinvalid;

  int w_nrwidth;






  int w_redr_type;
  int w_upd_rows;

  linenr_T w_redraw_top;
  linenr_T w_redraw_bot;
  
# 1365 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1365 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_redr_status;
  
# 1366 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1366 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_redr_border;


  pos_T w_ru_cursor;
  colnr_T w_ru_virtcol;
  linenr_T w_ru_topline;
  linenr_T w_ru_line_count;
  int w_ru_topfill;
  char w_ru_empty;

  int w_alt_fnum;

  alist_T *w_alist;
  int w_arg_idx;

  int w_arg_idx_invalid;

  char_u *w_localdir;
  char_u *w_prevdir;





  winopt_T w_onebuf_opt;
  winopt_T w_allbuf_opt;


  uint32_t w_p_stl_flags;
  uint32_t w_p_fde_flags;
  uint32_t w_p_fdt_flags;
  int *w_p_cc_cols;
  char_u w_p_culopt_flags;
  long w_p_siso;
  long w_p_so;

  int w_briopt_min;
  int w_briopt_shift;
  
# 1404 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1404 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_briopt_sbr;
  int w_briopt_list;




  long w_scbind_pos;

  ScopeDictDictItem w_winvar;
  dict_T *w_vars;






  pos_T w_pcmark;
  pos_T w_prev_pcmark;




  xfmark_T w_jumplist[100];
  int w_jumplistlen;
  int w_jumplistidx;

  int w_changelistidx;

  matchitem_T *w_match_head;
  int w_next_match_id;







  taggy_T w_tagstack[20];
  int w_tagstackidx;
  int w_tagstacklen;

  ScreenGrid w_grid;
  ScreenGrid w_grid_alloc;
  
# 1447 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1447 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_pos_changed;
  
# 1448 "/home/jesmith/neovim/src/nvim/buffer_defs.h" 3 4
 _Bool 
# 1448 "/home/jesmith/neovim/src/nvim/buffer_defs.h"
      w_floating;
  FloatConfig w_float_config;







  int w_fraction;
  int w_prev_fraction_row;

  linenr_T w_nrwidth_line_count;

  int w_nrwidth_width;

  qf_info_T *w_llist;


  qf_info_T *w_llist_ref;
};

static inline int win_hl_attr(win_T *wp, int hlf)
{
  return wp->w_hl_attrs[hlf];
}
# 5 "/home/jesmith/neovim/src/nvim/decoration.h" 2





typedef uint16_t DecorPriority;


typedef enum {
  kVTEndOfLine,
  kVTOverlay,
  kVTWinCol,
  kVTRightAlign,
} VirtTextPos;

typedef enum {
  kHlModeUnknown,
  kHlModeReplace,
  kHlModeCombine,
  kHlModeBlend,
} HlMode;

typedef struct { size_t size; size_t capacity; VirtTextChunk *items; } VirtText;



typedef struct { size_t size; size_t capacity; struct virt_line { VirtText line; 
# 31 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
       _Bool 
# 31 "/home/jesmith/neovim/src/nvim/decoration.h"
       left_col; } *items; } VirtLines;


struct Decoration {
  VirtText virt_text;
  VirtLines virt_lines;

  int hl_id;
  VirtTextPos virt_text_pos;
  HlMode hl_mode;


  
# 43 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 43 "/home/jesmith/neovim/src/nvim/decoration.h"
      virt_text_hide;
  
# 44 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 44 "/home/jesmith/neovim/src/nvim/decoration.h"
      hl_eol;
  
# 45 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 45 "/home/jesmith/neovim/src/nvim/decoration.h"
      shared;
  
# 46 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 46 "/home/jesmith/neovim/src/nvim/decoration.h"
      virt_lines_above;

  DecorPriority priority;
  int col;
  int virt_text_width;
};



typedef struct {
  int start_row;
  int start_col;
  int end_row;
  int end_col;
  Decoration decor;
  int attr_id;
  
# 62 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 62 "/home/jesmith/neovim/src/nvim/decoration.h"
      virt_text_owned;
  int win_col;
} DecorRange;

typedef struct {
  MarkTreeIter itr[1];
  struct { size_t size; size_t capacity; DecorRange *items; } active;
  buf_T *buf;
  int top_row;
  int row;
  int col_until;
  int current;
  int eol_col;
} DecorState;

typedef struct {
  NS ns_id;
  
# 79 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
 _Bool 
# 79 "/home/jesmith/neovim/src/nvim/decoration.h"
      active;
  LuaRef redraw_start;
  LuaRef redraw_buf;
  LuaRef redraw_win;
  LuaRef redraw_line;
  LuaRef redraw_end;
  LuaRef hl_def;
  int hl_valid;
} DecorProvider;

extern struct { size_t size; size_t capacity; DecorProvider *items; } decor_providers ;
extern DecorState decor_state ;
extern 
# 91 "/home/jesmith/neovim/src/nvim/decoration.h" 3 4
      _Bool 
# 91 "/home/jesmith/neovim/src/nvim/decoration.h"
           provider_active ;
# 6 "/home/jesmith/neovim/src/nvim/api/private/helpers.h" 2
# 1 "/home/jesmith/neovim/src/nvim/ex_eval.h" 1



# 1 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 1






# 1 "/home/jesmith/neovim/src/nvim/normal.h" 1
# 18 "/home/jesmith/neovim/src/nvim/normal.h"
typedef enum {
  kMTCharWise = 0,
  kMTLineWise = 1,
  kMTBlockWise = 2,
  kMTUnknown = -1,
} MotionType;




typedef struct oparg_S {
  int op_type;
  int regname;
  MotionType motion_type;
  int motion_force;
  
# 33 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 33 "/home/jesmith/neovim/src/nvim/normal.h"
      use_reg_one;

  
# 35 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 35 "/home/jesmith/neovim/src/nvim/normal.h"
      inclusive;

  
# 37 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 37 "/home/jesmith/neovim/src/nvim/normal.h"
      end_adjusted;

  pos_T start;
  pos_T end;
  pos_T cursor_start;

  long line_count;

  
# 45 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 45 "/home/jesmith/neovim/src/nvim/normal.h"
      empty;

  
# 47 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 47 "/home/jesmith/neovim/src/nvim/normal.h"
      is_VIsual;
  colnr_T start_vcol;
  colnr_T end_vcol;
  long prev_opcount;
  long prev_count0;
  
# 52 "/home/jesmith/neovim/src/nvim/normal.h" 3 4
 _Bool 
# 52 "/home/jesmith/neovim/src/nvim/normal.h"
      excl_tr_ws;

} oparg_T;




typedef struct cmdarg_S {
  oparg_T *oap;
  int prechar;
  int cmdchar;
  int nchar;
  int ncharC1;
  int ncharC2;
  int extra_char;
  long opcount;
  long count0;
  long count1;
  int arg;
  int retval;
  char_u *searchbuf;
} cmdarg_T;
# 8 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 2
# 69 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
typedef enum {
  ADDR_LINES,
  ADDR_WINDOWS,
  ADDR_ARGUMENTS,
  ADDR_LOADED_BUFFERS,
  ADDR_BUFFERS,
  ADDR_TABS,
  ADDR_TABS_RELATIVE,
  ADDR_QUICKFIX_VALID,
  ADDR_QUICKFIX,
  ADDR_UNSIGNED,
  ADDR_OTHER,
  ADDR_NONE,
} cmd_addr_T;

typedef struct exarg exarg_T;






typedef void (*ex_func_T)(exarg_T *eap);

typedef char_u *(*LineGetter)(int, void *, int, 
# 93 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
                                               _Bool
# 93 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
                                                   );


typedef struct cmdname {
  char_u *cmd_name;
  ex_func_T cmd_func;
  uint32_t cmd_argt;
  cmd_addr_T cmd_addr_type;
} CommandDefinition;




typedef struct eslist_elem eslist_T;
struct eslist_elem {
  int saved_emsg_silent;
  eslist_T *next;
};



enum {
  CSTACK_LEN = 50,
};

typedef struct {
  int cs_flags[CSTACK_LEN];
  char cs_pending[CSTACK_LEN];
  union {
    void *csp_rv[CSTACK_LEN];
    void *csp_ex[CSTACK_LEN];
  } cs_pend;
  void *cs_forinfo[CSTACK_LEN];
  int cs_line[CSTACK_LEN];
  int cs_idx;
  int cs_looplevel;
  int cs_trylevel;
  eslist_T *cs_emsg_silent_list;
  int cs_lflags;
} cstack_T;




enum {
  CSL_HAD_LOOP = 1,
  CSL_HAD_ENDLOOP = 2,
  CSL_HAD_CONT = 4,
  CSL_HAD_FINA = 8,
};


struct exarg {
  char_u *arg;
  char_u *nextcmd;
  char_u *cmd;
  char_u **cmdlinep;
  cmdidx_T cmdidx;
  uint32_t argt;
  int skip;
  int forceit;
  int addr_count;
  linenr_T line1;
  linenr_T line2;
  cmd_addr_T addr_type;
  int flags;
  char_u *do_ecmd_cmd;
  linenr_T do_ecmd_lnum;
  int append;
  int usefilter;
  int amount;
  int regname;
  int force_bin;
  int read_edit;
  int force_ff;
  int force_enc;
  int bad_char;
  int useridx;
  char *errmsg;
  LineGetter getline;
  void *cookie;
  cstack_T *cstack;
  long verbose_save;
  int save_msg_silent;
  int did_esilent;
  
# 178 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 178 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      did_sandbox;
};
# 190 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
struct expand {
  char_u *xp_pattern;
  int xp_context;
  size_t xp_pattern_len;
  char_u *xp_arg;
  sctx_T xp_script_ctx;
  int xp_backslash;

  int xp_shell;


  int xp_numfiles;
  int xp_col;
  char_u **xp_files;
  char_u *xp_line;
};
# 215 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
typedef struct {
  int split;
  int tab;
  
# 218 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 218 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      browse;
  
# 219 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 219 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      confirm;
  
# 220 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 220 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      hide;
  
# 221 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 221 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      keepalt;
  
# 222 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 222 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      keepjumps;
  
# 223 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 223 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      keepmarks;
  
# 224 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 224 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      keeppatterns;
  
# 225 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 225 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      lockmarks;
  
# 226 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 226 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      noswapfile;
  char_u *save_ei;
  regmatch_T filter_regmatch;
  
# 229 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h" 3 4
 _Bool 
# 229 "/home/jesmith/neovim/src/nvim/ex_cmds_defs.h"
      filter_force;
} cmdmod_T;
# 5 "/home/jesmith/neovim/src/nvim/ex_eval.h" 2
# 42 "/home/jesmith/neovim/src/nvim/ex_eval.h"
struct msglist {
  char *msg;
  char *throw_msg;
  struct msglist *next;
};


typedef enum
{
  ET_USER,
  ET_ERROR,
  ET_INTERRUPT,
} except_type_T;





typedef struct vim_exception except_T;
struct vim_exception {
  except_type_T type;
  char *value;
  struct msglist *messages;
  char_u *throw_name;
  linenr_T throw_lnum;
  except_T *caught;
};






typedef struct cleanup_stuff cleanup_T;
struct cleanup_stuff {
  int pending;
  except_T *exception;
};
# 7 "/home/jesmith/neovim/src/nvim/api/private/helpers.h" 2
# 1 "/home/jesmith/neovim/src/nvim/getchar.h" 1





# 1 "/home/jesmith/neovim/src/nvim/os/fileio.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/os/fileio.h" 2

# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 8 "/home/jesmith/neovim/src/nvim/os/fileio.h" 2
# 1 "/home/jesmith/neovim/src/nvim/rbuffer.h" 1
# 17 "/home/jesmith/neovim/src/nvim/rbuffer.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 18 "/home/jesmith/neovim/src/nvim/rbuffer.h" 2
# 71 "/home/jesmith/neovim/src/nvim/rbuffer.h"
typedef struct rbuffer RBuffer;



typedef void (*rbuffer_callback)(RBuffer *buf, void *data);

struct rbuffer {
  rbuffer_callback full_cb, nonfull_cb;
  void *data;
  size_t size;

  char *temp;
  char *end_ptr, *read_ptr, *write_ptr;
  char start_ptr[];
};
# 9 "/home/jesmith/neovim/src/nvim/os/fileio.h" 2


typedef struct {
  int fd;
  int _error;
  RBuffer *rv;
  
# 15 "/home/jesmith/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 15 "/home/jesmith/neovim/src/nvim/os/fileio.h"
      wr;
  
# 16 "/home/jesmith/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 16 "/home/jesmith/neovim/src/nvim/os/fileio.h"
      eof;
  
# 17 "/home/jesmith/neovim/src/nvim/os/fileio.h" 3 4
 _Bool 
# 17 "/home/jesmith/neovim/src/nvim/os/fileio.h"
      non_blocking;
} FileDescriptor;


typedef enum {
  kFileReadOnly = 1,
  kFileCreate = 2,

  kFileWriteOnly = 4,

  kFileNoSymlink = 8,
  kFileCreateOnly = 16,


  kFileTruncate = 32,


  kFileAppend = 64,

  kFileNonBlocking = 128,

} FileOpenFlags;

static inline 
# 40 "/home/jesmith/neovim/src/nvim/os/fileio.h" 3 4
             _Bool 
# 40 "/home/jesmith/neovim/src/nvim/os/fileio.h"
                  file_eof(const FileDescriptor *const fp)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));







static inline 
# 49 "/home/jesmith/neovim/src/nvim/os/fileio.h" 3 4
             _Bool 
# 49 "/home/jesmith/neovim/src/nvim/os/fileio.h"
                  file_eof(const FileDescriptor *const fp)
{
  return fp->eof && rbuffer_size(fp->rv) == 0;
}

static inline int file_fd(const FileDescriptor *const fp)
  __attribute__ ((pure)) __attribute__((warn_unused_result)) __attribute__((nonnull));






static inline int file_fd(const FileDescriptor *const fp)
{
  return fp->fd;
}

enum {



  kRWBufferSize = 1024,
};
# 7 "/home/jesmith/neovim/src/nvim/getchar.h" 2

# 1 "/home/jesmith/neovim/src/nvim/vim.h" 1
# 27 "/home/jesmith/neovim/src/nvim/vim.h"
enum { NUMBUFLEN = 65, };






# 1 "/home/jesmith/neovim/src/nvim/keymap.h" 1



# 1 "/home/jesmith/neovim/src/nvim/strings.h" 1
# 20 "/home/jesmith/neovim/src/nvim/strings.h"
static inline char *strappend(char *const dst, const char *const src)
  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT
  FUNC_ATTR_NONNULL_RET
{
  const size_t src_len = strlen(src);
  return (char *)memmove(dst, src, src_len) + src_len;
}
# 5 "/home/jesmith/neovim/src/nvim/keymap.h" 2
# 124 "/home/jesmith/neovim/src/nvim/keymap.h"
enum key_extra {
  KE_NAME = 3,

  KE_S_UP = 4,
  KE_S_DOWN = 5,

  KE_S_F1 = 6,
  KE_S_F2 = 7,
  KE_S_F3 = 8,
  KE_S_F4 = 9,
  KE_S_F5 = 10,
  KE_S_F6 = 11,
  KE_S_F7 = 12,
  KE_S_F8 = 13,
  KE_S_F9 = 14,
  KE_S_F10 = 15,

  KE_S_F11 = 16,
  KE_S_F12 = 17,
  KE_S_F13 = 18,
  KE_S_F14 = 19,
  KE_S_F15 = 20,
  KE_S_F16 = 21,
  KE_S_F17 = 22,
  KE_S_F18 = 23,
  KE_S_F19 = 24,
  KE_S_F20 = 25,

  KE_S_F21 = 26,
  KE_S_F22 = 27,
  KE_S_F23 = 28,
  KE_S_F24 = 29,
  KE_S_F25 = 30,
  KE_S_F26 = 31,
  KE_S_F27 = 32,
  KE_S_F28 = 33,
  KE_S_F29 = 34,
  KE_S_F30 = 35,

  KE_S_F31 = 36,
  KE_S_F32 = 37,
  KE_S_F33 = 38,
  KE_S_F34 = 39,
  KE_S_F35 = 40,
  KE_S_F36 = 41,
  KE_S_F37 = 42,

  KE_MOUSE = 43,



  KE_LEFTMOUSE = 44,
  KE_LEFTDRAG = 45,
  KE_LEFTRELEASE = 46,
  KE_MIDDLEMOUSE = 47,
  KE_MIDDLEDRAG = 48,
  KE_MIDDLERELEASE = 49,
  KE_RIGHTMOUSE = 50,
  KE_RIGHTDRAG = 51,
  KE_RIGHTRELEASE = 52,

  KE_IGNORE = 53,

  KE_TAB = 54,
  KE_S_TAB_OLD = 55,


  KE_XF1 = 57,
  KE_XF2 = 58,
  KE_XF3 = 59,
  KE_XF4 = 60,
  KE_XEND = 61,
  KE_ZEND = 62,
  KE_XHOME = 63,
  KE_ZHOME = 64,
  KE_XUP = 65,
  KE_XDOWN = 66,
  KE_XLEFT = 67,
  KE_XRIGHT = 68,

  KE_LEFTMOUSE_NM = 69,
  KE_LEFTRELEASE_NM = 70,

  KE_S_XF1 = 71,
  KE_S_XF2 = 72,
  KE_S_XF3 = 73,
  KE_S_XF4 = 74,




  KE_MOUSEDOWN = 75,
  KE_MOUSEUP = 76,
  KE_MOUSELEFT = 77,
  KE_MOUSERIGHT = 78,

  KE_KINS = 79,
  KE_KDEL = 80,

  KE_CSI = 81,
  KE_SNR = 82,
  KE_PLUG = 83,
  KE_CMDWIN = 84,

  KE_C_LEFT = 85,
  KE_C_RIGHT = 86,
  KE_C_HOME = 87,
  KE_C_END = 88,

  KE_X1MOUSE = 89,
  KE_X1DRAG = 90,
  KE_X1RELEASE = 91,
  KE_X2MOUSE = 92,
  KE_X2DRAG = 93,
  KE_X2RELEASE = 94,

  KE_DROP = 95,

  KE_NOP = 97,


  KE_MOUSEMOVE = 100,

  KE_EVENT = 102,
  KE_COMMAND = 104,
};
# 35 "/home/jesmith/neovim/src/nvim/vim.h" 2
# 81 "/home/jesmith/neovim/src/nvim/vim.h"
typedef enum {
  kDirectionNotSet = 0,
  FORWARD = 1,
  BACKWARD = (-1),
  FORWARD_FILE = 3,
  BACKWARD_FILE = (-3),
} Direction;
# 111 "/home/jesmith/neovim/src/nvim/vim.h"
enum {
  EXPAND_UNSUCCESSFUL = -2,
  EXPAND_OK = -1,
  EXPAND_NOTHING = 0,
  EXPAND_COMMANDS,
  EXPAND_FILES,
  EXPAND_DIRECTORIES,
  EXPAND_SETTINGS,
  EXPAND_BOOL_SETTINGS,
  EXPAND_TAGS,
  EXPAND_OLD_SETTING,
  EXPAND_HELP,
  EXPAND_BUFFERS,
  EXPAND_EVENTS,
  EXPAND_MENUS,
  EXPAND_SYNTAX,
  EXPAND_HIGHLIGHT,
  EXPAND_AUGROUP,
  EXPAND_USER_VARS,
  EXPAND_MAPPINGS,
  EXPAND_TAGS_LISTFILES,
  EXPAND_FUNCTIONS,
  EXPAND_USER_FUNC,
  EXPAND_EXPRESSION,
  EXPAND_MENUNAMES,
  EXPAND_USER_COMMANDS,
  EXPAND_USER_CMD_FLAGS,
  EXPAND_USER_NARGS,
  EXPAND_USER_COMPLETE,
  EXPAND_ENV_VARS,
  EXPAND_LANGUAGE,
  EXPAND_COLORS,
  EXPAND_COMPILER,
  EXPAND_USER_DEFINED,
  EXPAND_USER_LIST,
  EXPAND_SHELLCMD,
  EXPAND_CSCOPE,
  EXPAND_SIGN,
  EXPAND_PROFILE,
  EXPAND_BEHAVE,
  EXPAND_FILETYPE,
  EXPAND_FILES_IN_PATH,
  EXPAND_OWNSYNTAX,
  EXPAND_LOCALES,
  EXPAND_HISTORY,
  EXPAND_USER,
  EXPAND_SYNTIME,
  EXPAND_USER_ADDR_TYPE,
  EXPAND_PACKADD,
  EXPAND_MESSAGES,
  EXPAND_MAPCLEAR,
  EXPAND_ARGLIST,
  EXPAND_DIFF_BUFFERS,
  EXPAND_CHECKHEALTH,
  EXPAND_LUA,
};
# 201 "/home/jesmith/neovim/src/nvim/vim.h"
enum { FOLD_TEXT_LEN = 51, };
# 265 "/home/jesmith/neovim/src/nvim/vim.h"
# 1 "/home/jesmith/neovim/src/nvim/path.h" 1



# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 5 "/home/jesmith/neovim/src/nvim/path.h" 2
# 31 "/home/jesmith/neovim/src/nvim/path.h"
typedef enum file_comparison {
  kEqualFiles = 1,
  kDifferentFiles = 2,
  kBothFilesMissing = 4,
  kOneFileMissing = 6,
  kEqualFileNames = 7,
} FileComparison;
# 266 "/home/jesmith/neovim/src/nvim/vim.h" 2
# 304 "/home/jesmith/neovim/src/nvim/vim.h"
# 1 "/home/jesmith/neovim/src/nvim/globals.h" 1






# 1 "/home/jesmith/neovim/src/nvim/event/loop.h" 1






# 1 "/home/jesmith/neovim/src/nvim/event/multiqueue.h" 1





# 1 "/home/jesmith/neovim/src/nvim/event/defs.h" 1



# 1 "/usr/include/assert.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/event/defs.h" 2




typedef void (*argv_callback)(void **argv);
typedef struct message {
  argv_callback handler;
  void *argv[10];
} Event;
typedef void (*event_scheduler)(Event event, void *data);
# 30 "/home/jesmith/neovim/src/nvim/event/defs.h"
static inline Event event_create(argv_callback cb, int argc, ...)
{
  
# 32 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 ((void) (0))
# 32 "/home/jesmith/neovim/src/nvim/event/defs.h"
                                       ;
  Event event;
  do { 
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 ((void) (0))
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 ; (&event)->handler = cb; if (argc) { va_list args; 
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_start(
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 ,
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 argc
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 ; for (int i = 0; i < argc; i++) { (&event)->argv[i] = 
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_arg(
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 ,
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 void *
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 ; } 
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 __builtin_va_end(
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 args
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h" 3 4
 )
# 34 "/home/jesmith/neovim/src/nvim/event/defs.h"
 ; } } while (0);
  return event;
}
# 7 "/home/jesmith/neovim/src/nvim/event/multiqueue.h" 2


typedef struct multiqueue MultiQueue;
typedef void (*PutCallback)(MultiQueue *multiq, void *data);
# 8 "/home/jesmith/neovim/src/nvim/event/loop.h" 2
# 1 "/home/jesmith/neovim/src/nvim/lib/klist.h" 1
# 29 "/home/jesmith/neovim/src/nvim/lib/klist.h"
# 1 "/usr/include/assert.h" 1 3 4
# 30 "/home/jesmith/neovim/src/nvim/lib/klist.h" 2


# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 33 "/home/jesmith/neovim/src/nvim/lib/klist.h" 2
# 9 "/home/jesmith/neovim/src/nvim/event/loop.h" 2


typedef void *WatcherPtr;


struct __kl1_WatcherPtr { WatcherPtr data; struct __kl1_WatcherPtr *next; }; typedef struct __kl1_WatcherPtr kl1_WatcherPtr; typedef struct { size_t cnt, n, max; kl1_WatcherPtr **buf; } kmp_WatcherPtr_t; static inline kmp_WatcherPtr_t *kmp_init_WatcherPtr(void) { return xcalloc(1, sizeof(kmp_WatcherPtr_t)); } static inline void kmp_destroy_WatcherPtr(kmp_WatcherPtr_t *mp) __attribute__((unused)); static inline void kmp_destroy_WatcherPtr(kmp_WatcherPtr_t *mp) { size_t k; for (k = 0; k < mp->n; k++) { ; do { void **ptr_ = (void **)&(mp->buf[k]); xfree(*ptr_); *ptr_ = 
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } do { void **ptr_ = (void **)&(mp->buf); xfree(*ptr_); *ptr_ = 
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); do { void **ptr_ = (void **)&(mp); xfree(*ptr_); *ptr_ = 
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } static inline kl1_WatcherPtr *kmp_alloc_WatcherPtr(kmp_WatcherPtr_t *mp) { mp->cnt++; if (mp->n == 0) { return xcalloc(1, sizeof(kl1_WatcherPtr)); } return mp->buf[--mp->n]; } static inline void kmp_free_WatcherPtr(kmp_WatcherPtr_t *mp, kl1_WatcherPtr *p) { mp->cnt--; if (mp->n == mp->max) { mp->max = mp->max ? (mp->max << 1) : 16; mp->buf = xrealloc(mp->buf, sizeof(kl1_WatcherPtr *) * mp->max); } mp->buf[mp->n++] = p; } typedef struct { kl1_WatcherPtr *head, *tail; kmp_WatcherPtr_t *mp; size_t size; } kl_WatcherPtr_t; static inline kl_WatcherPtr_t *kl_init_WatcherPtr(void) { kl_WatcherPtr_t *kl = xcalloc(1, sizeof(kl_WatcherPtr_t)); kl->mp = kmp_init_WatcherPtr(); kl->head = kl->tail = kmp_alloc_WatcherPtr(kl->mp); kl->head->next = 0; return kl; } static inline void kl_destroy_WatcherPtr(kl_WatcherPtr_t *kl) __attribute__((unused)); static inline void kl_destroy_WatcherPtr(kl_WatcherPtr_t *kl) { kl1_WatcherPtr *p; for (p = kl->head; p != kl->tail; p = p->next) { kmp_free_WatcherPtr(kl->mp, p); } kmp_free_WatcherPtr(kl->mp, p); kmp_destroy_WatcherPtr(kl->mp); do { void **ptr_ = (void **)&(kl); xfree(*ptr_); *ptr_ = 
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h" 3 4
((void *)0)
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h"
; (void)(*ptr_); } while (0); } static inline void kl_push_WatcherPtr(kl_WatcherPtr_t *kl, WatcherPtr d) { kl1_WatcherPtr *q, *p = kmp_alloc_WatcherPtr(kl->mp); q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p; kl->size++; q->data = d; } static inline WatcherPtr kl_shift_at_WatcherPtr(kl_WatcherPtr_t *kl, kl1_WatcherPtr **n) { 
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h" 3 4
((void) (0))
# 14 "/home/jesmith/neovim/src/nvim/event/loop.h"
; kl1_WatcherPtr *p; kl->size--; p = *n; *n = (*n)->next; if (p == kl->head) { kl->head = *n; } WatcherPtr d = p->data; kmp_free_WatcherPtr(kl->mp, p); return d; }

typedef struct loop {
  uv_loop_t uv;
  MultiQueue *events;
  MultiQueue *thread_events;
# 29 "/home/jesmith/neovim/src/nvim/event/loop.h"
  MultiQueue *fast_events;


  kl_WatcherPtr_t *children;
  uv_signal_t children_watcher;
  uv_timer_t children_kill_timer;


  uv_timer_t poll_timer;

  uv_async_t async;
  uv_mutex_t mutex;
  int recursive;
} Loop;
# 8 "/home/jesmith/neovim/src/nvim/globals.h" 2




# 1 "/home/jesmith/neovim/src/nvim/menu.h" 1
# 13 "/home/jesmith/neovim/src/nvim/globals.h" 2
# 75 "/home/jesmith/neovim/src/nvim/globals.h"
extern struct nvim_stats_s {
  int64_t fsync;
  int64_t redraw;
} g_stats ;
# 92 "/home/jesmith/neovim/src/nvim/globals.h"
extern int Rows ;
extern int Columns ;

extern NS ns_hl_active ;
extern 
# 96 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 96 "/home/jesmith/neovim/src/nvim/globals.h"
           ns_hl_changed ;
# 115 "/home/jesmith/neovim/src/nvim/globals.h"
typedef off_t off_T;
# 129 "/home/jesmith/neovim/src/nvim/globals.h"
extern int mod_mask ;
# 139 "/home/jesmith/neovim/src/nvim/globals.h"
extern int cmdline_row;

extern 
# 141 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 141 "/home/jesmith/neovim/src/nvim/globals.h"
           redraw_cmdline ;
extern 
# 142 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 142 "/home/jesmith/neovim/src/nvim/globals.h"
           clear_cmdline ;
extern 
# 143 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 143 "/home/jesmith/neovim/src/nvim/globals.h"
           mode_displayed ;
extern int cmdline_star ;
extern 
# 145 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 145 "/home/jesmith/neovim/src/nvim/globals.h"
           redrawing_cmdline ;
extern 
# 146 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 146 "/home/jesmith/neovim/src/nvim/globals.h"
           cmdline_was_last_drawn ;

extern 
# 148 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 148 "/home/jesmith/neovim/src/nvim/globals.h"
           exec_from_reg ;





extern colnr_T dollar_vcol ;





extern int compl_length ;



extern int compl_interrupted ;



extern 
# 168 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 168 "/home/jesmith/neovim/src/nvim/globals.h"
           compl_busy ;


extern int compl_cont_status ;
# 183 "/home/jesmith/neovim/src/nvim/globals.h"
extern char_u *edit_submode ;
extern char_u *edit_submode_pre ;
extern char_u *edit_submode_extra ;
extern hlf_T edit_submode_highl;


extern int cmdmsg_rl ;
extern int msg_col;
extern int msg_row;
extern int msg_scrolled;



extern 
# 196 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 196 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_scrolled_ign ;


extern 
# 199 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 199 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_did_scroll ;


extern char_u *keep_msg ;
extern int keep_msg_attr ;
extern 
# 204 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 204 "/home/jesmith/neovim/src/nvim/globals.h"
           keep_msg_more ;
extern 
# 205 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 205 "/home/jesmith/neovim/src/nvim/globals.h"
           need_fileinfo ;
extern int msg_scroll ;
extern 
# 207 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 207 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_didout ;
extern 
# 208 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 208 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_didany ;
extern 
# 209 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 209 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_nowait ;
extern int emsg_off ;

extern 
# 212 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 212 "/home/jesmith/neovim/src/nvim/globals.h"
           info_message ;
extern 
# 213 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 213 "/home/jesmith/neovim/src/nvim/globals.h"
           msg_hist_off ;
extern 
# 214 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 214 "/home/jesmith/neovim/src/nvim/globals.h"
           need_clr_eos ;

extern int emsg_skip ;

extern 
# 218 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 218 "/home/jesmith/neovim/src/nvim/globals.h"
           emsg_severe ;

extern 
# 220 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 220 "/home/jesmith/neovim/src/nvim/globals.h"
           did_endif ;
extern dict_T vimvardict;
extern dict_T globvardict;


extern int did_emsg;

extern 
# 227 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 227 "/home/jesmith/neovim/src/nvim/globals.h"
           called_vim_beep;
extern 
# 228 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 228 "/home/jesmith/neovim/src/nvim/globals.h"
           did_emsg_syntax;

extern int called_emsg;
extern int ex_exitval ;
extern 
# 232 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 232 "/home/jesmith/neovim/src/nvim/globals.h"
           emsg_on_display ;
extern 
# 233 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 233 "/home/jesmith/neovim/src/nvim/globals.h"
           rc_did_emsg ;

extern int no_wait_return ;
extern 
# 236 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 236 "/home/jesmith/neovim/src/nvim/globals.h"
           need_wait_return ;
extern 
# 237 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 237 "/home/jesmith/neovim/src/nvim/globals.h"
           did_wait_return ;

extern 
# 239 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 239 "/home/jesmith/neovim/src/nvim/globals.h"
           need_maketitle ;

extern int quit_more ;
extern int vgetc_busy ;

extern 
# 244 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 244 "/home/jesmith/neovim/src/nvim/globals.h"
           didset_vim ;
extern 
# 245 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 245 "/home/jesmith/neovim/src/nvim/globals.h"
           didset_vimruntime ;



extern int lines_left ;
extern int msg_no_more ;


extern char_u *sourcing_name ;
extern linenr_T sourcing_lnum ;

extern int ex_nesting_level ;
extern int debug_break_level ;
extern 
# 258 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 258 "/home/jesmith/neovim/src/nvim/globals.h"
           debug_did_msg ;
extern int debug_tick ;
extern int debug_backtrace_level ;





extern int do_profiling ;




extern except_T *current_exception;



extern int need_rethrow ;



extern int check_cstack ;



extern int trylevel ;







extern int force_abort ;
# 301 "/home/jesmith/neovim/src/nvim/globals.h"
extern struct msglist **msg_list ;





extern 
# 307 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 307 "/home/jesmith/neovim/src/nvim/globals.h"
           suppress_errthrow ;





extern except_T *caught_stack ;
# 324 "/home/jesmith/neovim/src/nvim/globals.h"
extern 
# 324 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 324 "/home/jesmith/neovim/src/nvim/globals.h"
           may_garbage_collect ;
extern int want_garbage_collect ;
extern int garbage_collect_at_exit ;
# 341 "/home/jesmith/neovim/src/nvim/globals.h"
extern sctx_T current_sctx ;

extern uint64_t current_channel_id ;

extern 
# 345 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 345 "/home/jesmith/neovim/src/nvim/globals.h"
           did_source_packages ;



extern struct caller_scope {
  sctx_T script_ctx;
  uint8_t *sourcing_name, *autocmd_fname, *autocmd_match;
  linenr_T sourcing_lnum;
  int autocmd_bufnr;
  void *funccalp;
} provider_caller_scope;
extern int provider_call_nesting ;


extern int t_colors ;





extern 
# 365 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 365 "/home/jesmith/neovim/src/nvim/globals.h"
           highlight_match ;
extern linenr_T search_match_lines;
extern colnr_T search_match_endcol;
extern linenr_T search_first_line ;
extern linenr_T search_last_line ;

extern 
# 371 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 371 "/home/jesmith/neovim/src/nvim/globals.h"
           no_smartcase ;

extern int need_check_timestamps ;

extern int did_check_timestamps ;

extern int no_check_timestamps ;

extern int autocmd_busy ;
extern int autocmd_no_enter ;
extern int autocmd_no_leave ;
extern int modified_was_set;
extern int did_filetype ;

extern int keep_filetype ;



extern bufref_T au_new_curbuf ;





extern buf_T *au_pending_free_buf ;
extern win_T *au_pending_free_win ;


extern int mouse_grid;
extern int mouse_row;
extern int mouse_col;
extern 
# 402 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 402 "/home/jesmith/neovim/src/nvim/globals.h"
           mouse_past_bottom ;
extern 
# 403 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 403 "/home/jesmith/neovim/src/nvim/globals.h"
           mouse_past_eol ;
extern int mouse_dragging ;



extern vimmenu_T *root_menu ;


extern int sys_menu ;



extern int updating_screen ;




extern win_T *firstwin;
extern win_T *lastwin;
extern win_T *prevwin ;
# 438 "/home/jesmith/neovim/src/nvim/globals.h"
extern win_T *curwin;

extern win_T *aucmd_win;
extern int aucmd_win_used ;



extern frame_T *topframe;



extern tabpage_T *first_tabpage;
extern tabpage_T *lastused_tabpage;
extern tabpage_T *curtab;
extern 
# 452 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 452 "/home/jesmith/neovim/src/nvim/globals.h"
           redraw_tabline ;






extern buf_T *firstbuf ;
extern buf_T *lastbuf ;
extern buf_T *curbuf ;
# 476 "/home/jesmith/neovim/src/nvim/globals.h"
extern alist_T global_alist;
extern int max_alist_id ;
extern 
# 478 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 478 "/home/jesmith/neovim/src/nvim/globals.h"
           arg_had_last ;


extern int ru_col;
extern int ru_wid;
extern int sc_col;





extern int starting ;

extern 
# 491 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 491 "/home/jesmith/neovim/src/nvim/globals.h"
           exiting ;

extern int v_dying ;

extern int stdin_isatty ;

extern int stdout_isatty ;


extern volatile int full_screen ;



extern int secure ;



extern int textlock ;



extern int allbuf_lock ;



extern int sandbox ;


extern int silent_mode ;


extern pos_T VIsual;

extern int VIsual_active ;

extern int VIsual_select ;

extern int restart_VIsual_select ;

extern int VIsual_reselect;

extern int VIsual_mode ;

extern int redo_VIsual_busy ;



extern pos_T where_paste_started;





extern 
# 544 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 544 "/home/jesmith/neovim/src/nvim/globals.h"
           did_ai ;



extern colnr_T ai_col ;





extern int end_comment_pending ;





extern 
# 560 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 560 "/home/jesmith/neovim/src/nvim/globals.h"
           did_syncbind ;



extern 
# 564 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 564 "/home/jesmith/neovim/src/nvim/globals.h"
           did_si ;



extern 
# 568 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 568 "/home/jesmith/neovim/src/nvim/globals.h"
           can_si ;



extern 
# 572 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 572 "/home/jesmith/neovim/src/nvim/globals.h"
           can_si_back ;


extern pos_T saved_cursor ;


extern pos_T Insstart;





extern pos_T Insstart_orig;


extern int orig_line_count ;
extern int vr_lines_changed ;


extern int inhibit_delete_count ;
# 608 "/home/jesmith/neovim/src/nvim/globals.h"
extern char_u *fenc_default ;
# 617 "/home/jesmith/neovim/src/nvim/globals.h"
extern int State ;

extern 
# 619 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 619 "/home/jesmith/neovim/src/nvim/globals.h"
           debug_mode ;
extern 
# 620 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 620 "/home/jesmith/neovim/src/nvim/globals.h"
           finish_op ;
extern long opcount ;
extern int motion_force ;


extern 
# 625 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 625 "/home/jesmith/neovim/src/nvim/globals.h"
           exmode_active ;
extern 
# 626 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 626 "/home/jesmith/neovim/src/nvim/globals.h"
           ex_no_reprint ;

extern int reg_recording ;
extern int reg_executing ;

extern int no_mapping ;
extern int no_zero_mapping ;
extern int no_u_sync ;
extern int u_sync_once ;


extern 
# 637 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 637 "/home/jesmith/neovim/src/nvim/globals.h"
           force_restart_edit ;

extern int restart_edit ;
extern int arrow_used;



extern 
# 644 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 644 "/home/jesmith/neovim/src/nvim/globals.h"
           ins_at_eol ;


extern 
# 647 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 647 "/home/jesmith/neovim/src/nvim/globals.h"
           no_abbr ;

extern int mapped_ctrl_c ;

extern cmdmod_T cmdmod;

extern int msg_silent ;
extern int emsg_silent ;
extern 
# 655 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 655 "/home/jesmith/neovim/src/nvim/globals.h"
           emsg_noredir ;
extern 
# 656 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 656 "/home/jesmith/neovim/src/nvim/globals.h"
           cmd_silent ;







extern int swap_exists_action ;


extern 
# 667 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 667 "/home/jesmith/neovim/src/nvim/globals.h"
           swap_exists_did_quit ;


extern char_u IObuff[(1024+1)];
extern char_u NameBuff[4096];
extern char msg_buf[480];
extern char os_buf[

                                            4096



];


extern int RedrawingDisabled ;

extern int readonlymode ;
extern int recoverymode ;


extern typebuf_T typebuf ;

extern int ex_normal_busy ;
extern int ex_normal_lock ;
extern int ignore_script ;
extern int stop_insert_mode;
extern 
# 694 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 694 "/home/jesmith/neovim/src/nvim/globals.h"
           KeyTyped;
extern int KeyStuffed;
extern int maptick ;

extern int must_redraw ;
extern 
# 699 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 699 "/home/jesmith/neovim/src/nvim/globals.h"
           skip_redraw ;
extern 
# 700 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 700 "/home/jesmith/neovim/src/nvim/globals.h"
           do_redraw ;
extern 
# 701 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 701 "/home/jesmith/neovim/src/nvim/globals.h"
           must_redraw_pum ;


extern 
# 704 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 704 "/home/jesmith/neovim/src/nvim/globals.h"
           need_highlight_changed ;

extern FILE *scriptout ;


extern volatile int got_int ;

extern 
# 711 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 711 "/home/jesmith/neovim/src/nvim/globals.h"
           bangredo ;
extern int searchcmdlen;
extern int reg_do_extmatch ;



extern reg_extmatch_T *re_extmatch_in ;

extern reg_extmatch_T *re_extmatch_out ;

extern 
# 721 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 721 "/home/jesmith/neovim/src/nvim/globals.h"
           did_outofmem_msg ;

extern 
# 723 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 723 "/home/jesmith/neovim/src/nvim/globals.h"
           did_swapwrite_msg ;

extern int global_busy ;
extern 
# 726 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 726 "/home/jesmith/neovim/src/nvim/globals.h"
           listcmd_busy ;

extern 
# 728 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 728 "/home/jesmith/neovim/src/nvim/globals.h"
           need_start_insertmode ;

extern char *last_mode ;
extern char_u *last_cmdline ;
extern char_u *repeat_cmdline ;
extern char_u *new_last_cmdline ;
extern char_u *autocmd_fname ;
extern int autocmd_bufnr ;
extern char_u *autocmd_match ;
extern 
# 737 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 737 "/home/jesmith/neovim/src/nvim/globals.h"
           did_cursorhold ;

extern int postponed_split ;
extern int postponed_split_flags ;
extern int postponed_split_tab ;
extern int g_do_tagpreview ;

extern 
# 744 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 744 "/home/jesmith/neovim/src/nvim/globals.h"
           g_tag_at_cursor ;



extern int replace_offset ;

extern char_u *escape_chars ;


extern int keep_help_flag ;




extern char_u *empty_option ;

extern 
# 760 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 760 "/home/jesmith/neovim/src/nvim/globals.h"
           redir_off ;
extern FILE *redir_fd ;
extern int redir_reg ;
extern int redir_vname ;
extern garray_T *capture_ga ;

extern char_u langmap_mapchar[256];

extern int save_p_ls ;
extern int save_p_wmh ;
extern int wild_menu_showing ;
enum {
  WM_SHOWN = 1,
  WM_SCROLLED = 2,
  WM_LIST = 3,
};





extern char *default_vim_dir;
extern char *default_vimruntime_dir;
extern char *default_lib_dir;
extern char_u *compiled_user;
extern char_u *compiled_sys;





extern char_u *globaldir ;

extern char *last_chdir_reason ;


extern 
# 796 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 796 "/home/jesmith/neovim/src/nvim/globals.h"
           km_stopsel ;
extern 
# 797 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 797 "/home/jesmith/neovim/src/nvim/globals.h"
           km_startsel ;

extern int cedit_key ;
extern int cmdwin_type ;
extern int cmdwin_result ;
extern int cmdwin_level ;

extern char_u no_lines_msg[] ;




extern long sub_nsubs;
extern linenr_T sub_nlines;


extern char_u wim_flags[4];




extern int stl_syntax ;


extern 
# 821 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 821 "/home/jesmith/neovim/src/nvim/globals.h"
           no_hlsearch ;


extern linenr_T printer_page_num;


extern 
# 827 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 827 "/home/jesmith/neovim/src/nvim/globals.h"
           typebuf_was_filled ;
# 839 "/home/jesmith/neovim/src/nvim/globals.h"
extern TriState virtual_op ;


extern disptick_T display_tick ;



extern linenr_T spell_redraw_lnum ;





extern char e_abort[] ;
extern char e_afterinit[] ;
extern char e_api_spawn_failed[] ;
extern char e_argreq[] ;
extern char e_backslash[] ;
extern char e_cmdwin[] ;
extern char e_curdir[] ;
extern char e_endif[] ;
extern char e_endtry[] ;
extern char e_endwhile[] ;
extern char e_endfor[] ;
extern char e_while[] ;
extern char e_for[] ;
extern char e_exists[] ;
extern char e_failed[] ;
extern char e_internal[] ;
extern char e_intern2[] ;
extern char e_interr[] ;
extern char e_invarg[] ;
extern char e_invarg2[] ;
extern char e_invargval[] ;
extern char e_invargNval[] ;
extern char e_duparg2[] ;
extern char e_invexpr2[] ;
extern char e_invrange[] ;
extern char e_invcmd[] ;
extern char e_isadir2[] ;
extern char e_no_spell[] ;
extern char e_invchan[] ;
extern char e_invchanjob[] ;
extern char e_jobtblfull[] ;
extern char e_jobspawn[] ;
extern char e_channotpty[] ;
extern char e_stdiochan2[] ;
extern char e_invstream[] ;
extern char e_invstreamrpc[] ;
extern char e_streamkey[] ;
extern char e_libcall[] ;
extern char e_fsync[] ;
extern char e_mkdir[] ;
extern char e_markinval[] ;
extern char e_marknotset[] ;
extern char e_modifiable[] ;
extern char e_nesting[] ;
extern char e_noalt[] ;
extern char e_noabbr[] ;
extern char e_nobang[] ;
extern char e_nogroup[] ;
extern char e_noinstext[] ;
extern char e_nolastcmd[] ;
extern char e_nomap[] ;
extern char e_nomatch[] ;
extern char e_nomatch2[] ;
extern char e_noname[] ;
extern char e_nopresub[] ;
extern char e_noprev[] ;
extern char e_noprevre[] ;
extern char e_norange[] ;
extern char e_noroom[] ;
extern char e_notmp[] ;
extern char e_notopen[] ;
extern char e_notopen_2[] ;
extern char e_notread[] ;
extern char e_null[] ;
extern char e_number_exp[] ;
extern char e_openerrf[] ;
extern char e_outofmem[] ;
extern char e_patnotf[] ;
extern char e_patnotf2[] ;
extern char e_positive[] ;
extern char e_prev_dir[] ;

extern char e_quickfix[] ;
extern char e_loclist[] ;
extern char e_re_damg[] ;
extern char e_re_corr[] ;
extern char e_readonly[] ;
extern char e_readonlyvar[] ;
extern char e_stringreq[] ;
extern char e_dictreq[] ;
extern char e_blobidx[] ;
extern char e_invalblob[] ;
extern char e_toomanyarg[] ;
extern char e_dictkey[] ;
extern char e_listreq[] ;
extern char e_listblobreq[] ;
extern char e_listdictarg[] ;
extern char e_listdictblobarg[] ;
extern char e_readerrf[] ;
extern char e_sandbox[] ;
extern char e_secure[] ;
extern char e_screenmode[] ;
extern char e_scroll[] ;
extern char e_shellempty[] ;
extern char e_signdata[] ;
extern char e_swapclose[] ;
extern char e_tagstack[] ;
extern char e_toocompl[] ;
extern char e_longname[] ;
extern char e_toomsbra[] ;
extern char e_toomany[] ;
extern char e_trailing[] ;
extern char e_trailing2[] ;
extern char e_umark[] ;
extern char e_wildexpand[] ;
extern char e_winheight[] ;
extern char e_winwidth[] ;
extern char e_write[] ;
extern char e_zerocount[] ;
extern char e_usingsid[] ;
extern char e_missingparen[] ;
extern char e_maxmempat[] ;
extern char e_emptybuf[] ;
extern char e_nobufnr[] ;

extern char e_invalpat[] ;
extern char e_bufloaded[] ;
extern char e_notset[] ;
extern char e_invalidreg[] ;
extern char e_dirnotf[] ;
extern char e_au_recursive[] ;
extern char e_autocmd_close[] ;
extern char e_unsupportedoption[] ;
extern char e_fnametoolong[] ;
extern char e_float_as_string[] ;

extern char e_autocmd_err[] ;
extern char e_cmdmap_err[] ;
extern char e_cmdmap_repeated[] ;
extern char e_cmdmap_key[] ;

extern char e_api_error[] ;

extern char e_luv_api_disabled[] ;

extern char e_floatonly[] ;
extern char e_floatexchange[] ;

extern char e_non_empty_string_required[] ;

extern char e_cannot_define_autocommands_for_all_events[] ;

extern char top_bot_msg[] ;
extern char bot_top_msg[] ;

extern char line_msg[] ;


extern time_t starttime;

extern FILE *time_fd ;




extern int vim_ignored;


extern 
# 1010 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 1010 "/home/jesmith/neovim/src/nvim/globals.h"
           embedded_mode ;

extern 
# 1012 "/home/jesmith/neovim/src/nvim/globals.h" 3 4
      _Bool 
# 1012 "/home/jesmith/neovim/src/nvim/globals.h"
           headless_mode ;





typedef enum {
  kUnknown,
  kWorking,
  kBroken,
} WorkingStatus;







typedef enum {
  kCdScopeInvalid = -1,
  kCdScopeWindow,
  kCdScopeTabpage,
  kCdScopeGlobal,
} CdScope;





typedef enum {
  kCdCauseOther = -1,
  kCdCauseManual,
  kCdCauseWindow,
  kCdCauseAuto,
} CdCause;


extern char windowsVersion[20] ;
# 305 "/home/jesmith/neovim/src/nvim/vim.h" 2
# 9 "/home/jesmith/neovim/src/nvim/getchar.h" 2




enum RemapValues {
  REMAP_YES = 0,
  REMAP_NONE = -1,
  REMAP_SCRIPT = -2,
  REMAP_SKIP = -3,
};


typedef enum {
  FLUSH_MINIMAL,
  FLUSH_TYPEAHEAD,
  FLUSH_INPUT,
} flush_buffers_T;
# 34 "/home/jesmith/neovim/src/nvim/getchar.h"
struct map_arguments {
  
# 35 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 35 "/home/jesmith/neovim/src/nvim/getchar.h"
      buffer;
  
# 36 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 36 "/home/jesmith/neovim/src/nvim/getchar.h"
      expr;
  
# 37 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 37 "/home/jesmith/neovim/src/nvim/getchar.h"
      noremap;
  
# 38 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 38 "/home/jesmith/neovim/src/nvim/getchar.h"
      nowait;
  
# 39 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 39 "/home/jesmith/neovim/src/nvim/getchar.h"
      script;
  
# 40 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 40 "/home/jesmith/neovim/src/nvim/getchar.h"
      silent;
  
# 41 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 41 "/home/jesmith/neovim/src/nvim/getchar.h"
      unique;






  char_u lhs[50 + 1];
  size_t lhs_len;

  char_u *rhs;
  size_t rhs_len;
  
# 53 "/home/jesmith/neovim/src/nvim/getchar.h" 3 4
 _Bool 
# 53 "/home/jesmith/neovim/src/nvim/getchar.h"
      rhs_is_noop;

  char_u *orig_rhs;
  size_t orig_rhs_len;
};
typedef struct map_arguments MapArguments;







enum { NSCRIPT = 15, };


extern FileDescriptor *scriptin[NSCRIPT];
# 8 "/home/jesmith/neovim/src/nvim/api/private/helpers.h" 2
# 105 "/home/jesmith/neovim/src/nvim/api/private/helpers.h"
extern Map_handle_T_ptr_t buffer_handles ;
extern Map_handle_T_ptr_t window_handles ;
extern Map_handle_T_ptr_t tabpage_handles ;
# 117 "/home/jesmith/neovim/src/nvim/api/private/helpers.h"
typedef struct {
  except_T *current_exception;
  struct msglist *private_msg_list;
  const struct msglist *const *msg_list;
  int trylevel;
  int got_int;
  int need_rethrow;
  int did_emsg;
} TryState;
# 9 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/api/vim.h" 1
# 10 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/ascii.h" 1





# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 7 "/home/jesmith/neovim/src/nvim/ascii.h" 2
# 88 "/home/jesmith/neovim/src/nvim/ascii.h"
static inline 
# 88 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 88 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_iswhite(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 92 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 92 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_iswhite_or_nul(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 96 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 96 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 100 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 100 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isxdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 104 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 104 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isident(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 108 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 108 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isbdigit(int)
  __attribute__((const))
  __attribute__((always_inline));

static inline 
# 112 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 112 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isspace(int)
  __attribute__((const))
  __attribute__((always_inline));




static inline 
# 119 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 119 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_iswhite(int c)
{
  return c == ' ' || c == '\t';
}




static inline 
# 127 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 127 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_iswhite_or_nul(int c)
{
  return ascii_iswhite(c) || c == '\000';
}
# 141 "/home/jesmith/neovim/src/nvim/ascii.h"
static inline 
# 141 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 141 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isdigit(int c)
{
  return c >= '0' && c <= '9';
}




static inline 
# 149 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 149 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isxdigit(int c)
{
  return (c >= '0' && c <= '9')
         || (c >= 'a' && c <= 'f')
         || (c >= 'A' && c <= 'F');
}




static inline 
# 159 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 159 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isident(int c)
{
  return ((((unsigned)(c) >= 'A' && (unsigned)(c) <= 'Z') || ((unsigned)(c) >= 'a' && (unsigned)(c) <= 'z')) || ascii_isdigit(c)) || c == '_';
}




static inline 
# 167 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 167 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isbdigit(int c)
{
  return (c == '0' || c == '1');
}




static inline 
# 175 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 175 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isodigit(int c)
{
  return (c >= '0' && c <= '7');
}





static inline 
# 184 "/home/jesmith/neovim/src/nvim/ascii.h" 3 4
             _Bool 
# 184 "/home/jesmith/neovim/src/nvim/ascii.h"
                  ascii_isspace(int c)
{
  return (c >= 9 && c <= 13) || c == ' ';
}
# 11 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/assert.h" 1
# 12 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/buffer.h" 1



# 1 "/home/jesmith/neovim/src/nvim/eval.h" 1




# 1 "/home/jesmith/neovim/src/nvim/channel.h" 1




# 1 "/home/jesmith/neovim/src/nvim/event/libuv_process.h" 1





# 1 "/home/jesmith/neovim/src/nvim/event/process.h" 1





# 1 "/home/jesmith/neovim/src/nvim/event/rstream.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/event/rstream.h" 2



# 1 "/home/jesmith/neovim/src/nvim/event/stream.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/event/stream.h" 2





typedef struct stream Stream;







typedef void (*stream_read_cb)(Stream *stream, RBuffer *buf, size_t count,
                               void *data, 
# 20 "/home/jesmith/neovim/src/nvim/event/stream.h" 3 4
                                          _Bool 
# 20 "/home/jesmith/neovim/src/nvim/event/stream.h"
                                               eof);







typedef void (*stream_write_cb)(Stream *stream, void *data, int status);
typedef void (*stream_close_cb)(Stream *stream, void *data);

struct stream {
  
# 32 "/home/jesmith/neovim/src/nvim/event/stream.h" 3 4
 _Bool 
# 32 "/home/jesmith/neovim/src/nvim/event/stream.h"
      closed;
  
# 33 "/home/jesmith/neovim/src/nvim/event/stream.h" 3 4
 _Bool 
# 33 "/home/jesmith/neovim/src/nvim/event/stream.h"
      did_eof;
  union {
    uv_pipe_t pipe;
    uv_tcp_t tcp;
    uv_idle_t idle;



  } uv;
  uv_stream_t *uvstream;
  uv_buf_t uvbuf;
  RBuffer *buffer;
  uv_file fd;
  stream_read_cb read_cb;
  stream_write_cb write_cb;
  void *cb_data;
  stream_close_cb close_cb, internal_close_cb;
  void *close_cb_data, *internal_data;
  size_t fpos;
  size_t curmem;
  size_t maxmem;
  size_t pending_reqs;
  size_t num_bytes;
  MultiQueue *events;
};
# 10 "/home/jesmith/neovim/src/nvim/event/rstream.h" 2
# 7 "/home/jesmith/neovim/src/nvim/event/process.h" 2
# 1 "/home/jesmith/neovim/src/nvim/event/wstream.h" 1
# 11 "/home/jesmith/neovim/src/nvim/event/wstream.h"
typedef struct wbuffer WBuffer;
typedef void (*wbuffer_data_finalizer)(void *data);

struct wbuffer {
  size_t size, refcount;
  char *data;
  wbuffer_data_finalizer cb;
};
# 8 "/home/jesmith/neovim/src/nvim/event/process.h" 2

typedef enum {
  kProcessTypeUv,
  kProcessTypePty,
} ProcessType;

typedef struct process Process;
typedef void (*process_exit_cb)(Process *proc, int status, void *data);
typedef void (*internal_process_cb)(Process *proc);

struct process {
  ProcessType type;
  Loop *loop;
  void *data;
  int pid, status, refcount;
  uint8_t exit_signal;
  uint64_t stopped_time;
  const char *cwd;
  char **argv;
  dict_T *env;
  Stream in, out, err;

  process_exit_cb cb;
  internal_process_cb internal_exit_cb, internal_close_cb;
  
# 32 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
 _Bool 
# 32 "/home/jesmith/neovim/src/nvim/event/process.h"
      closed, detach, overlapped;
  MultiQueue *events;
};


static inline Process process_init(Loop *loop, ProcessType type, void *data)
{
  return (Process) {
    .type = type,
    .data = data,
    .loop = loop,
    .events = 
# 43 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
             ((void *)0)
# 43 "/home/jesmith/neovim/src/nvim/event/process.h"
                 ,
    .pid = 0,
    .status = -1,
    .refcount = 0,
    .stopped_time = 0,
    .cwd = 
# 48 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
          ((void *)0)
# 48 "/home/jesmith/neovim/src/nvim/event/process.h"
              ,
    .argv = 
# 49 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
           ((void *)0)
# 49 "/home/jesmith/neovim/src/nvim/event/process.h"
               ,
    .in = { .closed = 
# 50 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
                     0 
# 50 "/home/jesmith/neovim/src/nvim/event/process.h"
                           },
    .out = { .closed = 
# 51 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
                      0 
# 51 "/home/jesmith/neovim/src/nvim/event/process.h"
                            },
    .err = { .closed = 
# 52 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
                      0 
# 52 "/home/jesmith/neovim/src/nvim/event/process.h"
                            },
    .cb = 
# 53 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
         ((void *)0)
# 53 "/home/jesmith/neovim/src/nvim/event/process.h"
             ,
    .closed = 
# 54 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
             0
# 54 "/home/jesmith/neovim/src/nvim/event/process.h"
                  ,
    .internal_close_cb = 
# 55 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
                        ((void *)0)
# 55 "/home/jesmith/neovim/src/nvim/event/process.h"
                            ,
    .internal_exit_cb = 
# 56 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
                       ((void *)0)
# 56 "/home/jesmith/neovim/src/nvim/event/process.h"
                           ,
    .detach = 
# 57 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
             0
  
# 58 "/home/jesmith/neovim/src/nvim/event/process.h"
 };
}

static inline 
# 61 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
             _Bool 
# 61 "/home/jesmith/neovim/src/nvim/event/process.h"
                  process_is_stopped(Process *proc)
{
  
# 63 "/home/jesmith/neovim/src/nvim/event/process.h" 3 4
 _Bool 
# 63 "/home/jesmith/neovim/src/nvim/event/process.h"
      exited = (proc->status >= 0);
  return exited || (proc->stopped_time != 0);
}
# 7 "/home/jesmith/neovim/src/nvim/event/libuv_process.h" 2

typedef struct libuv_process {
  Process process;
  uv_process_t uv;
  uv_process_options_t uvopts;
  uv_stdio_container_t uvstdio[3];
} LibuvProcess;

static inline LibuvProcess libuv_process_init(Loop *loop, void *data)
{
  LibuvProcess rv = {
    .process = process_init(loop, kProcessTypeUv, data)
  };
  return rv;
}
# 6 "/home/jesmith/neovim/src/nvim/channel.h" 2

# 1 "/home/jesmith/neovim/src/nvim/event/socket.h" 1
# 12 "/home/jesmith/neovim/src/nvim/event/socket.h"
typedef struct socket_watcher SocketWatcher;
typedef void (*socket_cb)(SocketWatcher *watcher, int result, void *data);
typedef void (*socket_close_cb)(SocketWatcher *watcher, void *data);

struct socket_watcher {

  char addr[256];

  union {
    struct {
      uv_tcp_t handle;
      struct addrinfo *addrinfo;
    } tcp;
    struct {
      uv_pipe_t handle;
    } pipe;
  } uv;
  uv_stream_t *stream;
  void *data;
  socket_cb cb;
  socket_close_cb close_cb;
  MultiQueue *events;
};
# 8 "/home/jesmith/neovim/src/nvim/channel.h" 2
# 1 "/home/jesmith/neovim/src/nvim/main.h" 1
# 10 "/home/jesmith/neovim/src/nvim/main.h"
extern Loop main_loop;


typedef struct {
  int argc;
  char **argv;

  char *use_vimrc;
  
# 18 "/home/jesmith/neovim/src/nvim/main.h" 3 4
 _Bool 
# 18 "/home/jesmith/neovim/src/nvim/main.h"
      clean;

  int n_commands;
  char *commands[10];
  char_u cmds_tofree[10];
  int n_pre_commands;
  char *pre_commands[10];

  int edit_type;
  char_u *tagname;
  char_u *use_ef;

  
# 30 "/home/jesmith/neovim/src/nvim/main.h" 3 4
 _Bool 
# 30 "/home/jesmith/neovim/src/nvim/main.h"
      input_isatty;
  
# 31 "/home/jesmith/neovim/src/nvim/main.h" 3 4
 _Bool 
# 31 "/home/jesmith/neovim/src/nvim/main.h"
      output_isatty;
  
# 32 "/home/jesmith/neovim/src/nvim/main.h" 3 4
 _Bool 
# 32 "/home/jesmith/neovim/src/nvim/main.h"
      err_isatty;
  
# 33 "/home/jesmith/neovim/src/nvim/main.h" 3 4
 _Bool 
# 33 "/home/jesmith/neovim/src/nvim/main.h"
      input_neverscript;
  int no_swap_file;
  int use_debug_break_level;
  int window_count;
  int window_layout;

  int diff_mode;

  char *listen_addr;
} mparm_T;
# 9 "/home/jesmith/neovim/src/nvim/channel.h" 2
# 1 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 1
# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/util.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/version_number.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1






# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/test.h" 1
# 8 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 2
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdc.h" 2
# 53 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdc.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h" 2
# 115 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/stdcpp.h"







# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/objc.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/objc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/objc.h" 2
# 42 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language/objc.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/language.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h" 2
# 59 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/alpha.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h" 2
# 70 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/arm.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/blackfin.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h" 2
# 65 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/convex.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h" 2
# 49 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ia64.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h" 2
# 82 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/m68k.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h" 2
# 73 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/mips.h"

# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h" 2
# 64 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/parisc.h"

# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h" 2
# 72 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/ppc.h"

# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h" 2
# 42 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/pyramid.h"

# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h" 2
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/rs6k.h"

# 24 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h" 2
# 54 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sparc.h"

# 25 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h" 2
# 67 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/superh.h"

# 26 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h" 2
# 43 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys370.h"

# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h" 2
# 43 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/sys390.h"

# 28 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 2
# 82 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 87 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"

# 9 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 1







# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 1
# 87 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h"

# 9 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"

# 10 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 2





# 10 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 83 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/32.h" 2





# 9 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86/64.h"

# 10 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h" 2
# 38 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/x86.h"

# 29 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/z.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/z.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/z.h" 2
# 42 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture/z.h"

# 30 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/architecture.h" 2
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h" 2
# 58 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/borland.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h" 2
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/comeau.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h" 2
# 61 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/compaq.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/diab.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/digitalmars.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/dignus.h"

# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/edg.h"

# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h" 2
# 52 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ekopath.h"

# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h" 2
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc_xml.h"

# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2
# 55 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/comp_detected.h" 1
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/gcc.h" 2








# 24 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h" 2
# 61 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/greenhills.h"

# 25 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h" 2
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/hp_acc.h"

# 26 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/iar.h"

# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h" 2
# 67 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/ibm.h"

# 28 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h" 2
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/intel.h"

# 29 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/kai.h"

# 30 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h" 2
# 52 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/llvm.h"

# 31 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h" 2
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metaware.h"

# 32 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h" 2
# 72 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/metrowerks.h"

# 33 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h" 2
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/microtec.h"

# 34 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h" 2
# 58 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/mpw.h"

# 35 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/palm.h"

# 36 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h" 2
# 55 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/pgi.h"

# 37 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h" 2
# 61 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sgi_mipspro.h"

# 38 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h" 2
# 71 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/sunpro.h"

# 39 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h" 2
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/tendra.h"

# 40 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/clang.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h" 2
# 86 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/visualc.h"

# 41 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler/watcom.h"

# 42 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/compiler.h" 2
# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h"
# 1 "/usr/include/assert.h" 1 3 4
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/_cassert.h" 2
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/_prefix.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2

# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 2




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 2
# 61 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h" 2
# 47 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/uc.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h" 2
# 47 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/vms.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h" 2
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/zos.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h" 1
# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/_exception.h" 1
# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/_prefix.h" 2
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2

# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/cxx.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h" 2
# 52 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/dinkumware.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h" 2
# 47 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/libcomo.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/modena.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h" 2
# 53 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/msl.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h" 2
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/roguewave.h"

# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/sgi.h"

# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h" 2
# 53 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stdcpp3.h"

# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h" 2
# 59 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/stlport.h"

# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h" 2
# 44 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std/vacpp.h"

# 24 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/std.h" 2
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library.h" 2
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/aix.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/aix.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/aix.h" 2
# 66 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/aix.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/amigaos.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/beos.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/beos.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/beos.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/beos.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 2
# 65 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 52 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 2
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 2
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 2
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 2
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 2
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 53 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 54 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 55 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 57 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 103 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/cygwin.h"

# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/haiku.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/haiku.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/haiku.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/haiku.h"

# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/hpux.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/hpux.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/hpux.h" 2
# 47 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/hpux.h"

# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/irix.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/irix.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/irix.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/irix.h"

# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/ios.h"

# 24 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/linux.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 2
# 38 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/linux.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/detail/os_detected.h" 1
# 39 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/linux.h" 2








# 25 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 65 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 26 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/os400.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/os400.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/os400.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/os400.h"

# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h" 2
# 59 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/qnxnto.h"

# 28 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/solaris.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/solaris.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/solaris.h" 2
# 46 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/solaris.h"

# 29 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/unix.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/unix.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/unix.h" 2
# 75 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/unix.h"


# 30 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/vms.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/vms.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/vms.h" 2
# 52 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/vms.h"

# 31 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 32 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os.h" 2
# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h" 1
# 61 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/library/c/gnu.h"

# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h" 1
# 65 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/macos.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 1
# 94 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h" 1
# 48 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/bsdi.h"

# 95 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h" 1
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/dragonfly.h"

# 96 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h" 1
# 60 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/free.h"

# 97 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h" 1
# 171 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/open.h"

# 98 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h" 1
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd/net.h"

# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/bsd.h" 2





# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h" 1
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/android.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h" 2
# 195 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other/endian.h"










# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/other.h" 2
# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h" 2
# 64 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/mingw.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_desktop.h"

# 16 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h" 2
# 43 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_store.h"

# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h" 2
# 43 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_phone.h"

# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/make.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h" 1
# 51 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/os/windows.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h" 2
# 45 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform/windows_runtime.h"

# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/platform.h" 2
# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 1
# 9 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86/versions.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h" 2
# 123 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86.h"

# 10 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd/versions.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h" 2
# 87 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/x86_amd.h"

# 11 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm/versions.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h" 2
# 57 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/arm.h"

# 12 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc/versions.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h" 2
# 69 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd/ppc.h"

# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h" 2
# 119 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware/simd.h"

# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/hardware.h" 2
# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2

# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef/version.h" 1
# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack/predef.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h" 2


# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h" 2
# 63 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h"
    typedef unsigned int _msgpack_atomic_counter_t;
# 84 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h"
# 1 "/usr/include/byteswap.h" 1 3 4
# 24 "/usr/include/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 25 "/usr/include/byteswap.h" 2 3 4
# 85 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 2
# 26 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
typedef struct msgpack_zone_finalizer {
    void (*func)(void* data);
    void* data;
} msgpack_zone_finalizer;

typedef struct msgpack_zone_finalizer_array {
    msgpack_zone_finalizer* tail;
    msgpack_zone_finalizer* end;
    msgpack_zone_finalizer* array;
} msgpack_zone_finalizer_array;

struct msgpack_zone_chunk;
typedef struct msgpack_zone_chunk msgpack_zone_chunk;

typedef struct msgpack_zone_chunk_list {
    size_t free;
    char* ptr;
    msgpack_zone_chunk* head;
} msgpack_zone_chunk_list;

typedef struct msgpack_zone {
    msgpack_zone_chunk_list chunk_list;
    msgpack_zone_finalizer_array finalizer_array;
    size_t chunk_size;
} msgpack_zone;







# 57 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 57 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_init(msgpack_zone* zone, size_t chunk_size);

void msgpack_zone_destroy(msgpack_zone* zone);


msgpack_zone* msgpack_zone_new(size_t chunk_size);

void msgpack_zone_free(msgpack_zone* zone);

static inline void* msgpack_zone_malloc(msgpack_zone* zone, size_t size);
static inline void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size);

static inline 
# 69 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
             _Bool 
# 69 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
                  msgpack_zone_push_finalizer(msgpack_zone* zone,
        void (*func)(void* data), void* data);

static inline void msgpack_zone_swap(msgpack_zone* a, msgpack_zone* b);



# 75 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 75 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_is_empty(msgpack_zone* zone);


void msgpack_zone_clear(msgpack_zone* zone);
# 87 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"

void* msgpack_zone_malloc_expand(msgpack_zone* zone, size_t size);

static inline void* msgpack_zone_malloc_no_align(msgpack_zone* zone, size_t size)
{
    char* ptr;
    msgpack_zone_chunk_list* cl = &zone->chunk_list;

    if(zone->chunk_list.free < size) {
        return msgpack_zone_malloc_expand(zone, size);
    }

    ptr = cl->ptr;
    cl->free -= size;
    cl->ptr += size;

    return ptr;
}

static inline void* msgpack_zone_malloc(msgpack_zone* zone, size_t size)
{
    char* aligned =
        (char*)(
            (size_t)(
                zone->chunk_list.ptr + (sizeof(void*) - 1)
            ) / sizeof(void*) * sizeof(void*)
        );
    size_t adjusted_size = size + (aligned - zone->chunk_list.ptr);
    if(zone->chunk_list.free >= adjusted_size) {
        zone->chunk_list.free -= adjusted_size;
        zone->chunk_list.ptr += adjusted_size;
        return aligned;
    }
    {
        void* ptr = msgpack_zone_malloc_expand(zone, size + (sizeof(void*) - 1));
        if (ptr) {
            return (char*)((size_t)(ptr) / sizeof(void*) * sizeof(void*));
        }
    }
    return 
# 126 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
          ((void *)0)
# 126 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
              ;
}



# 130 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
_Bool 
# 130 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
    msgpack_zone_push_finalizer_expand(msgpack_zone* zone,
        void (*func)(void* data), void* data);

static inline 
# 133 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
             _Bool 
# 133 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
                  msgpack_zone_push_finalizer(msgpack_zone* zone,
        void (*func)(void* data), void* data)
{
    msgpack_zone_finalizer_array* const fa = &zone->finalizer_array;
    msgpack_zone_finalizer* fin = fa->tail;

    if(fin == fa->end) {
        return msgpack_zone_push_finalizer_expand(zone, func, data);
    }

    fin->func = func;
    fin->data = data;

    ++fa->tail;

    return 
# 148 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 3 4
          1
# 148 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h"
              ;
}

static inline void msgpack_zone_swap(msgpack_zone* a, msgpack_zone* b)
{
    msgpack_zone tmp = *a;
    *a = *b;
    *b = tmp;
}
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h" 2
# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h"
typedef enum {
    MSGPACK_OBJECT_NIL = 0x00,
    MSGPACK_OBJECT_BOOLEAN = 0x01,
    MSGPACK_OBJECT_POSITIVE_INTEGER = 0x02,
    MSGPACK_OBJECT_NEGATIVE_INTEGER = 0x03,
    MSGPACK_OBJECT_FLOAT32 = 0x0a,
    MSGPACK_OBJECT_FLOAT64 = 0x04,
    MSGPACK_OBJECT_FLOAT = 0x04,



    MSGPACK_OBJECT_STR = 0x05,
    MSGPACK_OBJECT_ARRAY = 0x06,
    MSGPACK_OBJECT_MAP = 0x07,
    MSGPACK_OBJECT_BIN = 0x08,
    MSGPACK_OBJECT_EXT = 0x09
} msgpack_object_type;


struct msgpack_object;
struct msgpack_object_kv;

typedef struct {
    uint32_t size;
    struct msgpack_object* ptr;
} msgpack_object_array;

typedef struct {
    uint32_t size;
    struct msgpack_object_kv* ptr;
} msgpack_object_map;

typedef struct {
    uint32_t size;
    const char* ptr;
} msgpack_object_str;

typedef struct {
    uint32_t size;
    const char* ptr;
} msgpack_object_bin;

typedef struct {
    int8_t type;
    uint32_t size;
    const char* ptr;
} msgpack_object_ext;

typedef union {
    
# 76 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h" 3 4
   _Bool 
# 76 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h"
        boolean;
    uint64_t u64;
    int64_t i64;



    double f64;
    msgpack_object_array array;
    msgpack_object_map map;
    msgpack_object_str str;
    msgpack_object_bin bin;
    msgpack_object_ext ext;
} msgpack_object_union;

typedef struct msgpack_object {
    msgpack_object_type type;
    msgpack_object_union via;
} msgpack_object;

typedef struct msgpack_object_kv {
    msgpack_object key;
    msgpack_object val;
} msgpack_object_kv;


void msgpack_object_print(FILE* out, msgpack_object o);


int msgpack_object_print_buffer(char *buffer, size_t buffer_size, msgpack_object o);



# 107 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h" 3 4
_Bool 
# 107 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h"
    msgpack_object_equal(const msgpack_object x, const msgpack_object y);
# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/zone.h" 1
# 19 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_define.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_define.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/sysdep.h" 1
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_define.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_define.h" 2
# 14 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/object.h" 1
# 15 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h" 2
# 35 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h"
typedef int (*msgpack_packer_write)(void* data, const char* buf, size_t len);

typedef struct msgpack_packer {
    void* data;
    msgpack_packer_write callback;
} msgpack_packer;

static void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback);

static msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback);
static void msgpack_packer_free(msgpack_packer* pk);

static int msgpack_pack_char(msgpack_packer* pk, char d);

static int msgpack_pack_signed_char(msgpack_packer* pk, signed char d);
static int msgpack_pack_short(msgpack_packer* pk, short d);
static int msgpack_pack_int(msgpack_packer* pk, int d);
static int msgpack_pack_long(msgpack_packer* pk, long d);
static int msgpack_pack_long_long(msgpack_packer* pk, long long d);
static int msgpack_pack_unsigned_char(msgpack_packer* pk, unsigned char d);
static int msgpack_pack_unsigned_short(msgpack_packer* pk, unsigned short d);
static int msgpack_pack_unsigned_int(msgpack_packer* pk, unsigned int d);
static int msgpack_pack_unsigned_long(msgpack_packer* pk, unsigned long d);
static int msgpack_pack_unsigned_long_long(msgpack_packer* pk, unsigned long long d);

static int msgpack_pack_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_fix_uint8(msgpack_packer* pk, uint8_t d);
static int msgpack_pack_fix_uint16(msgpack_packer* pk, uint16_t d);
static int msgpack_pack_fix_uint32(msgpack_packer* pk, uint32_t d);
static int msgpack_pack_fix_uint64(msgpack_packer* pk, uint64_t d);
static int msgpack_pack_fix_int8(msgpack_packer* pk, int8_t d);
static int msgpack_pack_fix_int16(msgpack_packer* pk, int16_t d);
static int msgpack_pack_fix_int32(msgpack_packer* pk, int32_t d);
static int msgpack_pack_fix_int64(msgpack_packer* pk, int64_t d);

static int msgpack_pack_float(msgpack_packer* pk, float d);
static int msgpack_pack_double(msgpack_packer* pk, double d);

static int msgpack_pack_nil(msgpack_packer* pk);
static int msgpack_pack_true(msgpack_packer* pk);
static int msgpack_pack_false(msgpack_packer* pk);

static int msgpack_pack_array(msgpack_packer* pk, size_t n);

static int msgpack_pack_map(msgpack_packer* pk, size_t n);

static int msgpack_pack_str(msgpack_packer* pk, size_t l);
static int msgpack_pack_str_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_v4raw(msgpack_packer* pk, size_t l);
static int msgpack_pack_v4raw_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_bin(msgpack_packer* pk, size_t l);
static int msgpack_pack_bin_body(msgpack_packer* pk, const void* b, size_t l);

static int msgpack_pack_ext(msgpack_packer* pk, size_t l, int8_t type);
static int msgpack_pack_ext_body(msgpack_packer* pk, const void* b, size_t l);


int msgpack_pack_object(msgpack_packer* pk, msgpack_object d);
# 122 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h"
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 1
# 271 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
inline int msgpack_pack_fix_uint8(msgpack_packer* x, uint8_t d)
{
    unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]};
    return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_uint16(msgpack_packer* x, uint16_t d)
{
    unsigned char buf[3];
    buf[0] = 0xcd; do { uint16_t val = 
# 280 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_16 (
# 280 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 280 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 280 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 2); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_uint32(msgpack_packer* x, uint32_t d)
{
    unsigned char buf[5];
    buf[0] = 0xce; do { uint32_t val = 
# 287 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_32 (
# 287 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 287 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 287 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_uint64(msgpack_packer* x, uint64_t d)
{
    unsigned char buf[9];
    buf[0] = 0xcf; do { uint64_t val = 
# 294 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_64 (
# 294 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 294 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 294 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}

inline int msgpack_pack_fix_int8(msgpack_packer* x, int8_t d)
{
    unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]};
    return (*(x)->callback)((x)->data, (const char*)buf, 2);
}

inline int msgpack_pack_fix_int16(msgpack_packer* x, int16_t d)
{
    unsigned char buf[3];
    buf[0] = 0xd1; do { uint16_t val = 
# 307 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_16 (
# 307 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 307 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 307 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 2); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 3);
}

inline int msgpack_pack_fix_int32(msgpack_packer* x, int32_t d)
{
    unsigned char buf[5];
    buf[0] = 0xd2; do { uint32_t val = 
# 314 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_32 (
# 314 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 314 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 314 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_fix_int64(msgpack_packer* x, int64_t d)
{
    unsigned char buf[9];
    buf[0] = 0xd3; do { uint64_t val = 
# 321 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_64 (
# 321 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  d
# 321 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 321 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}





inline int msgpack_pack_uint8(msgpack_packer* x, uint8_t d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } while(0);
}

inline int msgpack_pack_uint16(msgpack_packer* x, uint16_t d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 336 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 336 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 336 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 336 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
}

inline int msgpack_pack_uint32(msgpack_packer* x, uint32_t d)
{
    do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 341 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_uint64(msgpack_packer* x, uint64_t d)
{
    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 346 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
}

inline int msgpack_pack_int8(msgpack_packer* x, int8_t d)
{
    do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);
}

inline int msgpack_pack_int16(msgpack_packer* x, int16_t d)
{
    do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 356 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
}

inline int msgpack_pack_int32(msgpack_packer* x, int32_t d)
{
    do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = 
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int32_t)d
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 361 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
}

inline int msgpack_pack_int64(msgpack_packer* x, int64_t d)
{
    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int32_t)d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 366 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
}

inline int msgpack_pack_char(msgpack_packer* x, char d)
{


        do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);






}

inline int msgpack_pack_signed_char(msgpack_packer* x, signed char d)
{
    do { if(d < -(1<<5)) { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } } while(0);
}

inline int msgpack_pack_unsigned_char(msgpack_packer* x, unsigned char d)
{
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } while(0);
}



inline int msgpack_pack_short(msgpack_packer* x, short d)
{
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < -(1<<5)) { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 407 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } } while(0);
# 423 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_int(msgpack_packer* x, int d)
{




    do { if(d < -(1<<5)) { if(d < -(1<<15)) { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = 
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int32_t)d
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 431 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 454 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_long(msgpack_packer* x, long d)
{






    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int32_t)d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 464 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 485 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_long_long(msgpack_packer* x, long long d)
{
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < -(1LL<<5)) { if(d < -(1LL<<15)) { if(d < -(1LL<<31)) { unsigned char buf[9]; buf[0] = 0xd3; do { uint64_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } else { unsigned char buf[5]; buf[0] = 0xd2; do { uint32_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int32_t)d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } else { if(d < -(1<<7)) { unsigned char buf[3]; buf[0] = 0xd1; do { uint16_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (int16_t)d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[2] = {0xd0, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } } else if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { if(d < (1LL<<16)) { if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } else { if(d < (1LL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 504 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } } while(0);
# 516 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_short(msgpack_packer* x, unsigned short d)
{
# 531 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else if(d < (1<<8)) { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } else { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 531 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 531 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 531 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 531 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } } while(0);
# 547 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_int(msgpack_packer* x, unsigned int d)
{




    do { if(d < (1<<8)) { if(d < (1<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 555 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } } } while(0);
# 578 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_long(msgpack_packer* x, unsigned long d)
{






    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 588 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 609 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}

inline int msgpack_pack_unsigned_long_long(msgpack_packer* x, unsigned long long d)
{
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
    do { if(d < (1ULL<<8)) { if(d < (1ULL<<7)) { return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1); } else { unsigned char buf[2] = {0xcc, ((uint8_t*)&d)[0]}; return (*(x)->callback)((x)->data, (const char*)buf, 2); } } else { if(d < (1ULL<<16)) { unsigned char buf[3]; buf[0] = 0xcd; do { uint16_t val = 
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_16 (
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint16_t)d
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 2); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 3); } else if(d < (1ULL<<32)) { unsigned char buf[5]; buf[0] = 0xce; do { uint32_t val = 
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_32 (
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   (uint32_t)d
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 4); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 5); } else { unsigned char buf[9]; buf[0] = 0xcf; do { uint64_t val = 
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   d
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 628 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0); return (*(x)->callback)((x)->data, (const char*)buf, 9); } } } while(0);
# 640 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
}
# 651 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
inline int msgpack_pack_float(msgpack_packer* x, float d)
{
    unsigned char buf[5];
    union { float f; uint32_t i; } mem;
    mem.f = d;
    buf[0] = 0xca; do { uint32_t val = 
# 656 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  __bswap_32 (
# 656 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  mem.i
# 656 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                  )
# 656 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                  ; memcpy(&buf[1], &val, 4); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 5);
}

inline int msgpack_pack_double(msgpack_packer* x, double d)
{
    unsigned char buf[9];
    union { double f; uint64_t i; } mem;
    mem.f = d;
    buf[0] = 0xcb;






    do { uint64_t val = 
# 672 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   __bswap_64 (
# 672 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   mem.i
# 672 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
   )
# 672 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
   ; memcpy(&buf[1], &val, 8); } while(0);
    return (*(x)->callback)((x)->data, (const char*)buf, 9);
}






inline int msgpack_pack_nil(msgpack_packer* x)
{
    static const unsigned char d = 0xc0;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_true(msgpack_packer* x)
{
    static const unsigned char d = 0xc3;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}

inline int msgpack_pack_false(msgpack_packer* x)
{
    static const unsigned char d = 0xc2;
    return (*(x)->callback)((x)->data, (const char*)&d, 1);
}






inline int msgpack_pack_array(msgpack_packer* x, size_t n)
{
    if(n < 16) {
        unsigned char d = 0x90 | (uint8_t)n;
        return (*(x)->callback)((x)->data, (const char*)&d, 1);
    } else if(n < 65536) {
        unsigned char buf[3];
        buf[0] = 0xdc; do { uint16_t val = 
# 716 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_16 (
# 716 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint16_t)n
# 716 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 716 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdd; do { uint32_t val = 
# 720 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_32 (
# 720 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint32_t)n
# 720 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 720 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}






inline int msgpack_pack_map(msgpack_packer* x, size_t n)
{
    if(n < 16) {
        unsigned char d = 0x80 | (uint8_t)n;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(n < 65536) {
        unsigned char buf[3];
        buf[0] = 0xde; do { uint16_t val = 
# 737 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_16 (
# 737 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint16_t)n
# 737 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 737 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdf; do { uint32_t val = 
# 741 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_32 (
# 741 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint32_t)n
# 741 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 741 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}






inline int msgpack_pack_str(msgpack_packer* x, size_t l)
{
    if(l < 32) {
        unsigned char d = 0xa0 | (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(l < 256) {
        unsigned char buf[2];
        buf[0] = 0xd9; buf[1] = (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xda; do { uint16_t val = 
# 762 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_16 (
# 762 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint16_t)l
# 762 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 762 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdb; do { uint32_t val = 
# 766 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_32 (
# 766 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint32_t)l
# 766 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 766 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_str_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_v4raw(msgpack_packer* x, size_t l)
{
    if(l < 32) {
        unsigned char d = 0xa0 | (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)&((uint8_t*)&d)[0], 1);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xda; do { uint16_t val = 
# 787 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_16 (
# 787 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint16_t)l
# 787 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 787 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xdb; do { uint32_t val = 
# 791 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_32 (
# 791 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint32_t)l
# 791 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 791 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_v4raw_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_bin(msgpack_packer* x, size_t l)
{
    if(l < 256) {
        unsigned char buf[2];
        buf[0] = 0xc4; buf[1] = (uint8_t)l;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } else if(l < 65536) {
        unsigned char buf[3];
        buf[0] = 0xc5; do { uint16_t val = 
# 813 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_16 (
# 813 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint16_t)l
# 813 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 813 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 2); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 3);
    } else {
        unsigned char buf[5];
        buf[0] = 0xc6; do { uint32_t val = 
# 817 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      __bswap_32 (
# 817 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      (uint32_t)l
# 817 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
                      )
# 817 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
                      ; memcpy(&buf[1], &val, 4); } while(0);
        return (*(x)->callback)((x)->data, (const char*)buf, 5);
    }
}

inline int msgpack_pack_bin_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}





inline int msgpack_pack_ext(msgpack_packer* x, size_t l, int8_t type)
{
    switch(l) {
    case 1: {
        unsigned char buf[2];
        buf[0] = 0xd4;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 2: {
        unsigned char buf[2];
        buf[0] = 0xd5;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 4: {
        unsigned char buf[2];
        buf[0] = 0xd6;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 8: {
        unsigned char buf[2];
        buf[0] = 0xd7;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    case 16: {
        unsigned char buf[2];
        buf[0] = 0xd8;
        buf[1] = type;
        return (*(x)->callback)((x)->data, (const char*)buf, 2);
    } break;
    default:
        if(l < 256) {
            unsigned char buf[3];
            buf[0] = 0xc7;
            buf[1] = (unsigned char)l;
            buf[2] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 3);
        } else if(l < 65536) {
            unsigned char buf[4];
            buf[0] = 0xc8;
            do { uint16_t val = 
# 874 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
           __bswap_16 (
# 874 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
           l
# 874 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
           )
# 874 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
           ; memcpy(&buf[1], &val, 2); } while(0);
            buf[3] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 4);
        } else {
            unsigned char buf[6];
            buf[0] = 0xc9;
            do { uint32_t val = 
# 880 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
           __bswap_32 (
# 880 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
           l
# 880 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h" 3 4
           )
# 880 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack_template.h"
           ; memcpy(&buf[1], &val, 4); } while(0);
            buf[5] = type;
            return (*(x)->callback)((x)->data, (const char*)buf, 6);
        }
        break;
    }
}

inline int msgpack_pack_ext_body(msgpack_packer* x, const void* b, size_t l)
{
    return (*(x)->callback)((x)->data, (const char*)(const unsigned char*)b, l);
}
# 123 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h" 2

inline void msgpack_packer_init(msgpack_packer* pk, void* data, msgpack_packer_write callback)
{
    pk->data = data;
    pk->callback = callback;
}

inline msgpack_packer* msgpack_packer_new(void* data, msgpack_packer_write callback)
{
    msgpack_packer* pk = (msgpack_packer*)calloc(1, sizeof(msgpack_packer));
    if(!pk) { return 
# 133 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h" 3 4
                    ((void *)0)
# 133 "/home/jesmith/neovim/.deps/usr/include/msgpack/pack.h"
                        ; }
    msgpack_packer_init(pk, data, callback);
    return pk;
}

inline void msgpack_packer_free(msgpack_packer* pk)
{
    free(pk);
}
# 20 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 1
# 28 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
typedef struct msgpack_unpacked {
    msgpack_zone* zone;
    msgpack_object data;
} msgpack_unpacked;

typedef enum {
    MSGPACK_UNPACK_SUCCESS = 2,
    MSGPACK_UNPACK_EXTRA_BYTES = 1,
    MSGPACK_UNPACK_CONTINUE = 0,
    MSGPACK_UNPACK_PARSE_ERROR = -1,
    MSGPACK_UNPACK_NOMEM_ERROR = -2
} msgpack_unpack_return;



msgpack_unpack_return
msgpack_unpack_next(msgpack_unpacked* result,
        const char* data, size_t len, size_t* off);
# 56 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
typedef struct msgpack_unpacker {
    char* buffer;
    size_t used;
    size_t free;
    size_t off;
    size_t parsed;
    msgpack_zone* z;
    size_t initial_buffer_size;
    void* ctx;
} msgpack_unpacker;
# 76 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"


# 77 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 77 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_init(msgpack_unpacker* mpac, size_t initial_buffer_size);





void msgpack_unpacker_destroy(msgpack_unpacker* mpac);







msgpack_unpacker* msgpack_unpacker_new(size_t initial_buffer_size);





void msgpack_unpacker_free(msgpack_unpacker* mpac);
# 111 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
static inline 
# 111 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
             _Bool 
# 111 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                    msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size);
# 120 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
static inline char* msgpack_unpacker_buffer(msgpack_unpacker* mpac);
# 129 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
static inline size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac);
# 138 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
static inline void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size);








msgpack_unpack_return msgpack_unpacker_next(msgpack_unpacker* mpac, msgpack_unpacked* pac);
# 156 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"

msgpack_unpack_return msgpack_unpacker_next_with_size(msgpack_unpacker* mpac,
                                                      msgpack_unpacked* result,
                                                      size_t *p_bytes);







static inline void msgpack_unpacked_init(msgpack_unpacked* result);




static inline void msgpack_unpacked_destroy(msgpack_unpacked* result);





static inline msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result);



int msgpack_unpacker_execute(msgpack_unpacker* mpac);


msgpack_object msgpack_unpacker_data(msgpack_unpacker* mpac);


msgpack_zone* msgpack_unpacker_release_zone(msgpack_unpacker* mpac);


void msgpack_unpacker_reset_zone(msgpack_unpacker* mpac);


void msgpack_unpacker_reset(msgpack_unpacker* mpac);

static inline size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac);







msgpack_unpack_return
msgpack_unpack(const char* data, size_t len, size_t* off,
        msgpack_zone* result_zone, msgpack_object* result);




static inline size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac);



# 214 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 214 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_flush_zone(msgpack_unpacker* mpac);



# 217 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
_Bool 
# 217 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
    msgpack_unpacker_expand_buffer(msgpack_unpacker* mpac, size_t size);

static inline 
# 219 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
             _Bool 
# 219 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                  msgpack_unpacker_reserve_buffer(msgpack_unpacker* mpac, size_t size)
{
    if(mpac->free >= size) { return 
# 221 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                                   1
# 221 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                                       ; }
    return msgpack_unpacker_expand_buffer(mpac, size);
}

static inline char* msgpack_unpacker_buffer(msgpack_unpacker* mpac)
{
    return mpac->buffer + mpac->used;
}

static inline size_t msgpack_unpacker_buffer_capacity(const msgpack_unpacker* mpac)
{
    return mpac->free;
}

static inline void msgpack_unpacker_buffer_consumed(msgpack_unpacker* mpac, size_t size)
{
    mpac->used += size;
    mpac->free -= size;
}

static inline size_t msgpack_unpacker_message_size(const msgpack_unpacker* mpac)
{
    return mpac->parsed - mpac->off + mpac->used;
}

static inline size_t msgpack_unpacker_parsed_size(const msgpack_unpacker* mpac)
{
    return mpac->parsed;
}


static inline void msgpack_unpacked_init(msgpack_unpacked* result)
{
    memset(result, 0, sizeof(msgpack_unpacked));
}

static inline void msgpack_unpacked_destroy(msgpack_unpacked* result)
{
    if(result->zone != 
# 259 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 259 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                          ) {
        msgpack_zone_free(result->zone);
        result->zone = 
# 261 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 261 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                          ;
        memset(&result->data, 0, sizeof(msgpack_object));
    }
}

static inline msgpack_zone* msgpack_unpacked_release_zone(msgpack_unpacked* result)
{
    if(result->zone != 
# 268 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 268 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                          ) {
        msgpack_zone* z = result->zone;
        result->zone = 
# 270 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
                      ((void *)0)
# 270 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
                          ;
        return z;
    }
    return 
# 273 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h" 3 4
          ((void *)0)
# 273 "/home/jesmith/neovim/.deps/usr/include/msgpack/unpack.h"
              ;
}
# 21 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h" 1
# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h"
typedef struct msgpack_sbuffer {
    size_t size;
    char* data;
    size_t alloc;
} msgpack_sbuffer;

static inline void msgpack_sbuffer_init(msgpack_sbuffer* sbuf)
{
    memset(sbuf, 0, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_destroy(msgpack_sbuffer* sbuf)
{
    free(sbuf->data);
}

static inline msgpack_sbuffer* msgpack_sbuffer_new(void)
{
    return (msgpack_sbuffer*)calloc(1, sizeof(msgpack_sbuffer));
}

static inline void msgpack_sbuffer_free(msgpack_sbuffer* sbuf)
{
    if(sbuf == 
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h" 3 4
              ((void *)0)
# 50 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h"
                  ) { return; }
    msgpack_sbuffer_destroy(sbuf);
    free(sbuf);
}





static inline int msgpack_sbuffer_write(void* data, const char* buf, size_t len)
{
    msgpack_sbuffer* sbuf = (msgpack_sbuffer*)data;

    if(sbuf->alloc - sbuf->size < len) {
        void* tmp;
        size_t nsize = (sbuf->alloc) ?
                sbuf->alloc * 2 : 8192;

        while(nsize < sbuf->size + len) {
            size_t tmp_nsize = nsize * 2;
            if (tmp_nsize <= nsize) {
                nsize = sbuf->size + len;
                break;
            }
            nsize = tmp_nsize;
        }

        tmp = realloc(sbuf->data, nsize);
        if(!tmp) { return -1; }

        sbuf->data = (char*)tmp;
        sbuf->alloc = nsize;
    }

    memcpy(sbuf->data + sbuf->size, buf, len);
    sbuf->size += len;
    return 0;
}

static inline char* msgpack_sbuffer_release(msgpack_sbuffer* sbuf)
{
    char* tmp = sbuf->data;
    sbuf->size = 0;
    sbuf->data = 
# 93 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h" 3 4
                ((void *)0)
# 93 "/home/jesmith/neovim/.deps/usr/include/msgpack/sbuffer.h"
                    ;
    sbuf->alloc = 0;
    return tmp;
}

static inline void msgpack_sbuffer_clear(msgpack_sbuffer* sbuf)
{
    sbuf->size = 0;
}
# 22 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/uio.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4

# 41 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4

# 41 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  __attribute__ ((__warn_unused_result__));
# 52 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  __attribute__ ((__warn_unused_result__));
# 67 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) __attribute__ ((__warn_unused_result__));
# 79 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) __attribute__ ((__warn_unused_result__));
# 106 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) __attribute__ ((__warn_unused_result__));
# 118 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) __attribute__ ((__warn_unused_result__));







extern ssize_t preadv2 (int __fp, const struct iovec *__iovec, int __count,
   __off_t __offset, int ___flags) __attribute__ ((__warn_unused_result__));


extern ssize_t pwritev2 (int __fd, const struct iovec *__iodev, int __count,
    __off_t __offset, int __flags) __attribute__ ((__warn_unused_result__));
# 152 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv64v2 (int __fp, const struct iovec *__iovec,
      int __count, __off64_t __offset,
      int ___flags) __attribute__ ((__warn_unused_result__));


extern ssize_t pwritev64v2 (int __fd, const struct iovec *__iodev,
       int __count, __off64_t __offset,
       int __flags) __attribute__ ((__warn_unused_result__));








# 1 "/usr/include/x86_64-linux-gnu/bits/uio-ext.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/uio-ext.h" 3 4



extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  __attribute__ ((__nothrow__ , __leaf__));
# 51 "/usr/include/x86_64-linux-gnu/bits/uio-ext.h" 3 4

# 169 "/usr/include/x86_64-linux-gnu/sys/uio.h" 2 3 4
# 18 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 2
# 36 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"

# 36 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
struct msgpack_vrefbuffer_chunk;
typedef struct msgpack_vrefbuffer_chunk msgpack_vrefbuffer_chunk;

typedef struct msgpack_vrefbuffer_inner_buffer {
    size_t free;
    char* ptr;
    msgpack_vrefbuffer_chunk* head;
} msgpack_vrefbuffer_inner_buffer;

typedef struct msgpack_vrefbuffer {
    struct iovec* tail;
    struct iovec* end;
    struct iovec* array;

    size_t chunk_size;
    size_t ref_size;

    msgpack_vrefbuffer_inner_buffer inner_buffer;
} msgpack_vrefbuffer;
# 65 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"


# 66 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
_Bool 
# 66 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
    msgpack_vrefbuffer_init(msgpack_vrefbuffer* vbuf,
        size_t ref_size, size_t chunk_size);

void msgpack_vrefbuffer_destroy(msgpack_vrefbuffer* vbuf);

static inline msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size);
static inline void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf);

static inline int msgpack_vrefbuffer_write(void* data, const char* buf, size_t len);

static inline const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref);
static inline size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref);


int msgpack_vrefbuffer_append_copy(msgpack_vrefbuffer* vbuf,
        const char* buf, size_t len);


int msgpack_vrefbuffer_append_ref(msgpack_vrefbuffer* vbuf,
        const char* buf, size_t len);


int msgpack_vrefbuffer_migrate(msgpack_vrefbuffer* vbuf, msgpack_vrefbuffer* to);


void msgpack_vrefbuffer_clear(msgpack_vrefbuffer* vref);




static inline msgpack_vrefbuffer* msgpack_vrefbuffer_new(size_t ref_size, size_t chunk_size)
{
    msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)malloc(sizeof(msgpack_vrefbuffer));
    if (vbuf == 
# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
               ((void *)0)
# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                   ) return 
# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
                            ((void *)0)
# 99 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                                ;
    if(!msgpack_vrefbuffer_init(vbuf, ref_size, chunk_size)) {
        free(vbuf);
        return 
# 102 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
              ((void *)0)
# 102 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                  ;
    }
    return vbuf;
}

static inline void msgpack_vrefbuffer_free(msgpack_vrefbuffer* vbuf)
{
    if(vbuf == 
# 109 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h" 3 4
              ((void *)0)
# 109 "/home/jesmith/neovim/.deps/usr/include/msgpack/vrefbuffer.h"
                  ) { return; }
    msgpack_vrefbuffer_destroy(vbuf);
    free(vbuf);
}

static inline int msgpack_vrefbuffer_write(void* data, const char* buf, size_t len)
{
    msgpack_vrefbuffer* vbuf = (msgpack_vrefbuffer*)data;

    if(len < vbuf->ref_size) {
        return msgpack_vrefbuffer_append_copy(vbuf, buf, len);
    } else {
        return msgpack_vrefbuffer_append_ref(vbuf, buf, len);
    }
}

static inline const struct iovec* msgpack_vrefbuffer_vec(const msgpack_vrefbuffer* vref)
{
    return vref->array;
}

static inline size_t msgpack_vrefbuffer_veclen(const msgpack_vrefbuffer* vref)
{
    return (size_t)(vref->tail - vref->array);
}
# 23 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/version.h" 1
# 17 "/home/jesmith/neovim/.deps/usr/include/msgpack/version.h"

const char* msgpack_version(void);

int msgpack_version_major(void);

int msgpack_version_minor(void);

int msgpack_version_revision(void);

# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack/version_master.h" 1
# 27 "/home/jesmith/neovim/.deps/usr/include/msgpack/version.h" 2
# 24 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 2
# 5 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h" 2
# 13 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h"
typedef struct Channel Channel;

typedef struct {
  uint32_t request_id;
  
# 17 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h" 3 4
 _Bool 
# 17 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h"
      returned, errored;
  Object result;
} ChannelCallFrame;

typedef struct {
  MessageType type;
  Channel *channel;
  MsgpackRpcRequestHandler handler;
  Array args;
  uint32_t request_id;
} RequestEvent;

typedef struct {
  Map_cstr_t_ptr_t subscribed_events[1];
  
# 31 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h" 3 4
 _Bool 
# 31 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel_defs.h"
      closed;
  msgpack_unpacker *unpacker;
  uint32_t next_request_id;
  struct { size_t size; size_t capacity; ChannelCallFrame * *items; } call_stack;
  Dictionary info;
} RpcState;
# 10 "/home/jesmith/neovim/src/nvim/channel.h" 2
# 1 "/home/jesmith/neovim/src/nvim/os/pty_process.h" 1






# 1 "/home/jesmith/neovim/src/nvim/os/pty_process_unix.h" 1



# 1 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4




# 1 "/usr/include/linux/ioctl.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 2 3 4
# 6 "/usr/include/linux/ioctl.h" 2 3 4
# 6 "/usr/include/asm-generic/ioctls.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 2 3 4



# 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
# 30 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4




extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ , __leaf__));


# 5 "/home/jesmith/neovim/src/nvim/os/pty_process_unix.h" 2




# 8 "/home/jesmith/neovim/src/nvim/os/pty_process_unix.h"
typedef struct pty_process {
  Process process;
  uint16_t width, height;
  struct winsize winsize;
  int tty_fd;
} PtyProcess;

static inline PtyProcess pty_process_init(Loop *loop, void *data)
{
  PtyProcess rv;
  rv.process = process_init(loop, kProcessTypePty, data);
  rv.width = 80;
  rv.height = 24;
  rv.tty_fd = -1;
  return rv;
}
# 8 "/home/jesmith/neovim/src/nvim/os/pty_process.h" 2
# 11 "/home/jesmith/neovim/src/nvim/channel.h" 2




typedef enum {
  kChannelStreamProc,
  kChannelStreamSocket,
  kChannelStreamStdio,
  kChannelStreamStderr,
  kChannelStreamInternal,
} ChannelStreamType;

typedef enum {
  kChannelPartStdin,
  kChannelPartStdout,
  kChannelPartStderr,
  kChannelPartRpc,
  kChannelPartAll,
} ChannelPart;

typedef enum {
  kChannelStdinPipe,
  kChannelStdinNull,
} ChannelStdinMode;

typedef struct {
  Stream in;
  Stream out;
} StdioPair;

typedef struct {
  
# 42 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 42 "/home/jesmith/neovim/src/nvim/channel.h"
      closed;
} StderrState;

typedef struct {
  LuaRef cb;
} InternalState;

typedef struct {
  Callback cb;
  dict_T *self;
  garray_T buffer;
  
# 53 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 53 "/home/jesmith/neovim/src/nvim/channel.h"
      eof;
  
# 54 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 54 "/home/jesmith/neovim/src/nvim/channel.h"
      buffered;
  const char *type;
} CallbackReader;






static inline 
# 63 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
             _Bool 
# 63 "/home/jesmith/neovim/src/nvim/channel.h"
                  callback_reader_set(CallbackReader reader)
{
  return reader.cb.type != kCallbackNone || reader.self;
}

struct Channel {
  uint64_t id;
  size_t refcount;
  MultiQueue *events;

  ChannelStreamType streamtype;
  union {
    Process proc;
    LibuvProcess uv;
    PtyProcess pty;
    Stream socket;
    StdioPair stdio;
    StderrState err;
    InternalState internal;
  } stream;

  
# 84 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 84 "/home/jesmith/neovim/src/nvim/channel.h"
      is_rpc;
  RpcState rpc;
  Terminal *term;

  CallbackReader on_data;
  CallbackReader on_stderr;
  Callback on_exit;
  int exit_status;

  
# 93 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 93 "/home/jesmith/neovim/src/nvim/channel.h"
      callback_busy;
  
# 94 "/home/jesmith/neovim/src/nvim/channel.h" 3 4
 _Bool 
# 94 "/home/jesmith/neovim/src/nvim/channel.h"
      callback_scheduled;
};

extern Map_uint64_t_ptr_t channels ;






static inline Channel *find_channel(uint64_t id)
{
  return map_uint64_t_ptr_t_get(&channels, id);
}

static inline Stream *channel_instream(Channel *chan)
  FUNC_ATTR_NONNULL_ALL
{
  switch (chan->streamtype) {
  case kChannelStreamProc:
    return &chan->stream.proc.in;

  case kChannelStreamSocket:
    return &chan->stream.socket;

  case kChannelStreamStdio:
    return &chan->stream.stdio.out;

  case kChannelStreamInternal:
  case kChannelStreamStderr:
    abort();
  }
  abort();
}

static inline Stream *channel_outstream(Channel *chan)
  FUNC_ATTR_NONNULL_ALL
{
  switch (chan->streamtype) {
  case kChannelStreamProc:
    return &chan->stream.proc.out;

  case kChannelStreamSocket:
    return &chan->stream.socket;

  case kChannelStreamStdio:
    return &chan->stream.stdio.in;

  case kChannelStreamInternal:
  case kChannelStreamStderr:
    abort();
  }
  abort();
}
# 6 "/home/jesmith/neovim/src/nvim/eval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/eval/funcs.h" 1






typedef void (*FunPtr)(void);


typedef void (*VimLFunc)(typval_T *args, typval_T *rvar, FunPtr data);






typedef struct fst {
  char *name;
  uint8_t min_argc;
  uint8_t max_argc;
  uint8_t base_arg;
  VimLFunc func;
  FunPtr data;
} VimLFuncDef;
# 7 "/home/jesmith/neovim/src/nvim/eval.h" 2
# 1 "/home/jesmith/neovim/src/nvim/event/time.h" 1







typedef struct time_watcher TimeWatcher;
typedef void (*time_cb)(TimeWatcher *watcher, void *data);

struct time_watcher {
  uv_timer_t uv;
  void *data;
  time_cb cb, close_cb;
  MultiQueue *events;
  
# 16 "/home/jesmith/neovim/src/nvim/event/time.h" 3 4
 _Bool 
# 16 "/home/jesmith/neovim/src/nvim/event/time.h"
      blockable;
};
# 8 "/home/jesmith/neovim/src/nvim/eval.h" 2


# 1 "/home/jesmith/neovim/src/nvim/os/stdpaths_defs.h" 1




typedef enum {
  kXDGNone = -1,
  kXDGConfigHome,
  kXDGDataHome,
  kXDGCacheHome,
  kXDGRuntimeDir,
  kXDGConfigDirs,
  kXDGDataDirs,
} XDGVarType;
# 11 "/home/jesmith/neovim/src/nvim/eval.h" 2





extern hashtab_T func_hashtab;


extern ufunc_T dumuf;
# 51 "/home/jesmith/neovim/src/nvim/eval.h"
typedef struct lval_S {
  const char *ll_name;
  size_t ll_name_len;
  char *ll_exp_name;
  typval_T *ll_tv;

  listitem_T *ll_li;
  list_T *ll_list;
  
# 59 "/home/jesmith/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 59 "/home/jesmith/neovim/src/nvim/eval.h"
      ll_range;
  
# 60 "/home/jesmith/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 60 "/home/jesmith/neovim/src/nvim/eval.h"
      ll_empty2;
  long ll_n1;
  long ll_n2;
  dict_T *ll_dict;
  dictitem_T *ll_di;
  char_u *ll_newkey;
  blob_T *ll_blob;
} lval_T;


typedef enum {
  VAR_FLAVOUR_DEFAULT = 1,
  VAR_FLAVOUR_SESSION = 2,
  VAR_FLAVOUR_SHADA = 4,
} var_flavour_T;


typedef enum {
  VV_COUNT,
  VV_COUNT1,
  VV_PREVCOUNT,
  VV_ERRMSG,
  VV_WARNINGMSG,
  VV_STATUSMSG,
  VV_SHELL_ERROR,
  VV_THIS_SESSION,
  VV_VERSION,
  VV_LNUM,
  VV_TERMRESPONSE,
  VV_FNAME,
  VV_LANG,
  VV_LC_TIME,
  VV_CTYPE,
  VV_CC_FROM,
  VV_CC_TO,
  VV_FNAME_IN,
  VV_FNAME_OUT,
  VV_FNAME_NEW,
  VV_FNAME_DIFF,
  VV_CMDARG,
  VV_FOLDSTART,
  VV_FOLDEND,
  VV_FOLDDASHES,
  VV_FOLDLEVEL,
  VV_PROGNAME,
  VV_SEND_SERVER,
  VV_DYING,
  VV_EXCEPTION,
  VV_THROWPOINT,
  VV_REG,
  VV_CMDBANG,
  VV_INSERTMODE,
  VV_VAL,
  VV_KEY,
  VV_PROFILING,
  VV_FCS_REASON,
  VV_FCS_CHOICE,
  VV_BEVAL_BUFNR,
  VV_BEVAL_WINNR,
  VV_BEVAL_WINID,
  VV_BEVAL_LNUM,
  VV_BEVAL_COL,
  VV_BEVAL_TEXT,
  VV_SCROLLSTART,
  VV_SWAPNAME,
  VV_SWAPCHOICE,
  VV_SWAPCOMMAND,
  VV_CHAR,
  VV_MOUSE_WIN,
  VV_MOUSE_WINID,
  VV_MOUSE_LNUM,
  VV_MOUSE_COL,
  VV_OP,
  VV_SEARCHFORWARD,
  VV_HLSEARCH,
  VV_OLDFILES,
  VV_WINDOWID,
  VV_PROGPATH,
  VV_COMPLETED_ITEM,
  VV_OPTION_NEW,
  VV_OPTION_OLD,
  VV_OPTION_TYPE,
  VV_ERRORS,
  VV_FALSE,
  VV_TRUE,
  VV_NULL,
  VV_NUMBERMAX,
  VV_NUMBERMIN,
  VV_NUMBERSIZE,
  VV_VIM_DID_ENTER,
  VV_TESTING,
  VV_TYPE_NUMBER,
  VV_TYPE_STRING,
  VV_TYPE_FUNC,
  VV_TYPE_LIST,
  VV_TYPE_DICT,
  VV_TYPE_FLOAT,
  VV_TYPE_BOOL,
  VV_TYPE_BLOB,
  VV_EVENT,
  VV_ECHOSPACE,
  VV_ARGV,
  VV_COLLATE,
  VV_EXITING,

  VV_STDERR,
  VV_MSGPACK_TYPES,
  VV__NULL_STRING,
  VV__NULL_LIST,
  VV__NULL_DICT,
  VV__NULL_BLOB,
  VV_LUA,
} VimVarIndex;


typedef enum {
  kMPNil,
  kMPBoolean,
  kMPInteger,
  kMPFloat,
  kMPString,
  kMPBinary,
  kMPArray,
  kMPMap,
  kMPExt,

} MessagePackType;


extern const list_T *eval_msgpack_type_lists[kMPExt + 1];




typedef enum {
  TFN_INT = 1,
  TFN_QUIET = 2,
  TFN_NO_AUTOLOAD = 4,
  TFN_NO_DEREF = 8,
  TFN_READ_ONLY = 16,
} TransFunctionNameFlags;


typedef enum {
  GLV_QUIET = TFN_QUIET,
  GLV_NO_AUTOLOAD = TFN_NO_AUTOLOAD,
  GLV_READ_ONLY = TFN_READ_ONLY,

} GetLvalFlags;






typedef struct {
  TimeWatcher tw;
  int timer_id;
  int repeat_count;
  int refcount;
  int emsg_count;
  long timeout;
  
# 222 "/home/jesmith/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 222 "/home/jesmith/neovim/src/nvim/eval.h"
      stopped;
  
# 223 "/home/jesmith/neovim/src/nvim/eval.h" 3 4
 _Bool 
# 223 "/home/jesmith/neovim/src/nvim/eval.h"
      paused;
  Callback callback;
} timer_T;


typedef enum
{
  ASSERT_EQUAL,
  ASSERT_NOTEQUAL,
  ASSERT_MATCH,
  ASSERT_NOTMATCH,
  ASSERT_INRANGE,
  ASSERT_OTHER,
} assert_type_T;


typedef enum {
  EXPR_UNKNOWN = 0,
  EXPR_EQUAL,
  EXPR_NEQUAL,
  EXPR_GREATER,
  EXPR_GEQUAL,
  EXPR_SMALLER,
  EXPR_SEQUAL,
  EXPR_MATCH,
  EXPR_NOMATCH,
  EXPR_IS,
  EXPR_ISNOT,
} exprtype_T;


typedef enum {
  kDictListKeys,
  kDictListValues,
  kDictListItems,
} DictListType;

typedef int (*ex_unletlock_callback)(lval_T *, char_u *, exarg_T *, int);


extern 
# 263 "/home/jesmith/neovim/src/nvim/eval.h" 3 4
      _Bool 
# 263 "/home/jesmith/neovim/src/nvim/eval.h"
           *eval_lavars_used;
# 5 "/home/jesmith/neovim/src/nvim/buffer.h" 2

# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 7 "/home/jesmith/neovim/src/nvim/buffer.h" 2

# 1 "/home/jesmith/neovim/src/nvim/memline.h" 1
# 9 "/home/jesmith/neovim/src/nvim/buffer.h" 2

# 1 "/home/jesmith/neovim/src/nvim/screen.h" 1
# 31 "/home/jesmith/neovim/src/nvim/screen.h"
extern ScreenGrid default_grid ;







typedef struct {
  enum {
    kStlClickDisabled = 0,
    kStlClickTabSwitch,
    kStlClickTabClose,
    kStlClickFuncRun,
  } type;
  int tabnr;
  char *func;
} StlClickDefinition;


typedef struct {
  StlClickDefinition def;
  const char *start;
} StlClickRecord;


extern StlClickDefinition *tab_page_click_defs;


extern long tab_page_click_defs_size;
# 11 "/home/jesmith/neovim/src/nvim/buffer.h" 2

# 1 "/home/jesmith/neovim/src/nvim/window.h" 1
# 13 "/home/jesmith/neovim/src/nvim/buffer.h" 2


enum getf_values {
  GETF_SETMARK = 0x01,
  GETF_ALT = 0x02,
  GETF_SWITCH = 0x04,
};


enum getf_retvalues {
  GETFILE_ERROR = 1,
  GETFILE_NOT_WRITTEN = 2,
  GETFILE_SAME_FILE = 0,
  GETFILE_OPEN_OTHER = -1,
  GETFILE_UNUSED = 8,
};


enum bln_values {
  BLN_CURBUF = 1,
  BLN_LISTED = 2,
  BLN_DUMMY = 4,
  BLN_NEW = 8,
  BLN_NOOPT = 16,


  BLN_NOCURWIN = 128,
};


enum dobuf_action_values {
  DOBUF_GOTO = 0,
  DOBUF_SPLIT = 1,
  DOBUF_UNLOAD = 2,
  DOBUF_DEL = 3,
  DOBUF_WIPE = 4,
};


enum dobuf_start_values {
  DOBUF_CURRENT = 0,
  DOBUF_FIRST = 1,
  DOBUF_LAST = 2,
  DOBUF_MOD = 3,
};


enum bfa_values {
  BFA_DEL = 1,
  BFA_WIPE = 2,
  BFA_KEEP_UNDO = 4,
};





static inline void buf_set_changedtick(buf_T *const buf,
                                       const varnumber_T changedtick)
  __attribute__((nonnull)) __attribute__((always_inline));





static inline void buf_set_changedtick(buf_T *const buf, const varnumber_T changedtick)
{
  typval_T old_val = buf->changedtick_di.di_tv;
# 93 "/home/jesmith/neovim/src/nvim/buffer.h"
  buf->changedtick_di.di_tv.vval.v_number = changedtick;

  if (tv_dict_is_watched(buf->b_vars)) {
    tv_dict_watcher_notify(buf->b_vars,
                           (char *)buf->changedtick_di.di_key,
                           &buf->changedtick_di.di_tv,
                           &old_val);
  }
}

static inline varnumber_T buf_get_changedtick(const buf_T *const buf)
  __attribute__((nonnull)) __attribute__((always_inline)) __attribute__ ((pure))
  __attribute__((warn_unused_result));






static inline varnumber_T buf_get_changedtick(const buf_T *const buf)
{
  return buf->changedtick_di.di_tv.vval.v_number;
}

static inline void buf_inc_changedtick(buf_T *const buf)
  __attribute__((nonnull)) __attribute__((always_inline));






static inline void buf_inc_changedtick(buf_T *const buf)
{
  buf_set_changedtick(buf, buf_get_changedtick(buf) + 1);
}

static inline 
# 130 "/home/jesmith/neovim/src/nvim/buffer.h" 3 4
             _Bool 
# 130 "/home/jesmith/neovim/src/nvim/buffer.h"
                  buf_is_empty(buf_T *buf)
{
  return buf->b_ml.ml_line_count == 1
         && *ml_get_buf(buf, (linenr_T)1, 
# 133 "/home/jesmith/neovim/src/nvim/buffer.h" 3 4
                                         0
# 133 "/home/jesmith/neovim/src/nvim/buffer.h"
                                              ) == '\0';
}
# 13 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/change.h" 1
# 14 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/charset.h" 1
# 21 "/home/jesmith/neovim/src/nvim/charset.h"
typedef enum {
  STR2NR_DEC = 0,
  STR2NR_BIN = (1 << 0),
  STR2NR_OCT = (1 << 1),
  STR2NR_HEX = (1 << 2),
  STR2NR_OOCT = (1 << 3),







  STR2NR_FORCE = (1 << 7),

  STR2NR_ALL = STR2NR_BIN | STR2NR_OCT | STR2NR_HEX | STR2NR_OOCT,

  STR2NR_NO_OCT = STR2NR_BIN | STR2NR_HEX | STR2NR_OOCT,
  STR2NR_QUOTE = (1 << 4),
} ChStr2NrFlags;





static inline 
# 46 "/home/jesmith/neovim/src/nvim/charset.h" 3 4
             _Bool 
# 46 "/home/jesmith/neovim/src/nvim/charset.h"
                  vim_isbreak(int c)
  __attribute__((const))
  __attribute__((always_inline));



static inline 
# 52 "/home/jesmith/neovim/src/nvim/charset.h" 3 4
             _Bool 
# 52 "/home/jesmith/neovim/src/nvim/charset.h"
                  vim_isbreak(int c)
{
  return breakat_flags[(char_u)c];
}
# 16 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/context.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 1
# 5 "/home/jesmith/neovim/src/nvim/context.h" 2




typedef struct {
  msgpack_sbuffer regs;
  msgpack_sbuffer jumps;
  msgpack_sbuffer bufs;
  msgpack_sbuffer gvars;
  Array funcs;
} Context;
typedef struct { size_t size; size_t capacity; Context *items; } ContextVec;
# 32 "/home/jesmith/neovim/src/nvim/context.h"
typedef enum {
  kCtxRegs = 1,
  kCtxJumps = 2,
  kCtxBufs = 4,
  kCtxGVars = 8,
  kCtxSFuncs = 16,
  kCtxFuncs = 32,
} ContextTypeFlags;

extern int kCtxAll;
# 17 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/cursor.h" 1
# 18 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/diff.h" 1







extern int diff_context ;
extern int diff_foldcolumn ;
extern 
# 10 "/home/jesmith/neovim/src/nvim/diff.h" 3 4
      _Bool 
# 10 "/home/jesmith/neovim/src/nvim/diff.h"
           diff_need_scrollbind ;

extern 
# 12 "/home/jesmith/neovim/src/nvim/diff.h" 3 4
      _Bool 
# 12 "/home/jesmith/neovim/src/nvim/diff.h"
           need_diff_redraw ;
# 19 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/edit.h" 1
# 16 "/home/jesmith/neovim/src/nvim/edit.h"
typedef enum {
  CP_ORIGINAL_TEXT = 1,
  CP_FREE_FNAME = 2,
  CP_CONT_S_IPOS = 4,
  CP_EQUAL = 8,
  CP_ICASE = 16,
  CP_FAST = 32,
} cp_flags_T;

typedef int (*IndentGetter)(void);
# 20 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/eval/decode.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 1
# 5 "/home/jesmith/neovim/src/nvim/eval/decode.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/eval/decode.h" 2
# 22 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/eval/encode.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/msgpack.h" 1
# 5 "/home/jesmith/neovim/src/nvim/eval/encode.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/eval/encode.h" 2
# 18 "/home/jesmith/neovim/src/nvim/eval/encode.h"
int encode_vim_to_msgpack(msgpack_packer *const packer,
                          typval_T *const tv,
                          const char *const objname);
# 29 "/home/jesmith/neovim/src/nvim/eval/encode.h"
int encode_vim_to_echo(garray_T *const packer,
                       typval_T *const tv,
                       const char *const objname);


typedef struct {
  const list_T *const list;
  const listitem_T *li;
  size_t offset;
  size_t li_length;
} ListReaderState;


static inline ListReaderState encode_init_lrstate(const list_T *const list)
  FUNC_ATTR_NONNULL_ALL
{
  return (ListReaderState) {
    .list = list,
    .li = tv_list_first(list),
    .offset = 0,
    .li_length = ((&(tv_list_first(list))->li_tv)->vval.v_string == 
# 49 "/home/jesmith/neovim/src/nvim/eval/encode.h" 3 4
                                                                        ((void *)0)
                  
# 50 "/home/jesmith/neovim/src/nvim/eval/encode.h"
                 ? 0
                  : strlen((char *)((&(tv_list_first(list))->li_tv)->vval.v_string))),
  };
}


extern const char *const encode_bool_var_names[];
extern const char *const encode_special_var_names[];
# 23 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/eval/executor.h" 1





extern char *e_listidx;
# 24 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/eval/userfunc.h" 1







typedef struct {
  dict_T *fd_dict;
  char_u *fd_newkey;
  dictitem_T *fd_di;
} funcdict_T;

typedef struct funccal_entry funccal_entry_T;
struct funccal_entry {
  void *top_funccal;
  funccal_entry_T *next;
};


typedef enum {
  ERROR_UNKNOWN = 0,
  ERROR_TOOMANY,
  ERROR_TOOFEW,
  ERROR_SCRIPT,
  ERROR_DICT,
  ERROR_NONE,
  ERROR_OTHER,
  ERROR_BOTH,
  ERROR_DELETED,
  ERROR_NOTMETHOD,
} FnameTransError;


typedef int (*ArgvFunc)(int current_argcount, typval_T *argv, int argskip,
                        int called_func_argcount);


typedef struct {
  ArgvFunc argv_func;

  linenr_T firstline;
  linenr_T lastline;
  
# 44 "/home/jesmith/neovim/src/nvim/eval/userfunc.h" 3 4
 _Bool 
# 44 "/home/jesmith/neovim/src/nvim/eval/userfunc.h"
      *doesrange;
  
# 45 "/home/jesmith/neovim/src/nvim/eval/userfunc.h" 3 4
 _Bool 
# 45 "/home/jesmith/neovim/src/nvim/eval/userfunc.h"
      evaluate;
  partial_T *partial;
  dict_T *selfdict;
  typval_T *basetv;
} funcexe_T;
# 26 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 1





# 1 "/home/jesmith/neovim/src/nvim/ex_docmd.h" 1
# 22 "/home/jesmith/neovim/src/nvim/ex_docmd.h"
typedef struct {
  int save_msg_scroll;
  int save_restart_edit;
  
# 25 "/home/jesmith/neovim/src/nvim/ex_docmd.h" 3 4
 _Bool 
# 25 "/home/jesmith/neovim/src/nvim/ex_docmd.h"
      save_msg_didout;
  int save_State;
  int save_insertmode;
  
# 28 "/home/jesmith/neovim/src/nvim/ex_docmd.h" 3 4
 _Bool 
# 28 "/home/jesmith/neovim/src/nvim/ex_docmd.h"
      save_finish_op;
  long save_opcount;
  int save_reg_executing;
  tasave_T tabuf;
} save_state_T;
# 7 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 2
# 1 "/home/jesmith/neovim/src/nvim/runtime.h" 1







typedef void (*DoInRuntimepathCB)(char_u *, void *);

typedef struct {
  char *path;
  
# 12 "/home/jesmith/neovim/src/nvim/runtime.h" 3 4
 _Bool 
# 12 "/home/jesmith/neovim/src/nvim/runtime.h"
      after;
  TriState has_lua;
} SearchPathItem;

typedef struct { size_t size; size_t capacity; SearchPathItem *items; } RuntimeSearchPath;
typedef struct { size_t size; size_t capacity; char * *items; } CharVec;
# 8 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 2
# 21 "/home/jesmith/neovim/src/nvim/ex_cmds2.h"
typedef struct scriptitem_S {
  char_u *sn_name;
  
# 23 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 3 4
 _Bool 
# 23 "/home/jesmith/neovim/src/nvim/ex_cmds2.h"
      file_id_valid;
  FileID file_id;
  
# 25 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 3 4
 _Bool 
# 25 "/home/jesmith/neovim/src/nvim/ex_cmds2.h"
      sn_prof_on;
  
# 26 "/home/jesmith/neovim/src/nvim/ex_cmds2.h" 3 4
 _Bool 
# 26 "/home/jesmith/neovim/src/nvim/ex_cmds2.h"
      sn_pr_force;
  proftime_T sn_pr_child;
  int sn_pr_nest;

  int sn_pr_count;
  proftime_T sn_pr_total;
  proftime_T sn_pr_self;
  proftime_T sn_pr_start;
  proftime_T sn_pr_children;

  garray_T sn_prl_ga;
  proftime_T sn_prl_start;
  proftime_T sn_prl_children;
  proftime_T sn_prl_wait;
  linenr_T sn_prl_idx;
  int sn_prl_execed;
} scriptitem_T;
# 27 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/ex_getln.h" 1




# 1 "/home/jesmith/neovim/src/nvim/ex_cmds.h" 1
# 28 "/home/jesmith/neovim/src/nvim/ex_cmds.h"
typedef struct {
  char *sub;
  Timestamp timestamp;
  list_T *additional_elements;
} SubReplacementString;
# 6 "/home/jesmith/neovim/src/nvim/ex_getln.h" 2
# 38 "/home/jesmith/neovim/src/nvim/ex_getln.h"
typedef enum {
  HIST_DEFAULT = -2,
  HIST_INVALID = -1,
  HIST_CMD = 0,
  HIST_SEARCH,
  HIST_EXPR,
  HIST_INPUT,
  HIST_DEBUG,
} HistoryType;




typedef char_u *(*CompleteListItemGetter)(expand_T *, int);


typedef struct hist_entry {
  int hisnum;
  char_u *hisstr;
  Timestamp timestamp;
  list_T *additional_elements;
} histentry_T;
# 29 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/file_search.h" 1
# 30 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/fileio.h" 1



# 1 "/home/jesmith/neovim/src/nvim/autocmd.h" 1
# 9 "/home/jesmith/neovim/src/nvim/autocmd.h"
typedef struct {
  buf_T *save_curbuf;
  
# 11 "/home/jesmith/neovim/src/nvim/autocmd.h" 3 4
 _Bool 
# 11 "/home/jesmith/neovim/src/nvim/autocmd.h"
      use_aucmd_win;
  handle_T save_curwin_handle;
  handle_T new_curwin_handle;
  handle_T save_prevwin_handle;
  bufref_T new_curbuf;
  char_u *globaldir;
} aco_save_T;

typedef struct AutoCmd {
  char_u *cmd;

  
# 22 "/home/jesmith/neovim/src/nvim/autocmd.h" 3 4
 _Bool 
# 22 "/home/jesmith/neovim/src/nvim/autocmd.h"
      once;
  
# 23 "/home/jesmith/neovim/src/nvim/autocmd.h" 3 4
 _Bool 
# 23 "/home/jesmith/neovim/src/nvim/autocmd.h"
      nested;
  
# 24 "/home/jesmith/neovim/src/nvim/autocmd.h" 3 4
 _Bool 
# 24 "/home/jesmith/neovim/src/nvim/autocmd.h"
      last;
  sctx_T script_ctx;
  struct AutoCmd *next;
} AutoCmd;

typedef struct AutoPat {
  struct AutoPat *next;

  char_u *pat;

  regprog_T *reg_prog;
  AutoCmd *cmds;
  int group;
  int patlen;
  int buflocal_nr;
  char allow_dirs;
  char last;
} AutoPat;
# 50 "/home/jesmith/neovim/src/nvim/autocmd.h"
typedef struct AutoPatCmd {
  AutoPat *curpat;
  AutoCmd *nextcmd;
  int group;
  char_u *fname;
  char_u *sfname;
  char_u *tail;
  event_T event;
  int arg_bufnr;

  struct AutoPatCmd *next;
} AutoPatCmd;
# 70 "/home/jesmith/neovim/src/nvim/autocmd.h"
extern 
# 70 "/home/jesmith/neovim/src/nvim/autocmd.h" 3 4
      _Bool 
# 70 "/home/jesmith/neovim/src/nvim/autocmd.h"
           au_did_filetype ;
# 5 "/home/jesmith/neovim/src/nvim/fileio.h" 2

# 1 "/home/jesmith/neovim/src/nvim/os/os.h" 1
# 7 "/home/jesmith/neovim/src/nvim/fileio.h" 2
# 31 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/fold.h" 1
# 15 "/home/jesmith/neovim/src/nvim/fold.h"
typedef struct foldinfo {
  linenr_T fi_lnum;
  int fi_level;

  int fi_low_level;

  long fi_lines;
} foldinfo_T;
# 32 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/if_cscope.h" 1
# 34 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/indent.h" 1
# 35 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/indent_c.h" 1
# 36 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/lua/executor.h" 1



# 1 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 13 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h" 1
# 13 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 14 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h" 2


# 1 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 1
# 12 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/luaconf.h"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/limits.h" 1 3 4
# 13 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 14 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/luaconf.h" 2
# 17 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h" 2
# 51 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef struct lua_State lua_State;

typedef int (*lua_CFunction) (lua_State *L);





typedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);

typedef int (*lua_Writer) (lua_State *L, const void* p, size_t sz, void* ud);





typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
# 100 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef double lua_Number;



typedef ptrdiff_t lua_Integer;






extern lua_State *(lua_newstate) (lua_Alloc f, void *ud);
extern void (lua_close) (lua_State *L);
extern lua_State *(lua_newthread) (lua_State *L);

extern lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);





extern int (lua_gettop) (lua_State *L);
extern void (lua_settop) (lua_State *L, int idx);
extern void (lua_pushvalue) (lua_State *L, int idx);
extern void (lua_remove) (lua_State *L, int idx);
extern void (lua_insert) (lua_State *L, int idx);
extern void (lua_replace) (lua_State *L, int idx);
extern int (lua_checkstack) (lua_State *L, int sz);

extern void (lua_xmove) (lua_State *from, lua_State *to, int n);






extern int (lua_isnumber) (lua_State *L, int idx);
extern int (lua_isstring) (lua_State *L, int idx);
extern int (lua_iscfunction) (lua_State *L, int idx);
extern int (lua_isuserdata) (lua_State *L, int idx);
extern int (lua_type) (lua_State *L, int idx);
extern const char *(lua_typename) (lua_State *L, int tp);

extern int (lua_equal) (lua_State *L, int idx1, int idx2);
extern int (lua_rawequal) (lua_State *L, int idx1, int idx2);
extern int (lua_lessthan) (lua_State *L, int idx1, int idx2);

extern lua_Number (lua_tonumber) (lua_State *L, int idx);
extern lua_Integer (lua_tointeger) (lua_State *L, int idx);
extern int (lua_toboolean) (lua_State *L, int idx);
extern const char *(lua_tolstring) (lua_State *L, int idx, size_t *len);
extern size_t (lua_objlen) (lua_State *L, int idx);
extern lua_CFunction (lua_tocfunction) (lua_State *L, int idx);
extern void *(lua_touserdata) (lua_State *L, int idx);
extern lua_State *(lua_tothread) (lua_State *L, int idx);
extern const void *(lua_topointer) (lua_State *L, int idx);





extern void (lua_pushnil) (lua_State *L);
extern void (lua_pushnumber) (lua_State *L, lua_Number n);
extern void (lua_pushinteger) (lua_State *L, lua_Integer n);
extern void (lua_pushlstring) (lua_State *L, const char *s, size_t l);
extern void (lua_pushstring) (lua_State *L, const char *s);
extern const char *(lua_pushvfstring) (lua_State *L, const char *fmt,
                                                      va_list argp);
extern const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);
extern void (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);
extern void (lua_pushboolean) (lua_State *L, int b);
extern void (lua_pushlightuserdata) (lua_State *L, void *p);
extern int (lua_pushthread) (lua_State *L);





extern void (lua_gettable) (lua_State *L, int idx);
extern void (lua_getfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawget) (lua_State *L, int idx);
extern void (lua_rawgeti) (lua_State *L, int idx, int n);
extern void (lua_createtable) (lua_State *L, int narr, int nrec);
extern void *(lua_newuserdata) (lua_State *L, size_t sz);
extern int (lua_getmetatable) (lua_State *L, int objindex);
extern void (lua_getfenv) (lua_State *L, int idx);





extern void (lua_settable) (lua_State *L, int idx);
extern void (lua_setfield) (lua_State *L, int idx, const char *k);
extern void (lua_rawset) (lua_State *L, int idx);
extern void (lua_rawseti) (lua_State *L, int idx, int n);
extern int (lua_setmetatable) (lua_State *L, int objindex);
extern int (lua_setfenv) (lua_State *L, int idx);





extern void (lua_call) (lua_State *L, int nargs, int nresults);
extern int (lua_pcall) (lua_State *L, int nargs, int nresults, int errfunc);
extern int (lua_cpcall) (lua_State *L, lua_CFunction func, void *ud);
extern int (lua_load) (lua_State *L, lua_Reader reader, void *dt,
                                        const char *chunkname);

extern int (lua_dump) (lua_State *L, lua_Writer writer, void *data);





extern int (lua_yield) (lua_State *L, int nresults);
extern int (lua_resume) (lua_State *L, int narg);
extern int (lua_status) (lua_State *L);
# 232 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
extern int (lua_gc) (lua_State *L, int what, int data);






extern int (lua_error) (lua_State *L);

extern int (lua_next) (lua_State *L, int idx);

extern void (lua_concat) (lua_State *L, int n);

extern lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
extern void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
# 300 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
extern void lua_setlevel (lua_State *from, lua_State *to);
# 328 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h"
typedef struct lua_Debug lua_Debug;



typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);


extern int lua_getstack (lua_State *L, int level, lua_Debug *ar);
extern int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
extern const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
extern const char *lua_getupvalue (lua_State *L, int funcindex, int n);
extern const char *lua_setupvalue (lua_State *L, int funcindex, int n);
extern int lua_sethook (lua_State *L, lua_Hook func, int mask, int count);
extern lua_Hook lua_gethook (lua_State *L);
extern int lua_gethookmask (lua_State *L);
extern int lua_gethookcount (lua_State *L);


extern void *lua_upvalueid (lua_State *L, int idx, int n);
extern void lua_upvaluejoin (lua_State *L, int idx1, int n1, int idx2, int n2);
extern int lua_loadx (lua_State *L, lua_Reader reader, void *dt,
         const char *chunkname, const char *mode);
extern const lua_Number *lua_version (lua_State *L);
extern void lua_copy (lua_State *L, int fromidx, int toidx);
extern lua_Number lua_tonumberx (lua_State *L, int idx, int *isnum);
extern lua_Integer lua_tointegerx (lua_State *L, int idx, int *isnum);


extern int lua_isyieldable (lua_State *L);


struct lua_Debug {
  int event;
  const char *name;
  const char *namewhat;
  const char *what;
  const char *source;
  int currentline;
  int nups;
  int linedefined;
  int lastlinedefined;
  char short_src[60];

  int i_ci;
};
# 16 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 2





typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;

extern void (luaL_openlib) (lua_State *L, const char *libname,
                                const luaL_Reg *l, int nup);
extern void (luaL_register) (lua_State *L, const char *libname,
                                const luaL_Reg *l);
extern int (luaL_getmetafield) (lua_State *L, int obj, const char *e);
extern int (luaL_callmeta) (lua_State *L, int obj, const char *e);
extern int (luaL_typerror) (lua_State *L, int narg, const char *tname);
extern int (luaL_argerror) (lua_State *L, int numarg, const char *extramsg);
extern const char *(luaL_checklstring) (lua_State *L, int numArg,
                                                          size_t *l);
extern const char *(luaL_optlstring) (lua_State *L, int numArg,
                                          const char *def, size_t *l);
extern lua_Number (luaL_checknumber) (lua_State *L, int numArg);
extern lua_Number (luaL_optnumber) (lua_State *L, int nArg, lua_Number def);

extern lua_Integer (luaL_checkinteger) (lua_State *L, int numArg);
extern lua_Integer (luaL_optinteger) (lua_State *L, int nArg,
                                          lua_Integer def);

extern void (luaL_checkstack) (lua_State *L, int sz, const char *msg);
extern void (luaL_checktype) (lua_State *L, int narg, int t);
extern void (luaL_checkany) (lua_State *L, int narg);

extern int (luaL_newmetatable) (lua_State *L, const char *tname);
extern void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);

extern void (luaL_where) (lua_State *L, int lvl);
extern int (luaL_error) (lua_State *L, const char *fmt, ...);

extern int (luaL_checkoption) (lua_State *L, int narg, const char *def,
                                   const char *const lst[]);





extern int (luaL_ref) (lua_State *L, int t);
extern void (luaL_unref) (lua_State *L, int t, int ref);

extern int (luaL_loadfile) (lua_State *L, const char *filename);
extern int (luaL_loadbuffer) (lua_State *L, const char *buff, size_t sz,
                                  const char *name);
extern int (luaL_loadstring) (lua_State *L, const char *s);

extern lua_State *(luaL_newstate) (void);


extern const char *(luaL_gsub) (lua_State *L, const char *s, const char *p,
                                                  const char *r);

extern const char *(luaL_findtable) (lua_State *L, int idx,
                                         const char *fname, int szhint);


extern int luaL_fileresult(lua_State *L, int stat, const char *fname);
extern int luaL_execresult(lua_State *L, int stat);
extern int (luaL_loadfilex) (lua_State *L, const char *filename,
     const char *mode);
extern int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
       const char *name, const char *mode);
extern void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
    int level);
extern void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);
extern void (luaL_pushmodule) (lua_State *L, const char *modname,
       int sizehint);
extern void *(luaL_testudata) (lua_State *L, int ud, const char *tname);
extern void (luaL_setmetatable) (lua_State *L, const char *tname);
# 135 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
typedef struct luaL_Buffer {
  char *p;
  int lvl;
  lua_State *L;
  char buffer[(
# 139 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 3 4
             8192 
# 139 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
             > 16384 ? 8192 : 
# 139 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h" 3 4
             8192
# 139 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
             )];
} luaL_Buffer;
# 151 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lauxlib.h"
extern void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);
extern char *(luaL_prepbuffer) (luaL_Buffer *B);
extern void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);
extern void (luaL_addstring) (luaL_Buffer *B, const char *s);
extern void (luaL_addvalue) (luaL_Buffer *B);
extern void (luaL_pushresult) (luaL_Buffer *B);
# 5 "/home/jesmith/neovim/src/nvim/lua/executor.h" 2
# 1 "/home/jesmith/neovim/.deps/usr/include/luajit-2.1/lua.h" 1
# 6 "/home/jesmith/neovim/src/nvim/lua/executor.h" 2




# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 11 "/home/jesmith/neovim/src/nvim/lua/executor.h" 2
# 1 "/home/jesmith/neovim/src/nvim/lua/converter.h" 1
# 10 "/home/jesmith/neovim/src/nvim/lua/converter.h"
# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 11 "/home/jesmith/neovim/src/nvim/lua/converter.h" 2

typedef struct {
  LuaRef func_ref;
} LuaCallable;

typedef struct {
  LuaCallable lua_callable;
} LuaCFunctionState;
# 12 "/home/jesmith/neovim/src/nvim/lua/executor.h" 2


void nlua_add_api_functions(lua_State *lstate) __attribute__((nonnull));

extern LuaRef nlua_nil_ref ;
extern LuaRef nlua_empty_dict_ref ;

extern int nlua_refcount ;
# 37 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/mark.h" 1







# 1 "/home/jesmith/neovim/src/nvim/func_attr.h" 1
# 9 "/home/jesmith/neovim/src/nvim/mark.h" 2
# 55 "/home/jesmith/neovim/src/nvim/mark.h"
static inline int mark_global_index(const char name)
  FUNC_ATTR_CONST
{
  return (((unsigned)(name) >= 'A' && (unsigned)(name) <= 'Z')
          ? (name - 'A')
          : (ascii_isdigit(name)
             ? (('z' - 'a' + 1) + (name - '0'))
             : -1));
}


static inline int mark_local_index(const char name)
  FUNC_ATTR_CONST
{
  return (((unsigned)(name) >= 'a' && (unsigned)(name) <= 'z')
          ? (name - 'a')
          : (name == '"'
             ? ('z' - 'a' + 1)
             : (name == '^'
                ? ('z' - 'a' + 1) + 1
                : (name == '.'
                   ? ('z' - 'a' + 1) + 2
                   : -1))));
}

static inline 
# 80 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 80 "/home/jesmith/neovim/src/nvim/mark.h"
                  lt(pos_T, pos_T) __attribute__((const)) __attribute__((always_inline));
static inline 
# 81 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 81 "/home/jesmith/neovim/src/nvim/mark.h"
                  equalpos(pos_T, pos_T)
  __attribute__((const)) __attribute__((always_inline));
static inline 
# 83 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 83 "/home/jesmith/neovim/src/nvim/mark.h"
                  ltoreq(pos_T, pos_T)
  __attribute__((const)) __attribute__((always_inline));
static inline void clearpos(pos_T *)
  __attribute__((always_inline));


static inline 
# 89 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 89 "/home/jesmith/neovim/src/nvim/mark.h"
                  lt(pos_T a, pos_T b)
{
  if (a.lnum != b.lnum) {
    return a.lnum < b.lnum;
  } else if (a.col != b.col) {
    return a.col < b.col;
  } else {
    return a.coladd < b.coladd;
  }
}


static inline 
# 101 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 101 "/home/jesmith/neovim/src/nvim/mark.h"
                  equalpos(pos_T a, pos_T b)
{
  return (a.lnum == b.lnum) && (a.col == b.col) && (a.coladd == b.coladd);
}


static inline 
# 107 "/home/jesmith/neovim/src/nvim/mark.h" 3 4
             _Bool 
# 107 "/home/jesmith/neovim/src/nvim/mark.h"
                  ltoreq(pos_T a, pos_T b)
{
  return lt(a, b) || equalpos(a, b);
}


static inline void clearpos(pos_T *a)
{
  a->lnum = 0;
  a->col = 0;
  a->coladd = 0;
}
# 39 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/math.h" 1
# 40 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/misc1.h" 1



# 1 "/home/jesmith/neovim/src/nvim/os/shell.h" 1
# 9 "/home/jesmith/neovim/src/nvim/os/shell.h"
typedef enum {
  kShellOptFilter = 1,
  kShellOptExpand = 2,
  kShellOptDoOut = 4,
  kShellOptSilent = 8,
  kShellOptRead = 16,
  kShellOptWrite = 32,
  kShellOptHideMess = 64,
} ShellOpts;
# 5 "/home/jesmith/neovim/src/nvim/misc1.h" 2
# 42 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/mouse.h" 1
# 43 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/move.h" 1
# 44 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel.h" 1
# 18 "/home/jesmith/neovim/src/nvim/msgpack_rpc/channel.h"
extern MultiQueue *ch_before_blocking_events ;
# 45 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/msgpack_rpc/server.h" 1
# 46 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/ops.h" 1
# 9 "/home/jesmith/neovim/src/nvim/ops.h"
# 1 "/home/jesmith/neovim/src/nvim/extmark.h" 1
# 9 "/home/jesmith/neovim/src/nvim/extmark.h"
extern int extmark_splice_pending ;

typedef struct {
  uint64_t ns_id;
  uint64_t mark_id;
  int row;
  colnr_T col;
  int end_row;
  colnr_T end_col;
  Decoration *decor;
} ExtmarkInfo;

typedef struct { size_t size; size_t capacity; ExtmarkInfo *items; } ExtmarkInfoArray;


typedef ptrdiff_t bcount_t;



typedef struct {
  int start_row;
  colnr_T start_col;
  int old_row;
  colnr_T old_col;
  int new_row;
  colnr_T new_col;
  bcount_t start_byte;
  bcount_t old_byte;
  bcount_t new_byte;
} ExtmarkSplice;


typedef struct {
  int start_row;
  int start_col;
  int extent_row;
  int extent_col;
  int new_row;
  int new_col;
  bcount_t start_byte;
  bcount_t extent_byte;
  bcount_t new_byte;
} ExtmarkMove;


typedef struct {
  uint64_t mark;
  int old_row;
  colnr_T old_col;
  int row;
  colnr_T col;
} ExtmarkSavePos;

typedef enum {
  kExtmarkSplice,
  kExtmarkMove,
  kExtmarkUpdate,
  kExtmarkSavePos,
  kExtmarkClear,
} UndoObjectType;


struct undo_object {
  UndoObjectType type;
  union {
    ExtmarkSplice splice;
    ExtmarkMove move;
    ExtmarkSavePos savepos;
  } data;
};
# 10 "/home/jesmith/neovim/src/nvim/ops.h" 2





typedef int (*Indenter)(void);
# 77 "/home/jesmith/neovim/src/nvim/ops.h"
enum GRegFlags {
  kGRegNoExpr = 1,
  kGRegExprSrc = 2,
  kGRegList = 4,
};


typedef struct yankreg {
  char_u **y_array;
  size_t y_size;
  MotionType y_type;
  colnr_T y_width;
  Timestamp timestamp;
  dict_T *additional_data;
} yankreg_T;


typedef enum {
  YREG_PASTE,
  YREG_YANK,
  YREG_PUT,
} yreg_mode_t;






static inline int op_reg_index(const int regname)
  FUNC_ATTR_CONST
{
  if (ascii_isdigit(regname)) {
    return regname - '0';
  } else if (((unsigned)(regname) >= 'a' && (unsigned)(regname) <= 'z')) {
    return ((uint8_t)(regname) - 'a') + 10;
  } else if (((unsigned)(regname) >= 'A' && (unsigned)(regname) <= 'Z')) {
    return ((uint8_t)(regname) - 'A') + 10;
  } else if (regname == '-') {
    return 36;
  } else if (regname == '*') {
    return 37;
  } else if (regname == '+') {
    return 38;
  } else {
    return -1;
  }
}
# 47 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/option.h" 1
# 15 "/home/jesmith/neovim/src/nvim/option.h"
typedef enum {
  OPT_FREE = 1,
  OPT_GLOBAL = 2,
  OPT_LOCAL = 4,
  OPT_MODELINE = 8,
  OPT_WINONLY = 16,
  OPT_NOWIN = 32,
  OPT_ONECOLUMN = 64,
  OPT_NO_REDRAW = 128,
  OPT_SKIPRTP = 256,
} OptionFlags;
# 48 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/os/dl.h" 1
# 49 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/os/input.h" 1
# 50 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2


# 1 "/home/jesmith/neovim/src/nvim/plines.h" 1
# 53 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/popupmnu.h" 1
# 10 "/home/jesmith/neovim/src/nvim/popupmnu.h"
typedef struct {
  char_u *pum_text;
  char_u *pum_kind;
  char_u *pum_extra;
  char_u *pum_info;
} pumitem_T;

extern ScreenGrid pum_grid ;
# 54 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/quickfix.h" 1
# 55 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/regexp.h" 1
# 56 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2

# 1 "/home/jesmith/neovim/src/nvim/search.h" 1
# 62 "/home/jesmith/neovim/src/nvim/search.h"
typedef struct soffset {
  char dir;
  
# 64 "/home/jesmith/neovim/src/nvim/search.h" 3 4
 _Bool 
# 64 "/home/jesmith/neovim/src/nvim/search.h"
      line;
  
# 65 "/home/jesmith/neovim/src/nvim/search.h" 3 4
 _Bool 
# 65 "/home/jesmith/neovim/src/nvim/search.h"
      end;
  int64_t off;
} SearchOffset;


typedef struct spat {
  char_u *pat;
  
# 72 "/home/jesmith/neovim/src/nvim/search.h" 3 4
 _Bool 
# 72 "/home/jesmith/neovim/src/nvim/search.h"
      magic;
  
# 73 "/home/jesmith/neovim/src/nvim/search.h" 3 4
 _Bool 
# 73 "/home/jesmith/neovim/src/nvim/search.h"
      no_scs;
  Timestamp timestamp;
  SearchOffset off;
  dict_T *additional_data;
} SearchPattern;


typedef struct {
  linenr_T sa_stop_lnum;
  proftime_T *sa_tm;
  int sa_timed_out;
  int sa_wrapped;
} searchit_arg_T;

typedef struct searchstat {
  int cur;
  int cnt;
  
# 90 "/home/jesmith/neovim/src/nvim/search.h" 3 4
 _Bool 
# 90 "/home/jesmith/neovim/src/nvim/search.h"
      exact_match;
  int incomplete;


  int last_maxcount;
} searchstat_T;
# 58 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/sha256.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/sha256.h" 2







typedef struct {
  uint32_t total[2];
  uint32_t state[8];
  char_u buffer[64];
} context_sha256_T;
# 59 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/sign.h" 1
# 60 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/spell.h" 1







# 1 "/home/jesmith/neovim/src/nvim/spell_defs.h" 1
# 21 "/home/jesmith/neovim/src/nvim/spell_defs.h"
typedef int idx_T;
# 73 "/home/jesmith/neovim/src/nvim/spell_defs.h"
typedef struct fromto_S {
  char_u *ft_from;
  char_u *ft_to;
} fromto_T;




typedef struct salitem_S {
  char_u *sm_lead;
  int sm_leadlen;
  char_u *sm_oneof;
  char_u *sm_rules;
  char_u *sm_to;
  int *sm_lead_w;
  int *sm_oneof_w;
  int *sm_to_w;
} salitem_T;

typedef int salfirst_T;
# 113 "/home/jesmith/neovim/src/nvim/spell_defs.h"
typedef struct slang_S slang_T;

struct slang_S {
  slang_T *sl_next;
  char_u *sl_name;
  char_u *sl_fname;
  
# 119 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 119 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_add;

  char_u *sl_fbyts;
  long sl_fbyts_len;
  idx_T *sl_fidxs;
  char_u *sl_kbyts;
  idx_T *sl_kidxs;
  char_u *sl_pbyts;
  idx_T *sl_pidxs;

  char_u *sl_info;

  char_u sl_regions[8 * 2 + 1];


  char_u *sl_midword;

  hashtab_T sl_wordcount;

  int sl_compmax;
  int sl_compminlen;
  int sl_compsylmax;
  int sl_compoptions;
  garray_T sl_comppat;
  regprog_T *sl_compprog;

  char_u *sl_comprules;
  char_u *sl_compstartflags;
  char_u *sl_compallflags;
  
# 148 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 148 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_nobreak;
  char_u *sl_syllable;
  garray_T sl_syl_items;

  int sl_prefixcnt;
  regprog_T **sl_prefprog;

  garray_T sl_rep;
  int16_t sl_rep_first[256];

  garray_T sl_sal;
  salfirst_T sl_sal_first[256];

  
# 161 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 161 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_followup;
  
# 162 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 162 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_collapse;
  
# 163 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 163 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_rem_accents;
  
# 164 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 164 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_sofo;


  garray_T sl_repsal;
  int16_t sl_repsal_first[256];
  
# 169 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 169 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_nosplitsugs;
  
# 170 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 170 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_nocompoundsugs;


  time_t sl_sugtime;
  char_u *sl_sbyts;
  idx_T *sl_sidxs;
  buf_T *sl_sugbuf;
  
# 177 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 177 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_sugloaded;


  
# 180 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 180 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      sl_has_map;
  hashtab_T sl_map_hash;
  int sl_map_array[256];
  hashtab_T sl_sounddone;

};


typedef struct langp_S {
  slang_T *lp_slang;
  slang_T *lp_sallang;
  slang_T *lp_replang;
  int lp_region;
} langp_T;
# 205 "/home/jesmith/neovim/src/nvim/spell_defs.h"
typedef struct {
  
# 206 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 206 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      st_isw[256];
  
# 207 "/home/jesmith/neovim/src/nvim/spell_defs.h" 3 4
 _Bool 
# 207 "/home/jesmith/neovim/src/nvim/spell_defs.h"
      st_isu[256];
  char_u st_fold[256];
  char_u st_upper[256];
} spelltab_T;


typedef enum {
  STATE_START = 0,


  STATE_NOPREFIX,
  STATE_SPLITUNDO,
  STATE_ENDNUL,
  STATE_PLAIN,
  STATE_DEL,
  STATE_INS_PREP,
  STATE_INS,
  STATE_SWAP,
  STATE_UNSWAP,
  STATE_SWAP3,
  STATE_UNSWAP3,
  STATE_UNROT3L,
  STATE_UNROT3R,
  STATE_REP_INI,
  STATE_REP,
  STATE_REP_UNDO,
  STATE_FINAL,
} state_T;


typedef struct trystate_S {
  state_T ts_state;
  int ts_score;
  idx_T ts_arridx;
  short ts_curi;
  char_u ts_fidx;
  char_u ts_fidxtry;
  char_u ts_twordlen;
  char_u ts_prefixdepth;

  char_u ts_flags;
  char_u ts_tcharlen;
  char_u ts_tcharidx;
  char_u ts_isdiff;
  char_u ts_fcharstart;
  char_u ts_prewordlen;
  char_u ts_splitoff;
  char_u ts_splitfidx;
  char_u ts_complen;
  char_u ts_compsplit;
  char_u ts_save_badflags;
  char_u ts_delidx;

} trystate_T;
# 277 "/home/jesmith/neovim/src/nvim/spell_defs.h"
extern slang_T *first_lang;


extern char_u *int_wordlist;

extern spelltab_T spelltab;
extern int did_set_spelltab;

extern char *e_format;


typedef enum {
  SPELL_ADD_GOOD = 0,
  SPELL_ADD_BAD = 1,
  SPELL_ADD_RARE = 2,
} SpellAddType;
# 9 "/home/jesmith/neovim/src/nvim/spell.h" 2
# 61 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/state.h" 1



# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 5 "/home/jesmith/neovim/src/nvim/state.h" 2

typedef struct vim_state VimState;

typedef int (*state_check_callback)(VimState *state);
typedef int (*state_execute_callback)(VimState *state, int key);

struct vim_state {
  state_check_callback check;
  state_execute_callback execute;
};
# 62 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/syntax.h" 1
# 32 "/home/jesmith/neovim/src/nvim/syntax.h"
typedef struct {
  char *name;
  RgbValue color;
} color_name_table_T;
extern color_name_table_T color_name_table[];


extern const char *const highlight_init_cmdline[];
# 63 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/tag.h" 1
# 42 "/home/jesmith/neovim/src/nvim/tag.h"
typedef struct {
  char_u *tn_tags;
  char_u *tn_np;
  int tn_did_filefind_init;
  int tn_hf_idx;
  void *tn_search_ctx;
} tagname_T;
# 64 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/ui.h" 1




# 1 "/usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h" 1 3 4
# 6 "/home/jesmith/neovim/src/nvim/ui.h" 2






typedef enum {
  kUICmdline = 0,
  kUIPopupmenu,
  kUITabline,
  kUIWildmenu,
  kUIMessages,

  kUILinegrid,
  kUIMultigrid,
  kUIHlState,
  kUITermColors,
  kUIFloatDebug,
  kUIExtCount,
} UIExtension;

extern const char *ui_ext_names[]
# 38 "/home/jesmith/neovim/src/nvim/ui.h"
  ;

typedef struct ui_t UI;

enum {
  kLineFlagWrap = 1,
  kLineFlagInvalid = 2,
};

typedef int LineFlags;

struct ui_t {
  
# 50 "/home/jesmith/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 50 "/home/jesmith/neovim/src/nvim/ui.h"
      rgb;
  
# 51 "/home/jesmith/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 51 "/home/jesmith/neovim/src/nvim/ui.h"
      override;
  
# 52 "/home/jesmith/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 52 "/home/jesmith/neovim/src/nvim/ui.h"
      composed;
  
# 53 "/home/jesmith/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 53 "/home/jesmith/neovim/src/nvim/ui.h"
      ui_ext[kUIExtCount];
  int width;
  int height;
  int pum_nlines;
  
# 57 "/home/jesmith/neovim/src/nvim/ui.h" 3 4
 _Bool 
# 57 "/home/jesmith/neovim/src/nvim/ui.h"
      pum_pos;
  double pum_row;
  double pum_col;
  double pum_height;
  double pum_width;
  void *data;





  void (*inspect)(UI *ui, Dictionary *info);
};
# 78 "/home/jesmith/neovim/src/nvim/ui.h"
extern MultiQueue *resize_events;
# 65 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/undo.h" 1
# 66 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2
# 1 "/home/jesmith/neovim/src/nvim/version.h" 1







extern char *Version;
extern char *longVersion;
# 67 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 2




typedef enum {
  kSomeMatch,
  kSomeMatchEnd,
  kSomeMatchList,
  kSomeMatchStr,
  kSomeMatchStrPos,
} SomeMatchType;

typedef struct { khint_t n_buckets, size, n_occupied, upper_bound; khint32_t *flags; kh_cstr_t *keys; VimLFuncDef *vals; } kh_functions_t; static inline kh_functions_t *kh_init_functions(void) __attribute__((unused)); static inline kh_functions_t *kh_init_functions(void) { return (kh_functions_t *)xcalloc(1, sizeof(kh_functions_t)); } static inline void kh_dealloc_functions(kh_functions_t *h) __attribute__((unused)); static inline void kh_dealloc_functions(kh_functions_t *h) { do { void **ptr_ = (void **)&(h->keys); xfree(*ptr_); *ptr_ = 
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
((void *)0)
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
; (void)(*ptr_); } while (0); do { void **ptr_ = (void **)&(h->flags); xfree(*ptr_); *ptr_ = 
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
((void *)0)
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
; (void)(*ptr_); } while (0); do { void **ptr_ = (void **)&(h->vals); xfree(*ptr_); *ptr_ = 
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
((void *)0)
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
; (void)(*ptr_); } while (0); } static inline void kh_destroy_functions(kh_functions_t *h) __attribute__((unused)); static inline void kh_destroy_functions(kh_functions_t *h) { if (h) { kh_dealloc_functions(h); do { void **ptr_ = (void **)&(h); xfree(*ptr_); *ptr_ = 
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
((void *)0)
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
; (void)(*ptr_); } while (0); } } static inline void kh_clear_functions(kh_functions_t *h) __attribute__((unused)); static inline void kh_clear_functions(kh_functions_t *h) { if (h && h->flags) { memset(h->flags, 0xaa, ((h->n_buckets) < 16? 1 : (h->n_buckets)>>4) * sizeof(khint32_t)); h->size = h->n_occupied = 0; } } static inline khint_t kh_get_functions(const kh_functions_t *h, kh_cstr_t key) __attribute__((unused)); static inline khint_t kh_get_functions(const kh_functions_t *h, kh_cstr_t key) { if (h->n_buckets) { khint_t k, i, last, mask, step = 0; mask = h->n_buckets - 1; k = __ac_X31_hash_string(key); i = k & mask; last = i; while (!((h->flags[i>>4]>>((i&0xfU)<<1))&2) && (((h->flags[i>>4]>>((i&0xfU)<<1))&1) || !(strcmp(h->keys[i], key) == 0))) { i = (i + (++step)) & mask; if (i == last) { return h->n_buckets; } } return ((h->flags[i>>4]>>((i&0xfU)<<1))&3) ? h->n_buckets : i; } else { return 0; } } static inline void kh_resize_functions(kh_functions_t *h, khint_t new_n_buckets) __attribute__((unused)); static inline void kh_resize_functions(kh_functions_t *h, khint_t new_n_buckets) { khint32_t *new_flags = 0; khint_t j = 1; { (--(new_n_buckets), (new_n_buckets)|=(new_n_buckets)>>1, (new_n_buckets)|=(new_n_buckets)>>2, (new_n_buckets)|=(new_n_buckets)>>4, (new_n_buckets)|=(new_n_buckets)>>8, (new_n_buckets)|=(new_n_buckets)>>16, ++(new_n_buckets)); if (new_n_buckets < 4) { new_n_buckets = 4; } if (h->size >= (khint_t)(new_n_buckets * 0.77 + 0.5)) { j = 0; } else { new_flags = (khint32_t *)xmalloc(((new_n_buckets) < 16? 1 : (new_n_buckets)>>4) * sizeof(khint32_t)); memset(new_flags, 0xaa, ((new_n_buckets) < 16? 1 : (new_n_buckets)>>4) * sizeof(khint32_t)); if (h->n_buckets < new_n_buckets) { kh_cstr_t *new_keys = (kh_cstr_t *)xrealloc((void *)h->keys, new_n_buckets * sizeof(kh_cstr_t)); h->keys = new_keys; if (1) { VimLFuncDef *new_vals = (VimLFuncDef *)xrealloc((void *)h->vals, new_n_buckets * sizeof(VimLFuncDef)); h->vals = new_vals; } } } } if (j) { for (j = 0; j != h->n_buckets; ++j) { if (((h->flags[j>>4]>>((j&0xfU)<<1))&3) == 0) { kh_cstr_t key = h->keys[j]; VimLFuncDef val; khint_t new_mask; new_mask = new_n_buckets - 1; if (1) { val = h->vals[j]; } (h->flags[j>>4]|=(khint_t)1ul<<((j&0xfU)<<1)); while (1) { khint_t k, i, step = 0; k = __ac_X31_hash_string(key); i = k & new_mask; while (!((new_flags[i>>4]>>((i&0xfU)<<1))&2)) { i = (i + (++step)) & new_mask; } (new_flags[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1))); if (i < h->n_buckets && ((h->flags[i>>4]>>((i&0xfU)<<1))&3) == 0) { { kh_cstr_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } if (1) { VimLFuncDef tmp = h->vals[i]; h->vals[i] = val; val = tmp; } (h->flags[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1)); } else { h->keys[i] = key; if (1) { h->vals[i] = val; } break; } } } } if (h->n_buckets > new_n_buckets) { h->keys = (kh_cstr_t *)xrealloc((void *)h->keys, new_n_buckets * sizeof(kh_cstr_t)); if (1) { h->vals = (VimLFuncDef *)xrealloc((void *)h->vals, new_n_buckets * sizeof(VimLFuncDef)); } } do { void **ptr_ = (void **)&(h->flags); xfree(*ptr_); *ptr_ = 
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
((void *)0)
# 79 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
; (void)(*ptr_); } while (0); h->flags = new_flags; h->n_buckets = new_n_buckets; h->n_occupied = h->size; h->upper_bound = (khint_t)(h->n_buckets * 0.77 + 0.5); } } static inline khint_t kh_put_functions(kh_functions_t *h, kh_cstr_t key, int *ret) __attribute__((unused)); static inline khint_t kh_put_functions(kh_functions_t *h, kh_cstr_t key, int *ret) { khint_t x; if (h->n_occupied >= h->upper_bound) { if (h->n_buckets > (h->size << 1)) { kh_resize_functions(h, h->n_buckets - 1); } else { kh_resize_functions(h, h->n_buckets + 1); } } { khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; x = site = h->n_buckets; k = __ac_X31_hash_string(key); i = k & mask; if (((h->flags[i>>4]>>((i&0xfU)<<1))&2)) { x = i; } else { last = i; while (!((h->flags[i>>4]>>((i&0xfU)<<1))&2) && (((h->flags[i>>4]>>((i&0xfU)<<1))&1) || !(strcmp(h->keys[i], key) == 0))) { if (((h->flags[i>>4]>>((i&0xfU)<<1))&1)) { site = i; } i = (i + (++step)) & mask; if (i == last) { x = site; break; } } if (x == h->n_buckets) { if (((h->flags[i>>4]>>((i&0xfU)<<1))&2) && site != h->n_buckets) { x = site; } else { x = i; } } } } if (((h->flags[x>>4]>>((x&0xfU)<<1))&2)) { h->keys[x] = key; (h->flags[x>>4]&=~(khint_t)(3ul<<((x&0xfU)<<1))); h->size++; h->n_occupied++; *ret = 1; } else if (((h->flags[x>>4]>>((x&0xfU)<<1))&1)) { h->keys[x] = key; (h->flags[x>>4]&=~(khint_t)(3ul<<((x&0xfU)<<1))); h->size++; *ret = 2; } else { *ret = 0; } return x; } static inline void kh_del_functions(kh_functions_t *h, khint_t x) __attribute__((unused)); static inline void kh_del_functions(kh_functions_t *h, khint_t x) { if (x != h->n_buckets && !((h->flags[x>>4]>>((x&0xfU)<<1))&3)) { (h->flags[x>>4]|=(khint_t)1ul<<((x&0xfU)<<1)); --h->size; } }
# 100 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static char *e_listarg = "E686: Argument of %s must be a List";
static char *e_listblobarg = "E899: Argument of %s must be a List or Blob";
static char *e_invalwindow = "E957: Invalid window number";







static va_list dummy_ap;




char_u *get_function_name(expand_T *xp, int idx)
{
  static int intidx = -1;
  char_u *name;

  if (idx == 0) {
    intidx = -1;
  }
  if (intidx < 0) {
    name = get_user_func_name(xp, idx);
    if (name != 
# 125 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 125 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
      if (*name != '\000' && *name != '<'
          && strncmp((char *)("g:"), (char *)(xp->xp_pattern), (size_t)(2)) == 0) {
        return cat_prefix_varname('g', name);
      }
      return name;
    }
  }
  while ((size_t)++intidx < ((sizeof(functions)/sizeof((functions)[0])) / ((size_t)(!(sizeof(functions) % sizeof((functions)[0])))))
         && functions[intidx].name[0] == '\0') {
  }

  if ((size_t)intidx >= ((sizeof(functions)/sizeof((functions)[0])) / ((size_t)(!(sizeof(functions) % sizeof((functions)[0])))))) {
    return 
# 138 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 138 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  }

  const char *const key = functions[intidx].name;
  const size_t key_len = strlen(key);
  memcpy(IObuff, key, key_len);
  IObuff[key_len] = '(';
  if (functions[intidx].max_argc == 0) {
    IObuff[key_len + 1] = ')';
    IObuff[key_len + 2] = '\000';
  } else {
    IObuff[key_len + 1] = '\000';
  }
  return IObuff;
}



char_u *get_expr_name(expand_T *xp, int idx)
{
  static int intidx = -1;
  char_u *name;

  if (idx == 0) {
    intidx = -1;
  }
  if (intidx < 0) {
    name = get_function_name(xp, idx);
    if (name != 
# 166 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 166 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
      return name;
    }
  }
  return get_user_var_name(xp, ++intidx);
}






const VimLFuncDef *find_internal_func(const char *const name)
  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL
{
  size_t len = strlen(name);
  return find_internal_func_gperf(name, len);
}

int call_internal_func(const char_u *const fname, const int argcount, typval_T *const argvars,
                       typval_T *const rettv)
  FUNC_ATTR_NONNULL_ALL
{
  const VimLFuncDef *const fdef = find_internal_func((const char *)fname);
  if (fdef == 
# 190 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 190 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return ERROR_UNKNOWN;
  } else if (argcount < fdef->min_argc) {
    return ERROR_TOOFEW;
  } else if (argcount > fdef->max_argc) {
    return ERROR_TOOMANY;
  }
  argvars[argcount].v_type = VAR_UNKNOWN;
  fdef->func(argvars, rettv, fdef->data);
  return ERROR_NONE;
}


int call_internal_method(const char_u *const fname, const int argcount, typval_T *const argvars,
                         typval_T *const rettv, typval_T *const basetv)
  FUNC_ATTR_NONNULL_ALL
{
  const VimLFuncDef *const fdef = find_internal_func((const char *)fname);
  if (fdef == 
# 208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return ERROR_UNKNOWN;
  } else if (fdef->base_arg == 0) {
    return ERROR_NOTMETHOD;
  } else if (argcount + 1 < fdef->min_argc) {
    return ERROR_TOOFEW;
  } else if (argcount + 1 > fdef->max_argc) {
    return ERROR_TOOMANY;
  }

  typval_T argv[20 + 1];
  const ptrdiff_t base_index
    = fdef->base_arg == 
# 220 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       (255) 
# 220 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ? argcount : fdef->base_arg - 1;
  memcpy(argv, argvars, base_index * sizeof(typval_T));
  argv[base_index] = *basetv;
  memcpy(argv + base_index + 1, argvars + base_index,
         (argcount - base_index) * sizeof(typval_T));
  argv[argcount + 1].v_type = VAR_UNKNOWN;

  fdef->func(argv, rettv, fdef->data);
  return ERROR_NONE;
}




static int non_zero_arg(typval_T *argvars)
{
  return ((argvars[0].v_type == VAR_NUMBER
           && argvars[0].vval.v_number != 0)
          || (argvars[0].v_type == VAR_BOOL
              && argvars[0].vval.v_bool == kBoolVarTrue)
          || (argvars[0].v_type == VAR_STRING
              && argvars[0].vval.v_string != 
# 241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
              
# 242 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             && *argvars[0].vval.v_string != '\000'));
}






static void float_op_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  float_T f;
  float_T (*function)(float_T) = (float_T (*)(float_T)) fptr;

  rettv->v_type = VAR_FLOAT;
  if (tv_get_float_chk(argvars, &f)) {
    rettv->vval.v_float = function(f);
  } else {
    rettv->vval.v_float = 0.0;
  }
}

static void api_wrapper(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    return;
  }

  ApiDispatchWrapper fn = (ApiDispatchWrapper)fptr;

  Array args = { .size = 0, .capacity = 0, .items = 
# 271 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0) 
# 271 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              };

  for (typval_T *tv = argvars; tv->v_type != VAR_UNKNOWN; tv++) {
    (*((((args).size == (args).capacity) ? (((args).capacity = ((args).capacity ? (args).capacity << 1 : 8), (args).items = xrealloc((args).items, sizeof((args).items[0]) * (args).capacity)), 0) : 0), ((args).items + ((args).size++))) = (vim_to_object(tv)));
  }

  Error err = { .type = kErrorTypeNone, .msg = 
# 277 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 277 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             };
  Object result = fn((((uint64_t)1) << (sizeof(uint64_t) * 8 - 1)), args, &err);

  if (((&err)->type != kErrorTypeNone)) {
    semsg_multiline((const char *)e_api_error, err.msg);
    goto end;
  }

  if (!object_to_vim(result, rettv, &err)) {
    semsg(
# 286 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 286 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("Error converting the call result: %s")
# 286 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 286 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , err.msg);
  }

end:
  api_free_array(args);
  api_free_object(result);
  api_clear_error(&err);
}




static void f_abs(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type == VAR_FLOAT) {
    float_op_wrapper(argvars, rettv, (FunPtr)&fabs);
  } else {
    varnumber_T n;
    
# 304 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 304 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 304 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 304 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

    n = tv_get_number_chk(&argvars[0], &error);
    if (error) {
      rettv->vval.v_number = -1;
    } else if (n > 0) {
      rettv->vval.v_number = n;
    } else {
      rettv->vval.v_number = -n;
    }
  }
}




static void f_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = 1;
  if (argvars[0].v_type == VAR_LIST) {
    list_T *const l = argvars[0].vval.v_list;
    if (!var_check_lock(tv_list_locked(l), "add() argument",
                        (
# 326 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       (18446744073709551615UL)
# 326 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ))) {
      tv_list_append_tv(l, &argvars[1]);
      tv_copy(&argvars[0], rettv);
    }
  } else if (argvars[0].v_type == VAR_BLOB) {
    blob_T *const b = argvars[0].vval.v_blob;
    if (b != 
# 332 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
        
# 333 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       && !var_check_lock(b->bv_lock, "add() argument", (
# 333 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                            (18446744073709551615UL)
# 333 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            ))) {
      
# 334 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 334 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          error = 
# 334 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 334 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
      const varnumber_T n = tv_get_number_chk(&argvars[1], &error);

      if (!error) {
        ga_append(&b->bv_ga, (int)n);
        tv_copy(&argvars[0], rettv);
      }
    }
  } else {
    emsg(
# 343 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 343 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listblobreq)
# 343 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 343 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        );
  }
}




static void f_and(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = tv_get_number_chk(&argvars[0], 
# 352 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       ((void *)0)
# 352 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           )
                         & tv_get_number_chk(&argvars[1], 
# 353 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 353 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );
}



static void f_api_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  Dictionary metadata = api_metadata();
  (void)object_to_vim(((Object) { .type = kObjectTypeDictionary, .data.dictionary = metadata }), rettv, 
# 361 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 361 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          );
  api_free_dictionary(metadata);
}


static void f_append(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const linenr_T lnum = tv_get_lnum(&argvars[0]);

  set_buffer_lines(curbuf, lnum, 
# 370 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                1
# 370 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    , &argvars[1], rettv);
}


static void f_appendbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *const buf = tv_get_buf(&argvars[0], 
# 376 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 376 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
  if (buf == 
# 377 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 377 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = 1;
  } else {
    const linenr_T lnum = tv_get_lnum_buf(&argvars[1], buf);
    set_buffer_lines(buf, lnum, 
# 381 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               1
# 381 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   , &argvars[2], rettv);
  }
}

static void f_argc(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type == VAR_UNKNOWN) {

    rettv->vval.v_number = ((curwin)->w_alist->al_ga.ga_len);
  } else if (argvars[0].v_type == VAR_NUMBER
             && tv_get_number(&argvars[0]) == -1) {

    rettv->vval.v_number = (global_alist.al_ga.ga_len);
  } else {

    win_T *wp = find_win_by_nr_or_id(&argvars[0]);
    if (wp != 
# 397 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 397 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      rettv->vval.v_number = ((wp)->w_alist->al_ga.ga_len);
    } else {
      rettv->vval.v_number = -1;
    }
  }
}




static void f_argidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = curwin->w_arg_idx;
}


static void f_arglistid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;
  win_T *wp = find_tabwin(&argvars[0], &argvars[1]);
  if (wp != 
# 418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    rettv->vval.v_number = wp->w_alist->id;
  }
}




static void f_argv(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  aentry_T *arglist = 
# 428 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 428 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  int argcount = -1;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    if (argvars[1].v_type == VAR_UNKNOWN) {
      arglist = ((aentry_T *)(curwin)->w_alist->al_ga.ga_data);
      argcount = ((curwin)->w_alist->al_ga.ga_len);
    } else if (argvars[1].v_type == VAR_NUMBER
               && tv_get_number(&argvars[1]) == -1) {
      arglist = ((aentry_T *)global_alist.al_ga.ga_data);
      argcount = (global_alist.al_ga.ga_len);
    } else {
      win_T *wp = find_win_by_nr_or_id(&argvars[1]);
      if (wp != 
# 441 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 441 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {

        arglist = ((aentry_T *)(wp)->w_alist->al_ga.ga_data);
        argcount = ((wp)->w_alist->al_ga.ga_len);
      }
    }
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = 
# 448 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 448 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
    int idx = tv_get_number_chk(&argvars[0], 
# 449 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
# 449 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                );
    if (arglist != 
# 450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0) 
# 450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       && idx >= 0 && idx < argcount) {
      rettv->vval.v_string = (char_u *)xstrdup((const char *)alist_name(&arglist[idx]));
    } else if (idx == -1) {
      get_arglist_as_rettv(arglist, argcount, rettv);
    }
  } else {
    get_arglist_as_rettv(((aentry_T *)(curwin)->w_alist->al_ga.ga_data), ((curwin)->w_alist->al_ga.ga_len), rettv);
  }
}


static void f_assert_beeps(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_beeps(argvars, 
# 463 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              0
# 463 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   );
}


static void f_assert_nobeep(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_beeps(argvars, 
# 469 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              1
# 469 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
}


static void f_assert_equal(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_equal_common(argvars, ASSERT_EQUAL);
}


static void f_assert_equalfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_equalfile(argvars);
}


static void f_assert_notequal(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_equal_common(argvars, ASSERT_NOTEQUAL);
}


static void f_assert_report(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  garray_T ga;

  prepare_assert_error(&ga);
  ga_concat(&ga, tv_get_string(&argvars[0]));
  assert_error(&ga);
  ga_clear(&ga);
  rettv->vval.v_number = 1;
}


static void f_assert_exception(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_exception(argvars);
}


static void f_assert_fails(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_fails(argvars);
}


static void f_assert_false(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_bool(argvars, 
# 517 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             0
# 517 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
}


static void f_assert_inrange(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_inrange(argvars);
}


static void f_assert_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_match_common(argvars, ASSERT_MATCH);
}


static void f_assert_notmatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_match_common(argvars, ASSERT_NOTMATCH);
}


static void f_assert_true(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = assert_bool(argvars, 
# 541 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             1
# 541 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
}




static void f_atan2(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  float_T fx;
  float_T fy;

  rettv->v_type = VAR_FLOAT;
  if (tv_get_float_chk(argvars, &fx) && tv_get_float_chk(&argvars[1], &fy)) {
    rettv->vval.v_float = atan2(fx, fy);
  } else {
    rettv->vval.v_float = 0.0;
  }
}




static void f_browse(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_string = 
# 565 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 565 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  rettv->v_type = VAR_STRING;
}




static void f_browsedir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  f_browse(argvars, rettv, 
# 574 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 574 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              );
}





static buf_T *find_buffer(typval_T *avar)
{
  buf_T *buf = 
# 583 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 583 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;

  if (avar->v_type == VAR_NUMBER) {
    buf = buflist_findnr((int)avar->vval.v_number);
  } else if (avar->v_type == VAR_STRING && avar->vval.v_string != 
# 587 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                 ((void *)0)
# 587 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                     ) {
    buf = buflist_findname_exp(avar->vval.v_string);
    if (buf == 
# 589 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 589 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {


      for (buf_T *bp = firstbuf; bp != 
# 592 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     ((void *)0)
# 592 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     ; bp = bp->b_next) {
        if (bp->b_fname != 
# 593 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
            
# 594 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           && (path_with_url((char *)bp->b_fname)
                || bt_nofile(bp)
                )
            && strcmp((char *)(bp->b_fname), (char *)(avar->vval.v_string)) == 0) {
          buf = bp;
          break;
        }
      }
    }
  }
  return buf;
}


static void f_bufadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *name = (char_u *)tv_get_string(&argvars[0]);

  rettv->vval.v_number = buflist_add(*name == '\000' ? 
# 612 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0) 
# 612 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        : name, 0);
}




static void f_bufexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = (find_buffer(&argvars[0]) != 
# 620 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     ((void *)0)
# 620 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
}




static void f_buflisted(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf;

  buf = find_buffer(&argvars[0]);
  rettv->vval.v_number = (buf != 
# 631 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0) 
# 631 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     && buf->b_p_bl);
}


static void f_bufload(typval_T *argvars, typval_T *unused, FunPtr fptr)
{
  buf_T *buf = get_buf_arg(&argvars[0]);

  if (buf != 
# 639 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 639 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && buf->b_ml.ml_mfp == 
# 639 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0)
# 639 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            ) {
    aco_save_T aco;

    aucmd_prepbuf(&aco, buf);
    swap_exists_action = 0;
    open_buffer(
# 644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    , 
# 644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , 0);
    aucmd_restbuf(&aco);
  }
}




static void f_bufloaded(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf;

  buf = find_buffer(&argvars[0]);
  rettv->vval.v_number = (buf != 
# 657 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0) 
# 657 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     && buf->b_ml.ml_mfp != 
# 657 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                            ((void *)0)
# 657 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                );
}




static void f_bufname(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const buf_T *buf;
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 667 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 667 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (argvars[0].v_type == VAR_UNKNOWN) {
    buf = curbuf;
  } else {
    buf = tv_get_buf_from_arg(&argvars[0]);
  }
  if (buf != 
# 673 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 673 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && buf->b_fname != 
# 673 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 673 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ) {
    rettv->vval.v_string = (char_u *)xstrdup((char *)buf->b_fname);
  }
}




static void f_bufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const buf_T *buf;
  
# 684 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 684 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 684 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 684 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  rettv->vval.v_number = -1;

  if (argvars[0].v_type == VAR_UNKNOWN) {
    buf = curbuf;
  } else {



    if (!tv_check_str_or_nr(&argvars[0])) {
      return;
    }
    emsg_off++;
    buf = tv_get_buf(&argvars[0], 
# 698 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 0
# 698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      );
    emsg_off--;
  }



  const char *name;
  if (buf == 
# 705 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
      
# 706 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     && argvars[1].v_type != VAR_UNKNOWN
      && tv_get_number_chk(&argvars[1], &error) != 0
      && !error
      && (name = tv_get_string_chk(&argvars[0])) != 
# 709 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 709 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ) {
    buf = buflist_new((char_u *)name, 
# 710 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     ((void *)0)
# 710 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , 1, 0);
  }

  if (buf != 
# 713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = buf->handle;
  }
}

static void buf_win_common(typval_T *argvars, typval_T *rettv, 
# 718 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                              _Bool 
# 718 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                   get_nr)
{
  const buf_T *const buf = tv_get_buf_from_arg(&argvars[0]);
  if (buf == 
# 721 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 721 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = -1;
    return;
  }

  int winnr = 0;
  int winid;
  
# 728 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 728 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      found_buf = 
# 728 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 728 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 729 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 729 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; wp = wp->w_next) {
    winnr++;
    if (wp->w_buffer == buf) {
      found_buf = 
# 732 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 1
# 732 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
      winid = wp->handle;
      break;
    }
  }
  rettv->vval.v_number = (found_buf ? (get_nr ? winnr : winid) : -1);
}


static void f_bufwinid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_win_common(argvars, rettv, 
# 743 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                0
# 743 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     );
}


static void f_bufwinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_win_common(argvars, rettv, 
# 749 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                1
# 749 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    );
}




buf_T *tv_get_buf(typval_T *tv, int curtab_only)
{
  char_u *name = tv->vval.v_string;
  int save_magic;
  char_u *save_cpo;
  buf_T *buf;

  if (tv->v_type == VAR_NUMBER) {
    return buflist_findnr((int)tv->vval.v_number);
  }
  if (tv->v_type != VAR_STRING) {
    return 
# 766 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 766 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  }
  if (name == 
# 768 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 768 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  || *name == '\000') {
    return curbuf;
  }
  if (name[0] == '$' && name[1] == '\000') {
    return lastbuf;
  }


  save_magic = p_magic;
  p_magic = 1;
  save_cpo = p_cpo;
  p_cpo = (char_u *)"";

  buf = buflist_findnr(buflist_findpat(name, name + strlen((char *)(name)),
                                       
# 782 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      1
# 782 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          , 
# 782 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 782 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , curtab_only));

  p_magic = save_magic;
  p_cpo = save_cpo;


  if (buf == 
# 788 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 788 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    buf = find_buffer(tv);
  }

  return buf;
}


buf_T *tv_get_buf_from_arg(typval_T *const tv) FUNC_ATTR_NONNULL_ALL
{
  if (!tv_check_str_or_nr(tv)) {
    return 
# 799 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 799 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  }
  emsg_off++;
  buf_T *const buf = tv_get_buf(tv, 
# 802 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   0
# 802 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        );
  emsg_off--;
  return buf;
}



buf_T *get_buf_arg(typval_T *arg)
{
  buf_T *buf;

  emsg_off++;
  buf = tv_get_buf(arg, 
# 814 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       0
# 814 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            );
  emsg_off--;
  if (buf == 
# 816 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 816 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    semsg(
# 817 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 817 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E158: Invalid buffer name: %s")
# 817 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 817 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           , tv_get_string(arg));
  }
  return buf;
}




static void f_byte2line(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  long boff = tv_get_number(&argvars[0]) - 1;
  if (boff < 0) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = (varnumber_T)ml_find_line_or_offset(curbuf, 0,
                                                               &boff, 
# 832 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     0
# 832 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                          );
  }
}

static void byteidx(typval_T *argvars, typval_T *rettv, int comp)
{
  const char *const str = tv_get_string_chk(&argvars[0]);
  varnumber_T idx = tv_get_number_chk(&argvars[1], 
# 839 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  ((void *)0)
# 839 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      );
  rettv->vval.v_number = -1;
  if (str == 
# 841 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 841 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || idx < 0) {
    return;
  }

  const char *t = str;
  for (; idx > 0; idx--) {
    if (*t == '\000') {
      return;
    }
    if (comp) {
      t += utf_ptr2len((const char_u *)t);
    } else {
      t += utfc_ptr2len((const char_u *)t);
    }
  }
  rettv->vval.v_number = (varnumber_T)(t - str);
}




static void f_byteidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  byteidx(argvars, rettv, 0);
}




static void f_byteidxcomp(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  byteidx(argvars, rettv, 1);
}


static void f_call(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[1].v_type != VAR_LIST) {
    emsg(
# 879 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 879 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 879 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 879 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }
  if (argvars[1].vval.v_list == 
# 882 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 882 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ) {
    return;
  }

  
# 886 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 886 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      owned = 
# 886 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 886 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  char_u *func;
  partial_T *partial = 
# 888 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 888 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  dict_T *selfdict = 
# 889 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 889 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  if (argvars[0].v_type == VAR_FUNC) {
    func = argvars[0].vval.v_string;
  } else if (argvars[0].v_type == VAR_PARTIAL) {
    partial = argvars[0].vval.v_partial;
    func = partial_name(partial);
  } else if (nlua_is_table_from_lua(&argvars[0])) {
    func = nlua_register_table_as_callable(&argvars[0]);
    owned = 
# 897 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           1
# 897 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  } else {
    func = (char_u *)tv_get_string(&argvars[0]);
  }

  if (*func == '\000') {
    return;
  }

  if (argvars[2].v_type != VAR_UNKNOWN) {
    if (argvars[2].v_type != VAR_DICT) {
      emsg(
# 908 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 908 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_dictreq)
# 908 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 908 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
      return;
    }
    selfdict = argvars[2].vval.v_dict;
  }

  func_call(func, &argvars[1], partial, selfdict, rettv);
  if (owned) {
    func_unref(func);
  }
}




static void f_changenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = curbuf->b_u_seq_cur;
}


static void f_chanclose(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER || (argvars[1].v_type != VAR_STRING
                                          && argvars[1].v_type != VAR_UNKNOWN)) {
    emsg(
# 940 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 940 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 940 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 940 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  ChannelPart part = kChannelPartAll;
  if (argvars[1].v_type == VAR_STRING) {
    char *stream = (char *)argvars[1].vval.v_string;
    if (!strcmp(stream, "stdin")) {
      part = kChannelPartStdin;
    } else if (!strcmp(stream, "stdout")) {
      part = kChannelPartStdout;
    } else if (!strcmp(stream, "stderr")) {
      part = kChannelPartStderr;
    } else if (!strcmp(stream, "rpc")) {
      part = kChannelPartRpc;
    } else {
      semsg(
# 956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)("Invalid channel stream \"%s\"")
# 956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             , stream);
      return;
    }
  }
  const char *error;
  rettv->vval.v_number = channel_close(argvars[0].vval.v_number, part, &error);
  if (!rettv->vval.v_number) {
    emsg(error);
  }
}


static void f_chansend(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type == VAR_UNKNOWN) {

    emsg(
# 979 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 979 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 979 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 979 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  ptrdiff_t input_len = 0;
  char *input = 
# 984 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 984 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  if (argvars[1].v_type == VAR_BLOB) {
    const blob_T *const b = argvars[1].vval.v_blob;
    input_len = tv_blob_len(b);
    if (input_len > 0) {
      input = xmemdup(b->bv_ga.ga_data, input_len);
    }
  } else {
    input = save_tv_as_string(&argvars[1], &input_len, 
# 992 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      0
# 992 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           );
  }

  if (!input) {


    return;
  }
  uint64_t id = argvars[0].vval.v_number;
  const char *error = 
# 1001 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 1001 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  rettv->vval.v_number = channel_send(id, input, input_len, 
# 1002 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           1
# 1002 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               , &error);
  if (error) {
    emsg(error);
  }
}




static void f_char2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (!tv_check_num(&argvars[1])) {
      return;
    }
  }

  rettv->vval.v_number = utf_ptr2char((const char_u *)tv_get_string(&argvars[0]));
}


static void f_charidx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;

  if (argvars[0].v_type != VAR_STRING
      || argvars[1].v_type != VAR_NUMBER
      || (argvars[2].v_type != VAR_UNKNOWN
          && argvars[2].v_type != VAR_NUMBER)) {
    emsg(
# 1031 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1031 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1031 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1031 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  const char *str = tv_get_string_chk(&argvars[0]);
  varnumber_T idx = tv_get_number_chk(&argvars[1], 
# 1036 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  ((void *)0)
# 1036 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      );
  if (str == 
# 1037 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 1037 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || idx < 0) {
    return;
  }
  int countcc = 0;
  if (argvars[2].v_type != VAR_UNKNOWN) {
    countcc = (int)tv_get_number(&argvars[2]);
  }
  if (countcc < 0 || countcc > 1) {
    emsg(
# 1045 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1045 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1045 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1045 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  int (*ptr2len)(const char_u *);
  if (countcc) {
    ptr2len = utf_ptr2len;
  } else {
    ptr2len = utfc_ptr2len;
  }

  const char *p;
  int len;
  for (p = str, len = 0; p <= str + idx; len++) {
    if (*p == '\000') {
      return;
    }
    p += ptr2len((const char_u *)p);
  }

  rettv->vval.v_number = len > 0 ? len - 1 : 0;
}


static void f_chdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *cwd;
  CdScope scope = kCdScopeGlobal;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 1075 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 1075 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (argvars[0].v_type != VAR_STRING) {


    return;
  }


  cwd = xmalloc(4096);
  if (cwd != 
# 1085 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1085 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    if (os_dirname(cwd, 4096) != 0) {



      rettv->vval.v_string = vim_strsave(cwd);
    }
    xfree(cwd);
  }

  if (curwin->w_localdir != 
# 1095 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 1095 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ) {
    scope = kCdScopeWindow;
  } else if (curtab->tp_localdir != 
# 1097 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
# 1097 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ) {
    scope = kCdScopeTabpage;
  }

  if (!changedir_func(argvars[0].vval.v_string, scope)) {

    do { void **ptr_ = (void **)&(rettv->vval.v_string); xfree(*ptr_); *ptr_ = 
# 1103 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 1103 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; (void)(*ptr_); } while (0);
  }
}




static void f_cindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  pos_T pos;
  linenr_T lnum;

  pos = curwin->w_cursor;
  lnum = tv_get_lnum(argvars);
  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {
    curwin->w_cursor.lnum = lnum;
    rettv->vval.v_number = get_c_indent();
    curwin->w_cursor = pos;
  } else {
    rettv->vval.v_number = -1;
  }
}

static win_T *get_optional_window(typval_T *argvars, int idx)
{
  win_T *win = curwin;

  if (argvars[idx].v_type != VAR_UNKNOWN) {
    win = find_win_by_nr_or_id(&argvars[idx]);
    if (win == 
# 1132 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 1132 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      emsg(
# 1133 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 1133 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invalwindow)
# 1133 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 1133 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          );
      return 
# 1134 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1134 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;
    }
  }
  return win;
}




static void f_clearmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *win = get_optional_window(argvars, 0);

  if (win != 
# 1147 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1147 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    clear_matches(win);
  }
}




static void f_col(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  colnr_T col = 0;
  pos_T *fp;
  int fnum = curbuf->handle;

  fp = var2fpos(&argvars[0], 0, &fnum);
  if (fp != 
# 1162 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0) 
# 1162 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                && fnum == curbuf->handle) {
    if (fp->col == MAXCOL) {

      if (fp->lnum <= curbuf->b_ml.ml_line_count) {
        col = (colnr_T)strlen((char *)(ml_get(fp->lnum))) + 1;
      } else {
        col = MAXCOL;
      }
    } else {
      col = fp->col + 1;


      if (virtual_active() && fp == &curwin->w_cursor) {
        char_u *p = get_cursor_pos_ptr();

        if (curwin->w_cursor.coladd
            >= (colnr_T)win_chartabsize(curwin, p,
                                        (curwin->w_virtcol
                                         - curwin->w_cursor.coladd))) {
          int l;

          if (*p != '\000' && p[(l = utfc_ptr2len(p))] == '\000') {
            col += l;
          }
        }
      }
    }
  }
  rettv->vval.v_number = col;
}




static void f_complete(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if ((State & 0x10) == 0) {
    emsg(
# 1199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E785: complete() can only be used in Insert mode")
# 1199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );
    return;
  }



  if (!undo_allowed(curbuf)) {
    return;
  }

  if (argvars[1].v_type != VAR_LIST) {
    emsg(
# 1210 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1210 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1210 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1210 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  const colnr_T startcol = tv_get_number_chk(&argvars[0], 
# 1214 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 1214 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );
  if (startcol <= 0) {
    return;
  }

  set_completion(startcol - 1, argvars[1].vval.v_list);
}




static void f_complete_add(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = ins_compl_add_tv(&argvars[0], 0, 
# 1227 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         0
# 1227 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              );
}




static void f_complete_check(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int saved = RedrawingDisabled;

  RedrawingDisabled = 0;
  ins_compl_check_keys(0, 
# 1238 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         1
# 1238 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             );
  rettv->vval.v_number = compl_interrupted;
  RedrawingDisabled = saved;
}


static void f_complete_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);

  list_T *what_list = 
# 1248 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 1248 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    if (argvars[0].v_type != VAR_LIST) {
      emsg(
# 1252 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 1252 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_listreq)
# 1252 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 1252 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
      return;
    }
    what_list = argvars[0].vval.v_list;
  }
  get_complete_info(what_list, rettv->vval.v_dict);
}




static void f_confirm(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char buf[NUMBUFLEN];
  char buf2[NUMBUFLEN];
  const char *message;
  const char *buttons = 
# 1268 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 1268 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  int def = 1;
  int type = 0;
  const char *typestr;
  
# 1272 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 1272 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 1272 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 1272 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  message = tv_get_string_chk(&argvars[0]);
  if (message == 
# 1275 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 1275 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
    error = 
# 1276 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           1
# 1276 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  }
  if (argvars[1].v_type != VAR_UNKNOWN) {
    buttons = tv_get_string_buf_chk(&argvars[1], buf);
    if (buttons == 
# 1280 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 1280 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
      error = 
# 1281 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             1
# 1281 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
    }
    if (argvars[2].v_type != VAR_UNKNOWN) {
      def = tv_get_number_chk(&argvars[2], &error);
      if (argvars[3].v_type != VAR_UNKNOWN) {
        typestr = tv_get_string_buf_chk(&argvars[3], buf2);
        if (typestr == 
# 1287 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 1287 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ) {
          error = 
# 1288 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 1
# 1288 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
        } else {
          switch ((((*typestr) < 'a' || (*typestr) > 'z') ? (*typestr) : (*typestr) - ('a' - 'A'))) {
          case 'E':
            type = 1; break;
          case 'Q':
            type = 4; break;
          case 'I':
            type = 3; break;
          case 'W':
            type = 2; break;
          case 'G':
            type = 0; break;
          }
        }
      }
    }
  }

  if (buttons == 
# 1307 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 1307 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     || *buttons == '\000') {
    buttons = 
# 1308 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 1308 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)("&Ok")
# 1308 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 1308 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  }

  if (!error) {
    rettv->vval.v_number = do_dialog(type, 
# 1312 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 1312 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              , (char_u *)message, (char_u *)buttons, def, 
# 1312 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                                           ((void *)0)
# 1312 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                               ,
                                     
# 1313 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    0
# 1313 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         );
  }
}




static void f_copy(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  var_item_copy(
# 1322 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 1322 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   , &argvars[0], rettv, 
# 1322 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         0
# 1322 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              , 0);
}




static void f_count(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  long n = 0;
  int ic = 0;
  
# 1332 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 1332 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 1332 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 1332 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  if (argvars[2].v_type != VAR_UNKNOWN) {
    ic = tv_get_number_chk(&argvars[2], &error);
  }

  if (argvars[0].v_type == VAR_STRING) {
    const char_u *expr = (char_u *)tv_get_string_chk(&argvars[1]);
    const char_u *p = argvars[0].vval.v_string;

    if (!error && expr != 
# 1342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0) 
# 1342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              && *expr != '\000' && p != 
# 1342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 1342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          ) {
      if (ic) {
        const size_t len = strlen((char *)(expr));

        while (*p != '\000') {
          if (mb_strnicmp(p, expr, len) == 0) {
            n++;
            p += len;
          } else {
            (p += utfc_ptr2len((char_u *)p));
          }
        }
      } else {
        char_u *next;
        while ((next = (char_u *)strstr((char *)p, (char *)expr)) != 
# 1356 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                    ((void *)0)
# 1356 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        ) {
          n++;
          p = next + strlen((char *)(expr));
        }
      }
    }
  } else if (argvars[0].v_type == VAR_LIST) {
    listitem_T *li;
    list_T *l;
    long idx;

    if ((l = argvars[0].vval.v_list) != 
# 1367 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 1367 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ) {
      li = tv_list_first(l);
      if (argvars[2].v_type != VAR_UNKNOWN) {
        if (argvars[3].v_type != VAR_UNKNOWN) {
          idx = tv_get_number_chk(&argvars[3], &error);
          if (!error) {
            li = tv_list_find(l, idx);
            if (li == 
# 1374 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 1374 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
              semsg(
# 1375 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   dcgettext (((void *)0), 
# 1375 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   (char *)(e_listidx)
# 1375 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   , 5)
# 1375 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               , (int64_t)idx);
            }
          }
        }
        if (error) {
          li = 
# 1380 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 1380 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
        }
      }

      for (; li != 
# 1384 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 1384 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ; li = ((li)->li_next)) {
        if (tv_equal((&(li)->li_tv), &argvars[1], ic, 
# 1385 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                          0
# 1385 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               )) {
          n++;
        }
      }
    }
  } else if (argvars[0].v_type == VAR_DICT) {
    int todo;
    dict_T *d;
    hashitem_T *hi;

    if ((d = argvars[0].vval.v_dict) != 
# 1395 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 1395 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ) {
      if (argvars[2].v_type != VAR_UNKNOWN) {
        if (argvars[3].v_type != VAR_UNKNOWN) {
          emsg(
# 1398 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              dcgettext (((void *)0), 
# 1398 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              (char *)(e_invarg)
# 1398 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              , 5)
# 1398 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         );
        }
      }

      todo = error ? 0 : (int)d->dv_hashtab.ht_used;
      for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi) {
        if (!((hi)->hi_key == 
# 1404 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 1404 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            || (hi)->hi_key == (char_u *)&hash_removed)) {
          todo--;
          if (tv_equal(&((dictitem_T *)((hi)->hi_key - 
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       __builtin_offsetof (
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       dictitem_T
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       , 
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       di_key
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       )
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ))->di_tv, &argvars[1], ic, 
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  0
# 1406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       )) {
            n++;
          }
        }
      }
    }
  } else {
    semsg(
# 1413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listdictarg)
# 1413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "count()");
  }
  rettv->vval.v_number = n;
}






static void f_cscope_connection(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int num = 0;
  const char *dbpath = 
# 1426 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 1426 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  const char *prepend = 
# 1427 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 1427 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  char buf[NUMBUFLEN];

  if (argvars[0].v_type != VAR_UNKNOWN
      && argvars[1].v_type != VAR_UNKNOWN) {
    num = (int)tv_get_number(&argvars[0]);
    dbpath = tv_get_string(&argvars[1]);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      prepend = tv_get_string_buf(&argvars[2], buf);
    }
  }

  rettv->vval.v_number = cs_connection(num, (char_u *)dbpath,
                                       (char_u *)prepend);
}


static void f_ctxget(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  size_t index = 0;
  if (argvars[0].v_type == VAR_NUMBER) {
    index = argvars[0].vval.v_number;
  } else if (argvars[0].v_type != VAR_UNKNOWN) {
    semsg(
# 1450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected nothing or a Number as an argument");
    return;
  }

  Context *ctx = ctx_get(index);
  if (ctx == 
# 1455 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1455 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    semsg(
# 1456 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1456 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invargNval)
# 1456 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1456 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        , "index", "out of bounds");
    return;
  }

  Dictionary ctx_dict = ctx_to_dict(ctx);
  Error err = { .type = kErrorTypeNone, .msg = 
# 1461 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 1461 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             };
  object_to_vim(((Object) { .type = kObjectTypeDictionary, .data.dictionary = ctx_dict }), rettv, &err);
  api_free_dictionary(ctx_dict);
  api_clear_error(&err);
}


static void f_ctxpop(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (!ctx_restore(
# 1470 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 1470 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      , kCtxAll)) {
    emsg(
# 1471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("Context stack is empty")
# 1471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );
  }
}


static void f_ctxpush(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int types = kCtxAll;
  if (argvars[0].v_type == VAR_LIST) {
    types = 0;
    do { list_T *const l_ = (argvars[0].vval.v_list); ; if (l_ != 
# 1481 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 1481 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for ( listitem_T *li = l_->lv_first; li != 
# 1481 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 1481 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; li = li->li_next) { { typval_T *tv_li = (&(li)->li_tv); if (tv_li->v_type == VAR_STRING) { if (strequal((char *)tv_li->vval.v_string, "regs")) { types |= kCtxRegs; } else if (strequal((char *)tv_li->vval.v_string, "jumps")) { types |= kCtxJumps; } else if (strequal((char *)tv_li->vval.v_string, "bufs")) { types |= kCtxBufs; } else if (strequal((char *)tv_li->vval.v_string, "gvars")) { types |= kCtxGVars; } else if (strequal((char *)tv_li->vval.v_string, "sfuncs")) { types |= kCtxSFuncs; } else if (strequal((char *)tv_li->vval.v_string, "funcs")) { types |= kCtxFuncs; } } } } } } while (0)
# 1498 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      ;
  } else if (argvars[0].v_type != VAR_UNKNOWN) {
    semsg(
# 1500 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1500 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1500 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1500 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected nothing or a List as an argument");
    return;
  }
  ctx_save(
# 1503 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 1503 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              , types);
}


static void f_ctxset(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_DICT) {
    semsg(
# 1510 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1510 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1510 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1510 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected dictionary as first argument");
    return;
  }

  size_t index = 0;
  if (argvars[1].v_type == VAR_NUMBER) {
    index = argvars[1].vval.v_number;
  } else if (argvars[1].v_type != VAR_UNKNOWN) {
    semsg(
# 1518 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1518 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1518 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1518 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected nothing or a Number as second argument");
    return;
  }

  Context *ctx = ctx_get(index);
  if (ctx == 
# 1523 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1523 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    semsg(
# 1524 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1524 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invargNval)
# 1524 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1524 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        , "index", "out of bounds");
    return;
  }

  int save_did_emsg = did_emsg;
  did_emsg = 
# 1529 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 1529 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;

  Dictionary dict = vim_to_object(&argvars[0]).data.dictionary;
  Context tmp = (Context) { .regs = (msgpack_sbuffer) { .size = 0, .data = 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               , .alloc = 0, }, .jumps = (msgpack_sbuffer) { .size = 0, .data = 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               , .alloc = 0, }, .bufs = (msgpack_sbuffer) { .size = 0, .data = 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               , .alloc = 0, }, .gvars = (msgpack_sbuffer) { .size = 0, .data = 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               , .alloc = 0, }, .funcs = { .size = 0, .capacity = 0, .items = 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 1532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               }, };
  ctx_from_dict(dict, &tmp);

  if (did_emsg) {
    ctx_free(&tmp);
  } else {
    ctx_free(ctx);
    *ctx = tmp;
  }

  api_free_dictionary(dict);
  did_emsg = save_did_emsg;
}


static void f_ctxsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = ctx_size();
}







static void f_cursor(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  long line, col;
  long coladd = 0;
  
# 1563 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 1563 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      set_curswant = 
# 1563 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     1
# 1563 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;

  rettv->vval.v_number = -1;
  if (argvars[1].v_type == VAR_UNKNOWN) {
    pos_T pos;
    colnr_T curswant = -1;

    if (list2fpos(argvars, &pos, 
# 1570 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0)
# 1570 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    , &curswant) == 0) {
      emsg(
# 1571 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 1571 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 1571 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 1571 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }

    line = pos.lnum;
    col = pos.col;
    coladd = pos.coladd;
    if (curswant >= 0) {
      curwin->w_curswant = curswant - 1;
      set_curswant = 
# 1580 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 1580 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
    }
  } else {
    line = tv_get_lnum(argvars);
    col = (long)tv_get_number_chk(&argvars[1], 
# 1584 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
# 1584 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
    if (argvars[2].v_type != VAR_UNKNOWN) {
      coladd = (long)tv_get_number_chk(&argvars[2], 
# 1586 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 1586 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
    }
  }
  if (line < 0 || col < 0
      || coladd < 0) {
    return;
  }
  if (line > 0) {
    curwin->w_cursor.lnum = line;
  }
  if (col > 0) {
    curwin->w_cursor.col = col - 1;
  }
  curwin->w_cursor.coladd = coladd;


  check_cursor();

  mb_adjust_cursor();

  curwin->w_set_curswant = set_curswant;
  rettv->vval.v_number = 0;
}


static void f_debugbreak(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int pid;

  rettv->vval.v_number = 0;
  pid = (int)tv_get_number(&argvars[0]);
  if (pid == 0) {
    emsg(
# 1618 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1618 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1618 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1618 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
  } else {
# 1629 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    uv_kill(pid, 
# 1629 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                2
# 1629 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );

  }
}


static void f_deepcopy(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int noref = 0;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    noref = tv_get_number_chk(&argvars[1], 
# 1640 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 1640 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              );
  }
  if (noref < 0 || noref > 1) {
    emsg(
# 1643 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1643 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1643 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1643 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
  } else {
    var_item_copy(
# 1645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 1645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , &argvars[0], rettv, 
# 1645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                           1
# 1645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               , (noref == 0
                                                   ? get_copyID()
                                                   : 0));
  }
}


static void f_delete(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;
  if (check_secure()) {
    return;
  }

  const char *const name = tv_get_string(&argvars[0]);
  if (*name == '\000') {
    emsg(
# 1661 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 1661 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 1661 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 1661 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  char nbuf[NUMBUFLEN];
  const char *flags;
  if (argvars[1].v_type != VAR_UNKNOWN) {
    flags = tv_get_string_buf(&argvars[1], nbuf);
  } else {
    flags = "";
  }

  if (*flags == '\000') {

    rettv->vval.v_number = os_remove(name) == 0 ? 0 : -1;
  } else if (strcmp(flags, "d") == 0) {

    rettv->vval.v_number = os_rmdir(name) == 0 ? 0 : -1;
  } else if (strcmp(flags, "rf") == 0) {

    rettv->vval.v_number = delete_recursive(name);
  } else {
    semsg(
# 1683 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1683 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invexpr2)
# 1683 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1683 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      , flags);
  }
}


static void f_dictwatcheradd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_DICT) {
    semsg(
# 1695 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1695 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1695 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1695 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "dict");
    return;
  } else if (argvars[0].vval.v_dict == 
# 1697 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      ((void *)0)
# 1697 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ) {
    const char *const arg_errmsg = 
# 1698 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  dcgettext (((void *)0), 
# 1698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  (char *)("dictwatcheradd() argument")
# 1698 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  , 5)
# 1698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                ;
    const size_t arg_errmsg_len = strlen(arg_errmsg);
    semsg(
# 1700 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1700 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_readonlyvar)
# 1700 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1700 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , (int)arg_errmsg_len, arg_errmsg);
    return;
  }

  if (argvars[1].v_type != VAR_STRING && argvars[1].v_type != VAR_NUMBER) {
    semsg(
# 1705 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1705 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1705 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1705 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "key");
    return;
  }

  const char *const key_pattern = tv_get_string_chk(argvars + 1);
  if (key_pattern == 
# 1710 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 1710 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {
    return;
  }
  const size_t key_pattern_len = strlen(key_pattern);

  Callback callback;
  if (!callback_from_typval(&callback, &argvars[2])) {
    semsg(
# 1717 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1717 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1717 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1717 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "funcref");
    return;
  }

  tv_dict_watcher_add(argvars[0].vval.v_dict, key_pattern, key_pattern_len,
                      callback);
}


static void f_dictwatcherdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_DICT) {
    semsg(
# 1733 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1733 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1733 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1733 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "dict");
    return;
  }

  if (argvars[2].v_type != VAR_FUNC && argvars[2].v_type != VAR_STRING) {
    semsg(
# 1738 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 1738 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 1738 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 1738 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "funcref");
    return;
  }

  const char *const key_pattern = tv_get_string_chk(argvars + 1);
  if (key_pattern == 
# 1743 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 1743 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {
    return;
  }

  Callback callback;
  if (!callback_from_typval(&callback, &argvars[2])) {
    return;
  }

  if (!tv_dict_watcher_remove(argvars[0].vval.v_dict, key_pattern,
                              strlen(key_pattern), callback)) {
    emsg("Couldn't find a watcher matching key and callback");
  }

  callback_free(&callback);
}


static void f_deletebufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T last;
  buf_T *curbuf_save = 
# 1764 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 1764 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  win_T *curwin_save = 
# 1765 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 1765 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;

  buf_T *const buf = tv_get_buf(&argvars[0], 
# 1767 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 1767 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
  if (buf == 
# 1768 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 1768 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = 1;
    return;
  }
  const 
# 1772 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 1772 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            is_curbuf = buf == curbuf;

  const linenr_T first = tv_get_lnum_buf(&argvars[1], buf);
  if (argvars[2].v_type != VAR_UNKNOWN) {
    last = tv_get_lnum_buf(&argvars[2], buf);
  } else {
    last = first;
  }

  if (buf->b_ml.ml_mfp == 
# 1781 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0) 
# 1781 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              || first < 1
      || first > buf->b_ml.ml_line_count || last < first) {
    rettv->vval.v_number = 1;
    return;
  }

  if (!is_curbuf) {
    curbuf_save = curbuf;
    curwin_save = curwin;
    curbuf = buf;
    find_win_for_curbuf();
  }
  if (last > curbuf->b_ml.ml_line_count) {
    last = curbuf->b_ml.ml_line_count;
  }
  const long count = last - first + 1;



  if (u_sync_once == 2) {
    u_sync_once = 1;
    u_sync(
# 1802 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          1
# 1802 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              );
  }

  if (u_save(first - 1, last + 1) == 0) {
    rettv->vval.v_number = 1;
  } else {
    for (linenr_T lnum = first; lnum <= last; lnum++) {
      ml_delete(first, 
# 1809 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      1
# 1809 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          );
    }

    for (tabpage_T *tp = first_tabpage; tp != 
# 1812 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 1812 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; tp = tp->tp_next) for (win_T *wp = ((tp) == curtab) ? firstwin : (tp)->tp_firstwin; wp != 
# 1812 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 1812 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; wp = wp->w_next) {
      if (wp->w_buffer == buf) {
        if (wp->w_cursor.lnum > last) {
          wp->w_cursor.lnum -= count;
        } else if (wp->w_cursor.lnum > first) {
          wp->w_cursor.lnum = first;
        }
        if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count) {
          wp->w_cursor.lnum = wp->w_buffer->b_ml.ml_line_count;
        }
      }
    }
    check_cursor_col();
    deleted_lines_mark(first, count);
  }

  if (!is_curbuf) {
    curbuf = curbuf_save;
    curwin = curwin_save;
  }
}




static void f_did_filetype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = did_filetype;
}




static void f_diff_filler(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = 
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        (((
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        0
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        )>(
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        diff_check(curwin, tv_get_lnum(argvars))
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ))?(
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        0
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ):(
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        diff_check(curwin, tv_get_lnum(argvars))
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ))
# 1847 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        ;
}




static void f_diff_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum = tv_get_lnum(argvars);
  static linenr_T prev_lnum = 0;
  static int changedtick = 0;
  static int fnum = 0;
  static int change_start = 0;
  static int change_end = 0;
  static hlf_T hlID = (hlf_T)0;
  int filler_lines;
  int col;

  if (lnum < 0) {
    lnum = 0;
  }
  if (lnum != prev_lnum
      || changedtick != buf_get_changedtick(curbuf)
      || fnum != curbuf->handle) {

    filler_lines = diff_check(curwin, lnum);
    if (filler_lines < 0) {
      if (filler_lines == -1) {
        change_start = MAXCOL;
        change_end = -1;
        if (diff_find_change(curwin, lnum, &change_start, &change_end)) {
          hlID = HLF_ADD;
        } else {
          hlID = HLF_CHD;
        }
      } else {
        hlID = HLF_ADD;
      }
    } else {
      hlID = (hlf_T)0;
    }
    prev_lnum = lnum;
    changedtick = buf_get_changedtick(curbuf);
    fnum = curbuf->handle;
  }

  if (hlID == HLF_CHD || hlID == HLF_TXD) {
    col = tv_get_number(&argvars[1]) - 1;
    if (col >= change_start && col <= change_end) {
      hlID = HLF_TXD;
    } else {
      hlID = HLF_CHD;
    }
  }
  rettv->vval.v_number = hlID == (hlf_T)0 ? 0 : (int)(hlID + 1);
}




static void f_empty(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 1909 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 1909 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      n = 
# 1909 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          1
# 1909 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;

  switch (argvars[0].v_type) {
  case VAR_STRING:
  case VAR_FUNC:
    n = argvars[0].vval.v_string == 
# 1914 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
        
# 1915 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       || *argvars[0].vval.v_string == '\000';
    break;
  case VAR_PARTIAL:
    n = 
# 1918 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       0
# 1918 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            ;
    break;
  case VAR_NUMBER:
    n = argvars[0].vval.v_number == 0;
    break;
  case VAR_FLOAT:
    n = argvars[0].vval.v_float == 0.0;
    break;
  case VAR_LIST:
    n = (tv_list_len(argvars[0].vval.v_list) == 0);
    break;
  case VAR_DICT:
    n = (tv_dict_len(argvars[0].vval.v_dict) == 0);
    break;
  case VAR_BOOL:
    switch (argvars[0].vval.v_bool) {
    case kBoolVarTrue:
      n = 
# 1935 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         0
# 1935 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
      break;
    case kBoolVarFalse:
      n = 
# 1938 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         1
# 1938 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
      break;
    }
    break;
  case VAR_SPECIAL:
    n = argvars[0].vval.v_special == kSpecialVarNull;
    break;
  case VAR_BLOB:
    n = (tv_blob_len(argvars[0].vval.v_blob) == 0);
    break;
  case VAR_UNKNOWN:
    internal_error("f_empty(UNKNOWN)");
    break;
  }

  rettv->vval.v_number = n;
}


static void f_environ(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);

  size_t env_size = os_get_fullenv_size();
  char **env = xmalloc(sizeof(*env) * (env_size + 1));
  env[env_size] = 
# 1963 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 1963 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

  os_copy_fullenv(env, env_size);

  for (ssize_t i = env_size - 1; i >= 0; i--) {
    const char *str = env[i];
    const char * const end = strchr(str + (str[0] == '=' ? 1 : 0),
                                    '=');
    
# 1971 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 1971 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
    ptrdiff_t len = end - str;
    
# 1973 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 1973 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
    const char *value = str + len + 1;

    char c = env[i][len];
    env[i][len] = '\000';





    char *const key = xstrdup(str);


    env[i][len] = c;

    if (tv_dict_find(rettv->vval.v_dict, key, len) != 
# 1988 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     ((void *)0)
# 1988 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         ) {



      xfree(key);
      continue;
    }
    tv_dict_add_str(rettv->vval.v_dict,
                    key, len,
                    value);
    xfree(key);
  }
  os_free_fullenv(env);
}




static void f_escape(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char buf[NUMBUFLEN];

  rettv->vval.v_string = vim_strsave_escaped((const char_u *)tv_get_string(&argvars[0]),
                                             (const char_u *)tv_get_string_buf(&argvars[1], buf));
  rettv->v_type = VAR_STRING;
}


static void f_getenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *p = (char_u *)vim_getenv(tv_get_string(&argvars[0]));

  if (p == 
# 2020 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 2020 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    rettv->v_type = VAR_SPECIAL;
    rettv->vval.v_special = kSpecialVarNull;
    return;
  }
  rettv->vval.v_string = p;
  rettv->v_type = VAR_STRING;
}




static void f_eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *s = tv_get_string_chk(&argvars[0]);
  if (s != 
# 2035 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 2035 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    s = (const char *)skipwhite((const char_u *)s);
  }

  const char *const expr_start = s;
  if (s == 
# 2040 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0) 
# 2040 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               || eval1((char_u **)&s, rettv, 
# 2040 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              1
# 2040 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  ) == 0) {
    if (expr_start != 
# 2041 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0) 
# 2041 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          && !aborting()) {
      semsg(
# 2042 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 2042 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invexpr2)
# 2042 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 2042 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        , expr_start);
    }
    need_clr_eos = 
# 2044 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 2044 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
    rettv->v_type = VAR_NUMBER;
    rettv->vval.v_number = 0;
  } else if (*s != '\000') {
    emsg(
# 2048 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 2048 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_trailing)
# 2048 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 2048 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
  }
}




static void f_eventhandler(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = vgetc_busy;
}




static void f_executable(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (tv_check_for_string(&argvars[0]) == 0) {
    return;
  }


  rettv->vval.v_number = os_can_exe(tv_get_string(&argvars[0]), 
# 2070 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                               ((void *)0)
# 2070 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                   , 
# 2070 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     1
# 2070 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                         );
}

typedef struct {
  const list_T *const l;
  const listitem_T *li;
} GetListLineCookie;

static char_u *get_list_line(int c, void *cookie, int indent, 
# 2078 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                             _Bool 
# 2078 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  do_concat)
{
  GetListLineCookie *const p = (GetListLineCookie *)cookie;

  const listitem_T *const item = p->li;
  if (item == 
# 2083 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 2083 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return 
# 2084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 2084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  }
  char buf[NUMBUFLEN];
  const char *const s = tv_get_string_buf_chk((&(item)->li_tv), buf);
  p->li = ((item)->li_next);
  return (char_u *)(s == 
# 2089 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0) 
# 2089 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ? 
# 2089 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0) 
# 2089 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    : xstrdup(s));
}

static void execute_common(typval_T *argvars, typval_T *rettv, FunPtr fptr, int arg_off)
{
  const int save_msg_silent = msg_silent;
  const int save_emsg_silent = emsg_silent;
  const 
# 2096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 2096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            save_emsg_noredir = emsg_noredir;
  const 
# 2097 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 2097 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            save_redir_off = redir_off;
  garray_T *const save_capture_ga = capture_ga;
  const int save_msg_col = msg_col;
  
# 2100 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2100 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      echo_output = 
# 2100 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 2100 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;

  if (check_secure()) {
    return;
  }

  if (argvars[arg_off + 1].v_type != VAR_UNKNOWN) {
    char buf[NUMBUFLEN];
    const char *const s = tv_get_string_buf_chk(&argvars[arg_off + 1], buf);

    if (s == 
# 2110 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 2110 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      return;
    }
    if (*s == '\000') {
      echo_output = 
# 2114 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   1
# 2114 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
    }
    if (strncmp(s, "silent", 6) == 0) {
      msg_silent++;
    }
    if (strcmp(s, "silent!") == 0) {
      emsg_silent = 
# 2120 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   1
# 2120 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
      emsg_noredir = 
# 2121 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    1
# 2121 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
    }
  } else {
    msg_silent++;
  }

  garray_T capture_local;
  ga_init(&capture_local, (int)sizeof(char), 80);
  capture_ga = &capture_local;
  redir_off = 
# 2130 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 2130 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  if (!echo_output) {
    msg_col = 0;
  }

  if (argvars[arg_off].v_type != VAR_LIST) {
    do_cmdline_cmd(tv_get_string(&argvars[arg_off]));
  } else if (argvars[arg_off].vval.v_list != 
# 2137 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
# 2137 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                ) {
    list_T *const list = argvars[arg_off].vval.v_list;
    tv_list_ref(list);
    GetListLineCookie cookie = {
      .l = list,
      .li = tv_list_first(list),
    };
    do_cmdline(
# 2144 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 2144 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  , get_list_line, (void *)&cookie,
               0x02|0x01|0x04|0x08);
    tv_list_unref(list);
  }
  msg_silent = save_msg_silent;
  emsg_silent = save_emsg_silent;
  emsg_noredir = save_emsg_noredir;
  redir_off = save_redir_off;

  if (echo_output) {


    msg_col = 0;
  } else {


    msg_col = save_msg_col;
  }

  ga_append(capture_ga, '\000');
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = capture_ga->ga_data;

  capture_ga = save_capture_ga;
}


static void f_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  execute_common(argvars, rettv, fptr, 0);
}


static void f_win_execute(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tabpage_T *tp;
  win_T *wp = win_id2wp_tp(argvars, &tp);
  win_T *save_curwin;
  tabpage_T *save_curtab;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 2185 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 2185 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (wp != 
# 2187 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0) 
# 2187 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                && tp != 
# 2187 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 2187 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ) {
    pos_T curpos = wp->w_cursor;
    if (switch_win_noblock(&save_curwin, &save_curtab, wp, tp, 
# 2189 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                              1
# 2189 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  ) ==
        1) {
      check_cursor();
      execute_common(argvars, rettv, fptr, 1);
    }
    restore_win_noblock(save_curwin, save_curtab, 
# 2194 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 1
# 2194 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     );


    if (win_valid(wp) && !equalpos(curpos, wp->w_cursor)) {
      wp->w_redr_status = 
# 2198 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         1
# 2198 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
    }
  }
}


static void f_exepath(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (tv_check_for_nonempty_string(&argvars[0]) == 0) {
    return;
  }

  char *path = 
# 2210 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 2210 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;

  (void)os_can_exe(tv_get_string(&argvars[0]), &path, 
# 2212 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     1
# 2212 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)path;
}




static void f_exists(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int n = 
# 2223 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         0
# 2223 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;

  const char *p = tv_get_string(&argvars[0]);
  if (*p == '$') {

    if (os_env_exists(p + 1)) {
      n = 
# 2229 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         1
# 2229 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
    } else {

      char_u *const exp = expand_env_save((char_u *)p);
      if (exp != 
# 2233 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 2233 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     && *exp != '$') {
        n = 
# 2234 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           1
# 2234 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
      }
      xfree(exp);
    }
  } else if (*p == '&' || *p == '+') {
    n = (get_option_tv(&p, 
# 2239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 2239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              , 
# 2239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                1
# 2239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ) == 1);
    if (*skipwhite((const char_u *)p) != '\000') {
      n = 
# 2241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         0
# 2241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
    }
  } else if (*p == '*') {
    n = function_exists(p + 1, 
# 2244 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 2244 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );
  } else if (*p == ':') {
    n = cmd_exists(p + 1);
  } else if (*p == '#') {
    if (p[1] == '#') {
      n = autocmd_supported(p + 2);
    } else {
      n = au_exists(p + 1);
    }
  } else {
    n = var_exists(p);
  }

  rettv->vval.v_number = n;
}




static void f_expand(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  size_t len;
  char *errormsg;
  int options = 0x40|0x04|0x01;
  expand_T xpc;
  
# 2269 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2269 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 2269 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 2269 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  char_u *result;







  rettv->v_type = VAR_STRING;
  if (argvars[1].v_type != VAR_UNKNOWN
      && argvars[2].v_type != VAR_UNKNOWN
      && tv_get_number_chk(&argvars[2], &error)
      && !error) {
    tv_list_set_ret(rettv, 
# 2283 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 2283 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              );
  }

  const char *s = tv_get_string(&argvars[0]);
  if (*s == '%' || *s == '#' || *s == '<') {
    emsg_off++;
    result = eval_vars((char_u *)s, (char_u *)s, &len, 
# 2289 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 2289 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          , &errormsg, 
# 2289 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                       ((void *)0)
# 2289 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                           );
    emsg_off--;
    if (rettv->v_type == VAR_LIST) {
      tv_list_alloc_ret(rettv, (result != 
# 2292 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0)
# 2292 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             ));
      if (result != 
# 2293 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 2293 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
        tv_list_append_string(rettv->vval.v_list, (const char *)result, -1);
      }
      do { void **ptr_ = (void **)&(result); xfree(*ptr_); *ptr_ = 
# 2296 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     ((void *)0)
# 2296 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     ; (void)(*ptr_); } while (0);
    } else {
      rettv->vval.v_string = result;
    }
  } else {


    if (argvars[1].v_type != VAR_UNKNOWN
        && tv_get_number_chk(&argvars[1], &error)) {
      options |= 0x20;
    }
    if (!error) {
      ExpandInit(&xpc);
      xpc.xp_context = EXPAND_FILES;
      if (p_wic) {
        options += 0x100;
      }
      if (rettv->v_type == VAR_STRING) {
        rettv->vval.v_string = ExpandOne(&xpc, (char_u *)s, 
# 2314 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           ((void *)0)
# 2314 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               , options,
                                         6);
      } else {
        ExpandOne(&xpc, (char_u *)s, 
# 2317 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 2317 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        , options, 8);
        tv_list_alloc_ret(rettv, xpc.xp_numfiles);
        for (int i = 0; i < xpc.xp_numfiles; i++) {
          tv_list_append_string(rettv->vval.v_list,
                                (const char *)xpc.xp_files[i], -1);
        }
        ExpandCleanup(&xpc);
      }
    } else {
      rettv->vval.v_string = 
# 2326 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 2326 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
    }
  }



}



static void f_menu_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, kListLenMayKnow);
  int modes = ((1 << MENU_INDEX_TIP) - 1);
  if (argvars[1].v_type == VAR_STRING) {
    const char *const strmodes = tv_get_string(&argvars[1]);
    modes = get_menu_cmd_modes(strmodes, 
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        0
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             , 
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   , 
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     ((void *)0)
# 2342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
  }
  menu_get((char_u *)tv_get_string(&argvars[0]), modes, rettv->vval.v_list);
}



static void f_expandcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char *errormsg = 
# 2351 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 2351 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;

  rettv->v_type = VAR_STRING;
  char_u *cmdstr = (char_u *)xstrdup(tv_get_string(&argvars[0]));

  exarg_T eap = {
    .cmd = cmdstr,
    .arg = cmdstr,
    .usefilter = 
# 2359 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 2359 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ,
    .nextcmd = 
# 2360 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 2360 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ,
    .cmdidx = CMD_USER,
  };
  eap.argt |= 0x010;

  expand_filename(&eap, &cmdstr, &errormsg);
  if (errormsg != 
# 2366 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0) 
# 2366 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      && *errormsg != '\000') {
    emsg(errormsg);
  }
  rettv->vval.v_string = cmdstr;
}



static void f_flatten(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  list_T *list;
  long maxdepth;
  
# 2378 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2378 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 2378 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 2378 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 2381 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 2381 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listarg)
# 2381 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 2381 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "flatten()");
    return;
  }

  if (argvars[1].v_type == VAR_UNKNOWN) {
    maxdepth = 999999;
  } else {
    maxdepth = (long)tv_get_number_chk(&argvars[1], &error);
    if (error) {
      return;
    }
    if (maxdepth < 0) {
      emsg(
# 2393 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 2393 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E900: maxdepth must be non-negative number")
# 2393 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 2393 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
      return;
    }
  }

  list = argvars[0].vval.v_list;
  if (list != 
# 2399 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
      
# 2400 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     && !var_check_lock(tv_list_locked(list),
                         "flatten() argument",
                         (
# 2402 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        (18446744073709551615UL)
# 2402 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ))
      && tv_list_flatten(list, maxdepth) == 1) {
    tv_copy(&argvars[0], rettv);
  }
}





static void f_extend(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const arg_errmsg = "extend() argument";

  if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST) {
    long before;
    
# 2418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 2418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 2418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 2418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

    list_T *const l1 = argvars[0].vval.v_list;
    list_T *const l2 = argvars[1].vval.v_list;
    if (!var_check_lock(tv_list_locked(l1), arg_errmsg, (
# 2422 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       (18446744073709551615UL)
# 2422 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ))) {
      listitem_T *item;
      if (argvars[2].v_type != VAR_UNKNOWN) {
        before = (long)tv_get_number_chk(&argvars[2], &error);
        if (error) {
          return;
        }

        if (before == tv_list_len(l1)) {
          item = 
# 2431 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 2431 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
        } else {
          item = tv_list_find(l1, before);
          if (item == 
# 2434 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 2434 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
            semsg(
# 2435 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 dcgettext (((void *)0), 
# 2435 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 (char *)(e_listidx)
# 2435 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 , 5)
# 2435 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             , (int64_t)before);
            return;
          }
        }
      } else {
        item = 
# 2440 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 2440 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      }
      tv_list_extend(l1, l2, item);

      tv_copy(&argvars[0], rettv);
    }
  } else if (argvars[0].v_type == VAR_DICT && argvars[1].v_type ==
             VAR_DICT) {
    dict_T *const d1 = argvars[0].vval.v_dict;
    dict_T *const d2 = argvars[1].vval.v_dict;
    if (d1 == 
# 2450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 2450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      const 
# 2451 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           _Bool 
# 2451 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                locked = var_check_lock(VAR_FIXED, arg_errmsg, (
# 2451 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                               (18446744073709551615UL)
# 2451 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               ));
      (void)locked;
      
# 2453 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     ((void) (0))
# 2453 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
    } else if (d2 == 
# 2454 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 2454 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {

      tv_copy(&argvars[0], rettv);
    } else if (!var_check_lock(d1->dv_lock, arg_errmsg, (
# 2457 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       (18446744073709551615UL)
# 2457 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ))) {
      const char *action = "force";

      if (argvars[2].v_type != VAR_UNKNOWN) {
        const char *const av[] = { "keep", "force", "error" };

        action = tv_get_string_chk(&argvars[2]);
        if (action == 
# 2464 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 2464 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
          return;
        }
        size_t i;
        for (i = 0; i < ((sizeof(av)/sizeof((av)[0])) / ((size_t)(!(sizeof(av) % sizeof((av)[0]))))); i++) {
          if (strcmp(action, av[i]) == 0) {
            break;
          }
        }
        if (i == 3) {
          semsg(
# 2474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 2474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_invarg2)
# 2474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 2474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , action);
          return;
        }
      }

      tv_dict_extend(d1, d2, action);

      tv_copy(&argvars[0], rettv);
    }
  } else {
    semsg(
# 2484 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 2484 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listdictarg)
# 2484 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 2484 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "extend()");
  }
}




static void f_feedkeys(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{



  if (check_secure()) {
    return;
  }

  const char *const keys = tv_get_string(&argvars[0]);
  char nbuf[NUMBUFLEN];
  const char *flags = 
# 2502 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 2502 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  if (argvars[1].v_type != VAR_UNKNOWN) {
    flags = tv_get_string_buf(&argvars[1], nbuf);
  }

  nvim_feedkeys(cstr_as_string((char *)keys),
                cstr_as_string((char *)flags), 
# 2508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              1
# 2508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
}


static void f_filereadable(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const p = tv_get_string(&argvars[0]);
  rettv->vval.v_number =
    (*p && !os_isdir((const char_u *)p) && os_file_is_readable(p));
}





static void f_filewritable(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *filename = tv_get_string(&argvars[0]);
  rettv->vval.v_number = os_file_is_writable(filename);
}


static void findfilendir(typval_T *argvars, typval_T *rettv, int find_what)
{
  char_u *fresult = 
# 2532 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 2532 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  char_u *path = *curbuf->b_p_path == '\000' ? p_path : curbuf->b_p_path;
  int count = 1;
  
# 2535 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2535 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      first = 
# 2535 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 2535 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  
# 2536 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2536 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 2536 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 2536 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  rettv->vval.v_string = 
# 2538 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 2538 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  rettv->v_type = VAR_STRING;

  const char *fname = tv_get_string(&argvars[0]);

  char pathbuf[NUMBUFLEN];
  if (argvars[1].v_type != VAR_UNKNOWN) {
    const char *p = tv_get_string_buf_chk(&argvars[1], pathbuf);
    if (p == 
# 2546 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 2546 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      error = 
# 2547 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             1
# 2547 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
    } else {
      if (*p != '\000') {
        path = (char_u *)p;
      }

      if (argvars[2].v_type != VAR_UNKNOWN) {
        count = tv_get_number_chk(&argvars[2], &error);
      }
    }
  }

  if (count < 0) {
    tv_list_alloc_ret(rettv, kListLenUnknown);
  }

  if (*fname != '\000' && !error) {
    do {
      if (rettv->v_type == VAR_STRING || rettv->v_type == VAR_LIST) {
        xfree(fresult);
      }
      fresult = find_file_in_path_option(first ? (char_u *)fname : 
# 2568 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  ((void *)0)
# 2568 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                      ,
                                         first ? strlen(fname) : 0,
                                         0, first, path,
                                         find_what, curbuf->b_ffname,
                                         (find_what == 1
                                          ? (char_u *)""
                                          : curbuf->b_p_sua));
      first = 
# 2575 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 2575 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;

      if (fresult != 
# 2577 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0) 
# 2577 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         && rettv->v_type == VAR_LIST) {
        tv_list_append_string(rettv->vval.v_list, (const char *)fresult, -1);
      }
    } while ((rettv->v_type == VAR_LIST || --count > 0) && fresult != 
# 2580 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     ((void *)0)
# 2580 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                         );
  }

  if (rettv->v_type == VAR_STRING) {
    rettv->vval.v_string = fresult;
  }
}





static void f_filter(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  filter_map(argvars, rettv, 0);
}




static void f_finddir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  findfilendir(argvars, rettv, 1);
}




static void f_findfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  findfilendir(argvars, rettv, 0);
}




static void f_float2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  float_T f;

  if (tv_get_float_chk(argvars, &f)) {
    if (f <= (float_T)-
# 2621 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      (9223372036854775807L) 
# 2621 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    + ((double)2.22044604925031308084726333618164062e-16L)) {
      rettv->vval.v_number = -
# 2622 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             (9223372036854775807L)
# 2622 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ;
    } else if (f >= (float_T)
# 2623 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            (9223372036854775807L) 
# 2623 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          - ((double)2.22044604925031308084726333618164062e-16L)) {
      rettv->vval.v_number = 
# 2624 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            (9223372036854775807L)
# 2624 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         ;
    } else {
      rettv->vval.v_number = (varnumber_T)f;
    }
  }
}




static void f_fmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  float_T fx;
  float_T fy;

  rettv->v_type = VAR_FLOAT;
  if (tv_get_float_chk(argvars, &fx) && tv_get_float_chk(&argvars[1], &fy)) {
    rettv->vval.v_float = fmod(fx, fy);
  } else {
    rettv->vval.v_float = 0.0;
  }
}




static void f_fnameescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_string = (char_u *)vim_strsave_fnameescape(tv_get_string(&argvars[0]), 
# 2652 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                                      0
# 2652 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                           );
  rettv->v_type = VAR_STRING;
}




static void f_fnamemodify(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *fbuf = 
# 2661 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 2661 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  size_t len = 0;
  char buf[NUMBUFLEN];
  const char *fname = tv_get_string_chk(&argvars[0]);
  const char *const mods = tv_get_string_buf_chk(&argvars[1], buf);
  if (mods == 
# 2666 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 2666 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  || fname == 
# 2666 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 2666 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ) {
    fname = 
# 2667 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 2667 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  } else {
    len = strlen(fname);
    if (*mods != '\000') {
      size_t usedlen = 0;
      (void)modify_fname((char_u *)mods, 
# 2672 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        0
# 2672 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             , &usedlen,
                         (char_u **)&fname, &fbuf, &len);
    }
  }

  rettv->v_type = VAR_STRING;
  if (fname == 
# 2678 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 2678 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    rettv->vval.v_string = 
# 2679 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 2679 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    rettv->vval.v_string = (char_u *)xmemdupz(fname, len);
  }
  xfree(fbuf);
}





static void foldclosed_both(typval_T *argvars, typval_T *rettv, int end)
{
  const linenr_T lnum = tv_get_lnum(argvars);
  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {
    linenr_T first;
    linenr_T last;
    if (hasFoldingWin(curwin, lnum, &first, &last, 
# 2696 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  0
# 2696 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       , 
# 2696 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 2696 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             )) {
      if (end) {
        rettv->vval.v_number = (varnumber_T)last;
      } else {
        rettv->vval.v_number = (varnumber_T)first;
      }
      return;
    }
  }
  rettv->vval.v_number = -1;
}




static void f_foldclosed(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  foldclosed_both(argvars, rettv, 0);
}




static void f_foldclosedend(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  foldclosed_both(argvars, rettv, 1);
}




static void f_foldlevel(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const linenr_T lnum = tv_get_lnum(argvars);
  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {
    rettv->vval.v_number = foldLevel(lnum);
  }
}




static void f_foldtext(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T foldstart;
  linenr_T foldend;
  char_u *dashes;
  linenr_T lnum;
  char_u *s;
  char_u *r;
  int len;
  char *txt;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 2750 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 2750 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  foldstart = (linenr_T)get_vim_var_nr(VV_FOLDSTART);
  foldend = (linenr_T)get_vim_var_nr(VV_FOLDEND);
  dashes = get_vim_var_str(VV_FOLDDASHES);
  if (foldstart > 0 && foldend <= curbuf->b_ml.ml_line_count) {

    for (lnum = foldstart; lnum < foldend; lnum++) {
      if (!linewhite(lnum)) {
        break;
      }
    }


    s = skipwhite(ml_get(lnum));

    if (s[0] == '/' && (s[1] == '*' || s[1] == '/')) {
      s = skipwhite(s + 2);
      if (*skipwhite(s) == '\000' && lnum + 1 < foldend) {
        s = skipwhite(ml_get(lnum + 1));
        if (*s == '*') {
          s = skipwhite(s + 1);
        }
      }
    }
    unsigned long count = (unsigned long)(foldend - foldstart + 1);
    txt = 
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcngettext (((void *)0), 
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         "+-%s%3ld line: "
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         "+-%s%3ld lines: "
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (unsigned long)count
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 2776 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               ;
    r = xmalloc(strlen((char *)(txt))
                + strlen((char *)(dashes))
                + 20
                + strlen((char *)(s)));
    sprintf((char *)r, txt, dashes, count);
    len = (int)strlen((char *)(r));
    strcat((char *)(r), (char *)(s));

    foldtext_cleanup(r + len);
    rettv->vval.v_string = r;
  }
}




static void f_foldtextresult(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *text;
  char_u buf[FOLD_TEXT_LEN];
  static 
# 2797 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        _Bool 
# 2797 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             entered = 
# 2797 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       0
# 2797 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 2800 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 2800 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (entered) {
    return;
  }
  entered = 
# 2804 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           1
# 2804 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  linenr_T lnum = tv_get_lnum(argvars);

  if (lnum < 0) {
    lnum = 0;
  }

  foldinfo_T info = fold_info(curwin, lnum);
  if (info.fi_lines > 0) {
    text = get_foldtext(curwin, lnum, lnum + info.fi_lines - 1, info, buf);
    if (text == buf) {
      text = vim_strsave(text);
    }
    rettv->vval.v_string = text;
  }

  entered = 
# 2820 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           0
# 2820 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;
}




static void f_foreground(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
}

static void f_funcref(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  common_function(argvars, rettv, 
# 2832 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 1
# 2832 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     , fptr);
}

static void f_function(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  common_function(argvars, rettv, 
# 2837 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 0
# 2837 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      , fptr);
}


static void f_garbagecollect(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{


  want_garbage_collect = 
# 2845 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        1
# 2845 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (argvars[0].v_type != VAR_UNKNOWN && tv_get_number(&argvars[0]) == 1) {
    garbage_collect_at_exit = 
# 2848 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             1
# 2848 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ;
  }
}




static void f_get(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  listitem_T *li;
  list_T *l;
  dictitem_T *di;
  dict_T *d;
  typval_T *tv = 
# 2861 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 2861 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  
# 2862 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2862 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      what_is_dict = 
# 2862 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     0
# 2862 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;

  if (argvars[0].v_type == VAR_BLOB) {
    
# 2865 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 2865 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 2865 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 2865 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
    int idx = tv_get_number_chk(&argvars[1], &error);

    if (!error) {
      rettv->v_type = VAR_NUMBER;
      if (idx < 0) {
        idx = tv_blob_len(argvars[0].vval.v_blob) + idx;
      }
      if (idx < 0 || idx >= tv_blob_len(argvars[0].vval.v_blob)) {
        rettv->vval.v_number = -1;
      } else {
        rettv->vval.v_number = tv_blob_get(argvars[0].vval.v_blob, idx);
        tv = rettv;
      }
    }
  } else if (argvars[0].v_type == VAR_LIST) {
    if ((l = argvars[0].vval.v_list) != 
# 2881 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 2881 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ) {
      
# 2882 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 2882 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          error = 
# 2882 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 2882 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;

      li = tv_list_find(l, tv_get_number_chk(&argvars[1], &error));
      if (!error && li != 
# 2885 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 2885 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ) {
        tv = (&(li)->li_tv);
      }
    }
  } else if (argvars[0].v_type == VAR_DICT) {
    if ((d = argvars[0].vval.v_dict) != 
# 2890 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 2890 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ) {
      di = tv_dict_find(d, tv_get_string(&argvars[1]), -1);
      if (di != 
# 2892 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 2892 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
        tv = &di->di_tv;
      }
    }
  } else if (tv_is_func(argvars[0])) {
    partial_T *pt;
    partial_T fref_pt;

    if (argvars[0].v_type == VAR_PARTIAL) {
      pt = argvars[0].vval.v_partial;
    } else {
      memset(&fref_pt, 0, sizeof(fref_pt));
      fref_pt.pt_name = argvars[0].vval.v_string;
      pt = &fref_pt;
    }

    if (pt != 
# 2908 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 2908 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      const char *const what = tv_get_string(&argvars[1]);

      if (strcmp(what, "func") == 0 || strcmp(what, "name") == 0) {
        rettv->v_type = (*what == 'f' ? VAR_FUNC : VAR_STRING);
        const char *const n = (const char *)partial_name(pt);
        
# 2914 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       ((void) (0))
# 2914 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
        rettv->vval.v_string = (char_u *)xstrdup(n);
        if (rettv->v_type == VAR_FUNC) {
          func_ref(rettv->vval.v_string);
        }
      } else if (strcmp(what, "dict") == 0) {
        what_is_dict = 
# 2920 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      1
# 2920 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
        if (pt->pt_dict != 
# 2921 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 2921 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ) {
          tv_dict_set_ret(rettv, pt->pt_dict);
        }
      } else if (strcmp(what, "args") == 0) {
        rettv->v_type = VAR_LIST;
        tv_list_alloc_ret(rettv, pt->pt_argc);
        for (int i = 0; i < pt->pt_argc; i++) {
          tv_list_append_tv(rettv->vval.v_list, &pt->pt_argv[i]);
        }
      } else {
        semsg(
# 2931 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 2931 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 2931 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 2931 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , what);
      }



      if (!what_is_dict) {
        return;
      }
    }
  } else {
    semsg(
# 2941 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 2941 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listdictblobarg)
# 2941 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 2941 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             , "get()");
  }

  if (tv == 
# 2944 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 2944 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    if (argvars[2].v_type != VAR_UNKNOWN) {
      tv_copy(&argvars[2], rettv);
    }
  } else {
    tv_copy(tv, rettv);
  }
}


static void f_getbufinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *argbuf = 
# 2956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 2956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  
# 2957 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2957 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      filtered = 
# 2957 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 2957 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  
# 2958 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2958 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      sel_buflisted = 
# 2958 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      0
# 2958 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  
# 2959 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2959 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      sel_bufloaded = 
# 2959 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      0
# 2959 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  
# 2960 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 2960 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      sel_bufmodified = 
# 2960 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        0
# 2960 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;

  tv_list_alloc_ret(rettv, kListLenMayKnow);


  if (argvars[0].v_type == VAR_DICT) {
    dict_T *sel_d = argvars[0].vval.v_dict;

    if (sel_d != 
# 2968 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 2968 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      dictitem_T *di;

      filtered = 
# 2971 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                1
# 2971 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

      di = tv_dict_find(sel_d, ("buflisted"), (sizeof("buflisted") - 1));
      if (di != 
# 2974 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 2974 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    && tv_get_number(&di->di_tv)) {
        sel_buflisted = 
# 2975 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       1
# 2975 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
      }

      di = tv_dict_find(sel_d, ("bufloaded"), (sizeof("bufloaded") - 1));
      if (di != 
# 2979 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 2979 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    && tv_get_number(&di->di_tv)) {
        sel_bufloaded = 
# 2980 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       1
# 2980 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
      }
      di = tv_dict_find(sel_d, ("bufmodified"), (sizeof("bufmodified") - 1));
      if (di != 
# 2983 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 2983 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    && tv_get_number(&di->di_tv)) {
        sel_bufmodified = 
# 2984 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         1
# 2984 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
      }
    }
  } else if (argvars[0].v_type != VAR_UNKNOWN) {

    argbuf = tv_get_buf_from_arg(&argvars[0]);
    if (argbuf == 
# 2990 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 2990 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      return;
    }
  }


  for (buf_T *buf = firstbuf; buf != 
# 2996 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 2996 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; buf = buf->b_next) {
    if (argbuf != 
# 2997 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0) 
# 2997 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      && argbuf != buf) {
      continue;
    }
    if (filtered && ((sel_bufloaded && buf->b_ml.ml_mfp == 
# 3000 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                          ((void *)0)
# 3000 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              )
                     || (sel_buflisted && !buf->b_p_bl)
                     || (sel_bufmodified && !buf->b_changed))) {
      continue;
    }

    dict_T *const d = get_buffer_info(buf);
    tv_list_append_dict(rettv->vval.v_list, d);
    if (argbuf != 
# 3008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 3008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      return;
    }
  }
}







static void get_buffer_lines(buf_T *buf, linenr_T start, linenr_T end, int retlist, typval_T *rettv)
{
  rettv->v_type = (retlist ? VAR_LIST : VAR_STRING);
  rettv->vval.v_string = 
# 3023 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 3023 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (buf == 
# 3025 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 3025 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || buf->b_ml.ml_mfp == 
# 3025 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0) 
# 3025 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             || start < 0 || end < start) {
    if (retlist) {
      tv_list_alloc_ret(rettv, 0);
    }
    return;
  }

  if (retlist) {
    if (start < 1) {
      start = 1;
    }
    if (end > buf->b_ml.ml_line_count) {
      end = buf->b_ml.ml_line_count;
    }
    tv_list_alloc_ret(rettv, end - start + 1);
    while (start <= end) {
      tv_list_append_string(rettv->vval.v_list,
                            (const char *)ml_get_buf(buf, start++, 
# 3042 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  0
# 3042 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       ), -1);
    }
  } else {
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = ((start >= 1 && start <= buf->b_ml.ml_line_count)
                            ? vim_strsave(ml_get_buf(buf, start, 
# 3047 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                0
# 3047 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                     ))
                            : 
# 3048 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 3048 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
  }
}




static void f_getbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *const buf = tv_get_buf_from_arg(&argvars[0]);

  const linenr_T lnum = tv_get_lnum_buf(&argvars[1], buf);
  const linenr_T end = (argvars[2].v_type == VAR_UNKNOWN
                        ? lnum
                        : tv_get_lnum_buf(&argvars[2], buf));

  get_buffer_lines(buf, lnum, end, 
# 3064 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  1
# 3064 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      , rettv);
}




static void f_getbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 3072 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3072 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      done = 
# 3072 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 3072 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 3075 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 3075 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (!tv_check_str_or_nr(&argvars[0])) {
    goto f_getbufvar_end;
  }

  const char *varname = tv_get_string_chk(&argvars[1]);
  emsg_off++;
  buf_T *const buf = tv_get_buf(&argvars[0], 
# 3083 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 3083 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );

  if (buf != 
# 3085 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 3085 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && varname != 
# 3085 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 3085 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ) {
    if (*varname == '&') {
      buf_T *const save_curbuf = curbuf;


      curbuf = buf;

      if (varname[1] == '\000') {

        dict_T *opts = get_winbuf_options(
# 3094 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         1
# 3094 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             );

        if (opts != 
# 3096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 3096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
          tv_dict_set_ret(rettv, opts);
          done = 
# 3098 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                1
# 3098 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
        }
      } else if (get_option_tv(&varname, rettv, 
# 3100 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               1
# 3100 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ) == 1) {

        done = 
# 3102 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 3102 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      }


      curbuf = save_curbuf;
    } else {


      dictitem_T *const v = *varname == '\000'
        ? (dictitem_T *)&buf->b_bufvar
        : find_var_in_ht(&buf->b_vars->dv_hashtab, 'b',
                         varname, strlen(varname), 
# 3113 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  0
# 3113 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
      if (v != 
# 3114 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 3114 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
        tv_copy(&v->di_tv, rettv);
        done = 
# 3116 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 3116 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      }
    }
  }
  emsg_off--;

f_getbufvar_end:
  if (!done && argvars[2].v_type != VAR_UNKNOWN) {

    tv_copy(&argvars[2], rettv);
  }
}


static void f_getchangelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, 2);

  const buf_T *buf;
  if (argvars[0].v_type == VAR_UNKNOWN) {
    buf = curbuf;
  } else {
    vim_ignored = tv_get_number(&argvars[0]);
    emsg_off++;
    buf = tv_get_buf(&argvars[0], 
# 3140 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 0
# 3140 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      );
    emsg_off--;
  }
  if (buf == 
# 3143 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 3143 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  list_T *const l = tv_list_alloc(buf->b_changelistlen);
  tv_list_append_list(rettv->vval.v_list, l);



  tv_list_append_number(rettv->vval.v_list,
                        (buf == curwin->w_buffer)
                        ? curwin->w_changelistidx
                        : buf->b_changelistlen);

  for (int i = 0; i < buf->b_changelistlen; i++) {
    if (buf->b_changelist[i].mark.lnum == 0) {
      continue;
    }
    dict_T *const d = tv_dict_alloc();
    tv_list_append_dict(l, d);
    tv_dict_add_nr(d, ("lnum"), (sizeof("lnum") - 1), buf->b_changelist[i].mark.lnum);
    tv_dict_add_nr(d, ("col"), (sizeof("col") - 1), buf->b_changelist[i].mark.col);
    tv_dict_add_nr(d, ("coladd"), (sizeof("coladd") - 1), buf->b_changelist[i].mark.coladd);
  }
}


static void getchar_common(typval_T *argvars, typval_T *rettv)
  FUNC_ATTR_NONNULL_ALL
{
  varnumber_T n;
  
# 3174 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3174 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 3174 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 3174 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  no_mapping++;
  for (;;) {


    ui_cursor_goto(msg_row, msg_col);

    if (argvars[0].v_type == VAR_UNKNOWN) {


      if (!(char_avail() || using_script() || input_available())) {
        (void)os_inchar(
# 3186 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 3186 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , 0, -1, 0, main_loop.events);
        if (!multiqueue_empty(main_loop.events)) {
          state_handle_k_event();
          continue;
        }
      }
      n = safe_vgetc();
    } else if (tv_get_number_chk(&argvars[0], &error) == 1) {

      n = vpeekc_any();
    } else if (error || vpeekc_any() == '\000') {

      n = 0;
    } else {


      n = safe_vgetc();
    }

    if (n == (-((253) + ((int)(KE_IGNORE) << 8)))
        || n == (-((253) + ((int)(KE_MOUSEMOVE) << 8)))
        || n == (-((249) + ((int)(('X')) << 8)))
        || n == (-((248) + ((int)(('X')) << 8)))) {
      continue;
    }
    break;
  }
  no_mapping--;

  set_vim_var_nr(VV_MOUSE_WIN, 0);
  set_vim_var_nr(VV_MOUSE_WINID, 0);
  set_vim_var_nr(VV_MOUSE_LNUM, 0);
  set_vim_var_nr(VV_MOUSE_COL, 0);

  rettv->vval.v_number = n;
  if (((n) < 0) || mod_mask != 0) {
    char_u temp[10];
    int i = 0;


    if (mod_mask != 0) {
      temp[i++] = (0x80);
      temp[i++] = 252;
      temp[i++] = mod_mask;
    }
    if (((n) < 0)) {
      temp[i++] = (0x80);
      temp[i++] = ((n) == (0x80) ? 254 : (n) == '\000' ? 255 : ((-(n)) & 0xff));
      temp[i++] = (((n) == (0x80) || (n) == '\000') ? ('X') : (((unsigned)(-(n)) >> 8) & 0xff));
    } else {
      i += utf_char2bytes(n, temp + i);
    }
    
# 3238 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 3238 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
    temp[i++] = '\000';
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = vim_strsave(temp);

    if (is_mouse_key(n)) {
      int row = mouse_row;
      int col = mouse_col;
      int grid = mouse_grid;
      linenr_T lnum;
      win_T *wp;
      int winnr = 1;

      if (row >= 0 && col >= 0) {


        win_T *const win = mouse_find_win(&grid, &row, &col);
        if (win == 
# 3255 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 3255 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
          return;
        }
        (void)mouse_comp_pos(win, &row, &col, &lnum);
        for (wp = firstwin; wp != win; wp = wp->w_next) {
          ++winnr;
        }
        set_vim_var_nr(VV_MOUSE_WIN, winnr);
        set_vim_var_nr(VV_MOUSE_WINID, wp->handle);
        set_vim_var_nr(VV_MOUSE_LNUM, lnum);
        set_vim_var_nr(VV_MOUSE_COL, col + 1);
      }
    }
  }
}


static void f_getchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getchar_common(argvars, rettv);
}


static void f_getcharstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getchar_common(argvars, rettv);

  if (rettv->v_type == VAR_NUMBER) {
    char_u temp[7];
    const varnumber_T n = rettv->vval.v_number;
    int i = 0;

    if (n != 0) {
      i += utf_char2bytes(n, temp);
    }
    
# 3290 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 3290 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;
    temp[i++] = '\000';
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = vim_strsave(temp);
  }
}




static void f_getcharmod(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = mod_mask;
}




static void f_getcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);

  dict_T *dict = rettv->vval.v_dict;

  tv_dict_add_str(dict, ("char"), (sizeof("char") - 1), last_csearch());
  tv_dict_add_nr(dict, ("forward"), (sizeof("forward") - 1), last_csearch_forward());
  tv_dict_add_nr(dict, ("until"), (sizeof("until") - 1), last_csearch_until());
}




static void f_getcmdline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = get_cmdline_str();
}




static void f_getcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = get_cmdline_pos() + 1;
}




static void f_getcmdtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = xmallocz(1);
  rettv->vval.v_string[0] = get_cmdline_type();
}




static void f_getcmdwintype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 3352 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 3352 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  rettv->vval.v_string = xmallocz(1);
  rettv->vval.v_string[0] = cmdwin_type;
}


static void f_getcompletion(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *pat;
  expand_T xpc;
  
# 3362 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3362 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      filtered = 
# 3362 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 3362 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  int options = 0x40 | 0x04 | 0x10
                | 0x08 | 0x02;

  if (argvars[1].v_type != VAR_STRING) {
    semsg(
# 3367 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 3367 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 3367 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 3367 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "type must be a string");
    return;
  }
  const char *const type = tv_get_string(&argvars[1]);

  if (argvars[2].v_type != VAR_UNKNOWN) {
    filtered = (
# 3373 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               _Bool
# 3373 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   )tv_get_number_chk(&argvars[2], 
# 3373 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 3373 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
  }

  if (p_wic) {
    options |= 0x100;
  }


  if (!filtered) {
    options |= 0x20;
  }

  if (argvars[0].v_type != VAR_STRING) {
    emsg(
# 3386 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 3386 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 3386 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 3386 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }
  const char *pattern = tv_get_string(&argvars[0]);

  if (strcmp(type, "cmdline") == 0) {
    set_one_cmd_context(&xpc, pattern);
    xpc.xp_pattern_len = strlen((char *)(xpc.xp_pattern));
    xpc.xp_col = strlen((char *)(pattern));
    goto theend;
  }

  ExpandInit(&xpc);
  xpc.xp_pattern = (char_u *)pattern;
  xpc.xp_pattern_len = strlen((char *)(xpc.xp_pattern));
  xpc.xp_context = cmdcomplete_str_to_type(type);
  if (xpc.xp_context == EXPAND_NOTHING) {
    semsg(
# 3403 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 3403 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 3403 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 3403 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , type);
    return;
  }

  if (xpc.xp_context == EXPAND_MENUS) {
    set_context_in_menu_cmd(&xpc, "menu", xpc.xp_pattern, 
# 3408 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         0
# 3408 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              );
    xpc.xp_pattern_len = strlen((char *)(xpc.xp_pattern));
  }

  if (xpc.xp_context == EXPAND_CSCOPE) {
    set_context_in_cscope_cmd(&xpc, (const char *)xpc.xp_pattern, CMD_cscope);
    xpc.xp_pattern_len = strlen((char *)(xpc.xp_pattern));
  }

  if (xpc.xp_context == EXPAND_SIGN) {
    set_context_in_sign_cmd(&xpc, xpc.xp_pattern);
    xpc.xp_pattern_len = strlen((char *)(xpc.xp_pattern));
  }

theend:
  pat = addstar(xpc.xp_pattern, xpc.xp_pattern_len, xpc.xp_context);
  ExpandOne(&xpc, pat, 
# 3424 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 3424 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , options, 8);
  tv_list_alloc_ret(rettv, xpc.xp_numfiles);

  for (int i = 0; i < xpc.xp_numfiles; i++) {
    tv_list_append_string(rettv->vval.v_list, (const char *)xpc.xp_files[i],
                          -1);
  }
  xfree(pat);
  ExpandCleanup(&xpc);
}
# 3444 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static void f_getcwd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{

  CdScope scope = kCdScopeInvalid;



  int scope_number[] = {
    [kCdScopeWindow] = 0,
    [kCdScopeTabpage] = 0,
  };

  char_u *cwd = 
# 3456 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 3456 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  char_u *from = 
# 3457 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 3457 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  tabpage_T *tp = curtab;
  win_T *win = curwin;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 3463 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 3463 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;


  for (int i = kCdScopeWindow; i < kCdScopeGlobal; i++) {

    if (argvars[i].v_type == VAR_UNKNOWN) {
      break;
    }
    if (argvars[i].v_type != VAR_NUMBER) {
      emsg(
# 3472 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 3472 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 3472 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 3472 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }
    scope_number[i] = argvars[i].vval.v_number;

    if (scope_number[i] < -1) {
      emsg(
# 3478 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 3478 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 3478 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 3478 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }

    if (scope_number[i] >= 0 && scope == kCdScopeInvalid) {

      scope = i;
    } else if (scope_number[i] < 0) {
      scope = i + 1;
    }
  }


  if (scope_number[kCdScopeTabpage] > 0) {
    tp = find_tabpage(scope_number[kCdScopeTabpage]);
    if (!tp) {
      emsg(
# 3494 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 3494 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E5000: Cannot find tab number.")
# 3494 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 3494 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             );
      return;
    }
  }


  if (scope_number[kCdScopeWindow] >= 0) {
    if (scope_number[kCdScopeTabpage] < 0) {
      emsg(
# 3502 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 3502 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E5001: Higher scope cannot be -1 if lower scope is >= 0.")
# 3502 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 3502 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       );
      return;
    }

    if (scope_number[kCdScopeWindow] > 0) {
      win = find_win_by_nr(&argvars[0], tp);
      if (!win) {
        emsg(
# 3509 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 3509 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)("E5002: Cannot find window number.")
# 3509 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 3509 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
        return;
      }
    }
  }

  cwd = xmalloc(4096);

  switch (scope) {
  case kCdScopeWindow:
    
# 3519 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 3519 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
    from = win->w_localdir;
    if (from) {
      break;
    }
    {} __attribute__((fallthrough));
  case kCdScopeTabpage:
    
# 3526 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 3526 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
    from = tp->tp_localdir;
    if (from) {
      break;
    }
    {} __attribute__((fallthrough));
  case kCdScopeGlobal:
    if (globaldir) {
      from = globaldir;
      break;
    }
    {} __attribute__((fallthrough));
  case kCdScopeInvalid:
    if (os_dirname(cwd, 4096) == 0) {
      from = (char_u *)"";
    }
  }

  if (from) {
    xstrlcpy((char *)(cwd), (char *)(from), (size_t)(4096));
  }

  rettv->vval.v_string = vim_strsave(cwd);




  xfree(cwd);
}




static void f_getfontname(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 3562 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 3562 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
}




static void f_getfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char *perm = 
# 3570 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 3570 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  char_u flags[] = "rwx";

  const char *filename = tv_get_string(&argvars[0]);
  int32_t file_perm = os_getperm(filename);
  if (file_perm >= 0) {
    perm = xstrdup("---------");
    for (int i = 0; i < 9; i++) {
      if (file_perm & (1 << (8 - i))) {
        perm[i] = flags[i % 3];
      }
    }
  }
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)perm;
}




static void f_getfsize(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *fname = tv_get_string(&argvars[0]);

  rettv->v_type = VAR_NUMBER;

  FileInfo file_info;
  if (os_fileinfo(fname, &file_info)) {
    uint64_t filesize = os_fileinfo_size(&file_info);
    if (os_isdir((const char_u *)fname)) {
      rettv->vval.v_number = 0;
    } else {
      rettv->vval.v_number = (varnumber_T)filesize;


      if ((uint64_t)rettv->vval.v_number != filesize) {
        rettv->vval.v_number = -2;
      }
    }
  } else {
    rettv->vval.v_number = -1;
  }
}




static void f_getftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *fname = tv_get_string(&argvars[0]);

  FileInfo file_info;
  if (os_fileinfo(fname, &file_info)) {
    rettv->vval.v_number = (varnumber_T)file_info.stat.st_mtim.tv_sec;
  } else {
    rettv->vval.v_number = -1;
  }
}




static void f_getftype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *type = 
# 3634 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 3634 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  char *t;

  const char *fname = tv_get_string(&argvars[0]);

  rettv->v_type = VAR_STRING;
  FileInfo file_info;
  if (os_fileinfo_link(fname, &file_info)) {
    uint64_t mode = file_info.stat.st_mode;
    if (
# 3643 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       ((((
# 3643 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       mode
# 3643 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       )) & 0170000) == (0100000))
# 3643 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      t = "file";
    } else if (
# 3645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0040000))
# 3645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
      t = "dir";
    } else if (
# 3647 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3647 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3647 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0120000))
# 3647 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
      t = "link";
    } else if (
# 3649 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3649 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3649 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0060000))
# 3649 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
      t = "bdev";
    } else if (
# 3651 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3651 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3651 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0020000))
# 3651 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
      t = "cdev";
    } else if (
# 3653 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3653 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3653 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0010000))
# 3653 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ) {
      t = "fifo";
    } else if (
# 3655 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((((
# 3655 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              mode
# 3655 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              )) & 0170000) == (0140000))
# 3655 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ) {
      t = "socket";
    } else {
      t = "other";
    }
    type = vim_strsave((char_u *)t);
  }
  rettv->vval.v_string = type;
}


static void f_getjumplist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, kListLenMayKnow);
  win_T *const wp = find_tabwin(&argvars[0], &argvars[1]);
  if (wp == 
# 3670 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 3670 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    return;
  }

  cleanup_jumplist(wp, 
# 3674 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      1
# 3674 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          );

  list_T *const l = tv_list_alloc(wp->w_jumplistlen);
  tv_list_append_list(rettv->vval.v_list, l);
  tv_list_append_number(rettv->vval.v_list, wp->w_jumplistidx);

  for (int i = 0; i < wp->w_jumplistlen; i++) {
    if (wp->w_jumplist[i].fmark.mark.lnum == 0) {
      continue;
    }
    dict_T *const d = tv_dict_alloc();
    tv_list_append_dict(l, d);
    tv_dict_add_nr(d, ("lnum"), (sizeof("lnum") - 1), wp->w_jumplist[i].fmark.mark.lnum);
    tv_dict_add_nr(d, ("col"), (sizeof("col") - 1), wp->w_jumplist[i].fmark.mark.col);
    tv_dict_add_nr(d, ("coladd"), (sizeof("coladd") - 1), wp->w_jumplist[i].fmark.mark.coladd);
    tv_dict_add_nr(d, ("bufnr"), (sizeof("bufnr") - 1), wp->w_jumplist[i].fmark.fnum);
    if (wp->w_jumplist[i].fname != 
# 3690 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  ((void *)0)
# 3690 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      ) {
      tv_dict_add_str(d, ("filename"), (sizeof("filename") - 1), (char *)wp->w_jumplist[i].fname);
    }
  }
}




static void f_getline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T end;
  
# 3702 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3702 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      retlist;

  const linenr_T lnum = tv_get_lnum(argvars);
  if (argvars[1].v_type == VAR_UNKNOWN) {
    end = lnum;
    retlist = 
# 3707 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 3707 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  } else {
    end = tv_get_lnum(&argvars[1]);
    retlist = 
# 3710 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             1
# 3710 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  }

  get_buffer_lines(curbuf, lnum, end, retlist, rettv);
}


static void f_getloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = find_win_by_nr_or_id(&argvars[0]);
  get_qf_loc_list(
# 3720 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 3720 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      , wp, &argvars[1], rettv);
}



static void f_getmarklist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, kListLenMayKnow);

  if (argvars[0].v_type == VAR_UNKNOWN) {
    get_global_marks(rettv->vval.v_list);
    return;
  }

  buf_T *buf = tv_get_buf(&argvars[0], 
# 3734 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      0
# 3734 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           );
  if (buf == 
# 3735 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 3735 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  get_buf_local_marks(buf, rettv->vval.v_list);
}




static void f_getmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  matchitem_T *cur;
  int i;
  win_T *win = get_optional_window(argvars, 0);

  if (win == 
# 3751 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 3751 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  tv_list_alloc_ret(rettv, kListLenMayKnow);
  cur = win->w_match_head;
  while (cur != 
# 3757 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 3757 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
    dict_T *dict = tv_dict_alloc();
    if (cur->match.regprog == 
# 3759 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 3759 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ) {

      for (i = 0; i < 8; i++) {
        llpos_T *llpos;
        char buf[30];

        llpos = &cur->pos.pos[i];
        if (llpos->lnum == 0) {
          break;
        }
        list_T *const l = tv_list_alloc(1 + (llpos->col > 0 ? 2 : 0));
        tv_list_append_number(l, (varnumber_T)llpos->lnum);
        if (llpos->col > 0) {
          tv_list_append_number(l, (varnumber_T)llpos->col);
          tv_list_append_number(l, (varnumber_T)llpos->len);
        }
        int len = snprintf(buf, sizeof(buf), "pos%d", i + 1);
        
# 3776 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       ((void) (0))
# 3776 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
        tv_dict_add_list(dict, buf, (size_t)len, l);
      }
    } else {
      tv_dict_add_str(dict, ("pattern"), (sizeof("pattern") - 1), (const char *)cur->pattern);
    }
    tv_dict_add_str(dict, ("group"), (sizeof("group") - 1),
                    (const char *)syn_id2name(cur->hlg_id));
    tv_dict_add_nr(dict, ("priority"), (sizeof("priority") - 1), (varnumber_T)cur->priority);
    tv_dict_add_nr(dict, ("id"), (sizeof("id") - 1), (varnumber_T)cur->id);

    if (cur->conceal_char) {
      char buf[21 + 1];

      buf[utf_char2bytes(cur->conceal_char, (char_u *)buf)] = '\000';
      tv_dict_add_str(dict, ("conceal"), (sizeof("conceal") - 1), buf);
    }

    tv_list_append_dict(rettv->vval.v_list, dict);
    cur = cur->next;
  }
}


void f_getmousepos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *d;
  win_T *wp;
  int row = mouse_row;
  int col = mouse_col;
  int grid = mouse_grid;
  varnumber_T winid = 0;
  varnumber_T winrow = 0;
  varnumber_T wincol = 0;
  linenr_T line = 0;
  varnumber_T column = 0;

  tv_dict_alloc_ret(rettv);
  d = rettv->vval.v_dict;

  tv_dict_add_nr(d, ("screenrow"), (sizeof("screenrow") - 1), (varnumber_T)mouse_row + 1);
  tv_dict_add_nr(d, ("screencol"), (sizeof("screencol") - 1), (varnumber_T)mouse_col + 1);

  wp = mouse_find_win(&grid, &row, &col);
  if (wp != 
# 3820 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 3820 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    int height = wp->w_height + wp->w_status_height;


    if (row < height + wp->w_border_adj[2]) {
      winid = wp->handle;
      winrow = row + 1 + wp->w_border_adj[0];
      wincol = col + 1 + wp->w_border_adj[3];
      if (row >= 0 && row < wp->w_height && col >= 0 && col < wp->w_width) {
        char_u *p;
        int count;

        mouse_comp_pos(wp, &row, &col, &line);


        p = ml_get_buf(wp->w_buffer, line, 
# 3835 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          0
# 3835 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               );
        count = (int)strlen((char *)(p));
        if (col > count) {
          col = count;
        }

        column = col + 1;
      }
    }
  }
  tv_dict_add_nr(d, ("winid"), (sizeof("winid") - 1), winid);
  tv_dict_add_nr(d, ("winrow"), (sizeof("winrow") - 1), winrow);
  tv_dict_add_nr(d, ("wincol"), (sizeof("wincol") - 1), wincol);
  tv_dict_add_nr(d, ("line"), (sizeof("line") - 1), (varnumber_T)line);
  tv_dict_add_nr(d, ("column"), (sizeof("column") - 1), column);
}




static void f_getpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = os_get_pid();
}

static void getpos_both(typval_T *argvars, typval_T *rettv, 
# 3860 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           _Bool 
# 3860 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                getcurpos)
{
  pos_T *fp;
  int fnum = -1;

  if (getcurpos) {
    fp = &curwin->w_cursor;
  } else {
    fp = var2fpos(&argvars[0], 
# 3868 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 3868 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  , &fnum);
  }

  list_T *const l = tv_list_alloc_ret(rettv, 4 + (!!getcurpos));
  tv_list_append_number(l, (fnum != -1) ? (varnumber_T)fnum : (varnumber_T)0);
  tv_list_append_number(l, ((fp != 
# 3873 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  ((void *)0)
# 3873 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      )
                            ? (varnumber_T)fp->lnum
                            : (varnumber_T)0));
  tv_list_append_number(l, ((fp != 
# 3876 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  ((void *)0)
# 3876 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      )
          ? (varnumber_T)(fp->col == MAXCOL ? MAXCOL : fp->col + 1)
                                            : (varnumber_T)0));
  tv_list_append_number(l, (fp != 
# 3879 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0)
# 3879 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     ) ? (varnumber_T)fp->coladd : (varnumber_T)0);
  if (getcurpos) {
    const int save_set_curswant = curwin->w_set_curswant;
    const colnr_T save_curswant = curwin->w_curswant;
    const colnr_T save_virtcol = curwin->w_virtcol;

    update_curswant();
    tv_list_append_number(l, (curwin->w_curswant == MAXCOL
                              ? (varnumber_T)MAXCOL
                              : (varnumber_T)curwin->w_curswant + 1));



    if (save_set_curswant) {
      curwin->w_set_curswant = save_set_curswant;
      curwin->w_curswant = save_curswant;
      curwin->w_virtcol = save_virtcol;
      curwin->w_valid &= ~0x04;
    }
  }
}




static void f_getcurpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getpos_both(argvars, rettv, 
# 3906 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             1
# 3906 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
}




static void f_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getpos_both(argvars, rettv, 
# 3914 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             0
# 3914 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
}


static void f_getqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_qf_loc_list(
# 3920 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 1
# 3920 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , 
# 3920 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 3920 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , &argvars[0], rettv);
}


static void f_getreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *strregname;
  int arg2 = 
# 3927 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 3927 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  
# 3928 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3928 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      return_list = 
# 3928 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 3928 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  
# 3929 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 3929 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 3929 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 3929 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    strregname = tv_get_string_chk(&argvars[0]);
    error = strregname == 
# 3933 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 3933 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
    if (argvars[1].v_type != VAR_UNKNOWN) {
      arg2 = tv_get_number_chk(&argvars[1], &error);
      if (!error && argvars[2].v_type != VAR_UNKNOWN) {
        return_list = tv_get_number_chk(&argvars[2], &error);
      }
    }
  } else {
    strregname = 
# 3941 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                dcgettext (((void *)0), 
# 3941 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                (char *)(get_vim_var_str(VV_REG))
# 3941 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                , 5)
# 3941 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ;
  }

  if (error) {
    return;
  }

  int regname = (uint8_t)(strregname == 
# 3948 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0) 
# 3948 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            ? '"' : *strregname);
  if (regname == 0) {
    regname = '"';
  }

  if (return_list) {
    rettv->v_type = VAR_LIST;
    rettv->vval.v_list =
      get_reg_contents(regname, (arg2 ? kGRegExprSrc : 0) | kGRegList);
    if (rettv->vval.v_list == 
# 3957 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 3957 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ) {
      rettv->vval.v_list = tv_list_alloc(0);
    }
    tv_list_ref(rettv->vval.v_list);
  } else {
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = get_reg_contents(regname, arg2 ? kGRegExprSrc : 0);
  }
}




static void f_getregtype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *strregname;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    strregname = tv_get_string_chk(&argvars[0]);
    if (strregname == 
# 3976 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 3976 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = 
# 3978 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 3978 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
      return;
    }
  } else {

    strregname = 
# 3983 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                dcgettext (((void *)0), 
# 3983 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                (char *)(get_vim_var_str(VV_REG))
# 3983 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                , 5)
# 3983 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ;
  }

  int regname = (uint8_t)(strregname == 
# 3986 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0) 
# 3986 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            ? '"' : *strregname);
  if (regname == 0) {
    regname = '"';
  }

  colnr_T reglen = 0;
  char buf[NUMBUFLEN + 2];
  MotionType reg_type = get_reg_type(regname, &reglen);
  format_reg_type(reg_type, reglen, buf, ((sizeof(buf)/sizeof((buf)[0])) / ((size_t)(!(sizeof(buf) % sizeof((buf)[0]))))));

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)xstrdup(buf);
}


static void f_gettabinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tabpage_T *tparg = 
# 4003 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 4003 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;

  tv_list_alloc_ret(rettv, (argvars[0].v_type == VAR_UNKNOWN
                            ? 1
                            : kListLenMayKnow));

  if (argvars[0].v_type != VAR_UNKNOWN) {

    tparg = find_tabpage((int)tv_get_number_chk(&argvars[0], 
# 4011 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                            ((void *)0)
# 4011 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                ));
    if (tparg == 
# 4012 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4012 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      return;
    }
  }


  int tpnr = 0;
  for (tabpage_T *tp = first_tabpage; tp != 
# 4019 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 4019 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; tp = tp->tp_next) {
    tpnr++;
    if (tparg != 
# 4021 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 4021 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     && tp != tparg) {
      continue;
    }
    dict_T *const d = get_tabpage_info(tp, tpnr);
    tv_list_append_dict(rettv->vval.v_list, d);
    if (tparg != 
# 4026 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4026 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      return;
    }
  }
}




static void f_gettabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *oldcurwin;
  tabpage_T *oldtabpage;
  
# 4039 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4039 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      done = 
# 4039 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 4039 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 4042 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 4042 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  const char *const varname = tv_get_string_chk(&argvars[1]);
  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&argvars[0], 
# 4045 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                        ((void *)0)
# 4045 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                            ));
  if (tp != 
# 4046 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0) 
# 4046 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                && varname != 
# 4046 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 4046 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ) {


    win_T *const window = tp == curtab || tp->tp_firstwin == 
# 4049 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                            ((void *)0)
        
# 4050 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       ? firstwin
        : tp->tp_firstwin;
    if (switch_win(&oldcurwin, &oldtabpage, window, tp, 
# 4052 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       1
# 4052 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           ) == 1) {


      const dictitem_T *const v = find_var_in_ht(&tp->tp_vars->dv_hashtab, 't',
                                                 varname, strlen(varname),
                                                 
# 4057 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                0
# 4057 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     );
      if (v != 
# 4058 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 4058 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
        tv_copy(&v->di_tv, rettv);
        done = 
# 4060 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 4060 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      }
    }


    restore_win(oldcurwin, oldtabpage, 
# 4065 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      1
# 4065 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          );
  }

  if (!done && argvars[2].v_type != VAR_UNKNOWN) {
    tv_copy(&argvars[2], rettv);
  }
}




static void f_gettabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getwinvar(argvars, rettv, 1);
}


static void f_gettagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = curwin;

  tv_dict_alloc_ret(rettv);

  if (argvars[0].v_type != VAR_UNKNOWN) {
    wp = find_win_by_nr_or_id(&argvars[0]);
    if (wp == 
# 4090 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 4090 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      return;
    }
  }

  get_tagstack(wp, rettv->vval.v_dict);
}


static void f_getwininfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wparg = 
# 4101 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  tv_list_alloc_ret(rettv, kListLenMayKnow);

  if (argvars[0].v_type != VAR_UNKNOWN) {
    wparg = win_id2wp(argvars);
    if (wparg == 
# 4107 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4107 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      return;
    }
  }



  int16_t tabnr = 0;
  for (tabpage_T *tp = first_tabpage; tp != 
# 4115 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 4115 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; tp = tp->tp_next) {
    tabnr++;
    int16_t winnr = 0;
    for (win_T *wp = ((tp) == curtab) ? firstwin : (tp)->tp_firstwin; wp != 
# 4118 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 4118 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; wp = wp->w_next) {
      winnr++;
      if (wparg != 
# 4120 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0) 
# 4120 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       && wp != wparg) {
        continue;
      }
      dict_T *const d = get_win_info(wp, tabnr, winnr);
      tv_list_append_dict(rettv->vval.v_list, d);
      if (wparg != 
# 4125 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 4125 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {

        return;
      }
    }
  }
}


static void dummy_timer_due_cb(TimeWatcher *tw, void *data)
{
}


static void dummy_timer_close_cb(TimeWatcher *tw, void *data)
{
  xfree(tw);
}


static void f_wait(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = -1;

  if (argvars[0].v_type != VAR_NUMBER) {
    semsg(
# 4151 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 4151 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invargval)
# 4151 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 4151 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "1");
    return;
  }
  if ((argvars[2].v_type != VAR_NUMBER && argvars[2].v_type != VAR_UNKNOWN)
      || (argvars[2].v_type == VAR_NUMBER && argvars[2].vval.v_number <= 0)) {
    semsg(
# 4156 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 4156 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invargval)
# 4156 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 4156 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "3");
    return;
  }

  int timeout = argvars[0].vval.v_number;
  typval_T expr = argvars[1];
  int interval = argvars[2].v_type == VAR_NUMBER
    ? argvars[2].vval.v_number
    : 200;
  TimeWatcher *tw = xmalloc(sizeof(TimeWatcher));


  time_watcher_init(&main_loop, tw, 
# 4168 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
# 4168 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       );
  tw->events = main_loop.events;
  tw->blockable = 
# 4170 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 1
# 4170 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  time_watcher_start(tw, dummy_timer_due_cb, interval, interval);

  typval_T argv = ((typval_T) { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED, });
  typval_T exprval = ((typval_T) { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED, });
  
# 4175 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4175 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 4175 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 4175 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  int save_called_emsg = called_emsg;
  called_emsg = 
# 4177 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 4177 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  do { int remaining = timeout; uint64_t before = (remaining > 0) ? os_hrtime() : 0; while (!(eval_expr_typval(&expr, &argv, 0, &exprval) != 1 || tv_get_number_chk(&exprval, &error) || called_emsg || error || got_int)) { do { if (main_loop.events && !multiqueue_empty(main_loop.events)) { multiqueue_process_events(main_loop.events); } else { loop_poll_events(&main_loop, remaining); } } while (0); if (remaining == 0) { break; } else if (remaining > 0) { uint64_t now = os_hrtime(); remaining -= (int)((now - before) / 1000000); before = now; if (remaining <= 0) { break; } } } } while (0)


                                                               ;

  if (called_emsg || error) {
    rettv->vval.v_number = -3;
  } else if (got_int) {
    got_int = 
# 4187 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 4187 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
    vgetc();
    rettv->vval.v_number = -2;
  } else if (tv_get_number_chk(&exprval, &error)) {
    rettv->vval.v_number = 0;
  }

  called_emsg = save_called_emsg;


  time_watcher_stop(tw);
  time_watcher_close(tw, dummy_timer_close_cb);
}


static void f_win_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, 2);
  const win_T *const wp = find_win_by_nr_or_id(&argvars[0]);
  tv_list_append_number(rettv->vval.v_list, wp == 
# 4206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 ((void *)0) 
# 4206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      ? 0 : wp->w_winrow + 1);
  tv_list_append_number(rettv->vval.v_list, wp == 
# 4207 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 ((void *)0) 
# 4207 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      ? 0 : wp->w_wincol + 1);
}




static void win_move_into_split(win_T *wp, win_T *targetwin, int size, int flags)
{
  int dir;
  int height = wp->w_height;
  win_T *oldwin = curwin;

  if (wp == targetwin) {
    return;
  }


  if (curwin != targetwin) {
    win_goto(targetwin);
  }


  (void)winframe_remove(wp, &dir, 
# 4229 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0)
# 4229 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     );
  win_remove(wp, 
# 4230 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4230 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
  last_status(
# 4231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 4231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  );
  (void)win_comp_pos();


  (void)win_split_ins(size, flags, wp, dir);


  if (size == 0 && !(flags & 2)) {
    win_setheight_win(height, wp);
    if (p_ea) {
      win_equal(wp, 
# 4241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   1
# 4241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , 'v');
    }
  }

  if (oldwin != curwin) {
    win_goto(oldwin);
  }
}


static void f_win_splitmove(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp;
  win_T *targetwin;
  int flags = 0, size = 0;

  wp = find_win_by_nr_or_id(&argvars[0]);
  targetwin = find_win_by_nr_or_id(&argvars[1]);

  if (wp == 
# 4260 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0) 
# 4260 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                || targetwin == 
# 4260 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0) 
# 4260 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     || wp == targetwin
      || !win_valid(wp) || !win_valid(targetwin)
      || win_valid_floating(wp) || win_valid_floating(targetwin)) {
    emsg(
# 4263 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 4263 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invalwindow)
# 4263 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 4263 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        );
    rettv->vval.v_number = -1;
    return;
  }

  if (argvars[2].v_type != VAR_UNKNOWN) {
    dict_T *d;
    dictitem_T *di;

    if (argvars[2].v_type != VAR_DICT || argvars[2].vval.v_dict == 
# 4272 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  ((void *)0)
# 4272 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                      ) {
      emsg(
# 4273 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 4273 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 4273 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 4273 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }

    d = argvars[2].vval.v_dict;
    if (tv_dict_get_number(d, "vertical")) {
      flags |= 2;
    }
    if ((di = tv_dict_find(d, "rightbelow", -1)) != 
# 4281 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 4281 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ) {
      flags |= tv_get_number(&di->di_tv) ? 32 : 64;
    }
    size = tv_dict_get_number(d, "size");
  }

  win_move_into_split(wp, targetwin, size, flags);
}


static void f_getwinpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, 2);
  tv_list_append_number(rettv->vval.v_list, -1);
  tv_list_append_number(rettv->vval.v_list, -1);
}




static void f_getwinposx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;
}




static void f_getwinposy(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;
}


static void f_getwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  getwinvar(argvars, rettv, 0);
}




static void f_glob(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int options = 0x40|0x04;
  expand_T xpc;
  
# 4327 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4327 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 4327 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 4327 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;



  rettv->v_type = VAR_STRING;
  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (tv_get_number_chk(&argvars[1], &error)) {
      options |= 0x20;
    }
    if (argvars[2].v_type != VAR_UNKNOWN) {
      if (tv_get_number_chk(&argvars[2], &error)) {
        tv_list_set_ret(rettv, 
# 4338 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 4338 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
      }
      if (argvars[3].v_type != VAR_UNKNOWN
          && tv_get_number_chk(&argvars[3], &error)) {
        options |= 0x200;
      }
    }
  }
  if (!error) {
    ExpandInit(&xpc);
    xpc.xp_context = EXPAND_FILES;
    if (p_wic) {
      options += 0x100;
    }
    if (rettv->v_type == VAR_STRING) {
      rettv->vval.v_string = ExpandOne(&xpc, (char_u *)tv_get_string(&argvars[0]), 
# 4353 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                                  ((void *)0)
# 4353 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                      , options,
                                       6);
    } else {
      ExpandOne(&xpc, (char_u *)tv_get_string(&argvars[0]), 
# 4356 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           ((void *)0)
# 4356 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               , options,
                8);
      tv_list_alloc_ret(rettv, xpc.xp_numfiles);
      for (int i = 0; i < xpc.xp_numfiles; i++) {
        tv_list_append_string(rettv->vval.v_list, (const char *)xpc.xp_files[i],
                              -1);
      }
      ExpandCleanup(&xpc);
    }
  } else {
    rettv->vval.v_string = 
# 4366 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 4366 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  }
}


static void f_globpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int flags = 0x400;
  
# 4374 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4374 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 4374 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 4374 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;


  rettv->v_type = VAR_STRING;

  if (argvars[2].v_type != VAR_UNKNOWN) {


    if (tv_get_number_chk(&argvars[2], &error)) {
      flags |= 0x20;
    }

    if (argvars[3].v_type != VAR_UNKNOWN) {
      if (tv_get_number_chk(&argvars[3], &error)) {
        tv_list_set_ret(rettv, 
# 4388 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 4388 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
      }
      if (argvars[4].v_type != VAR_UNKNOWN
          && tv_get_number_chk(&argvars[4], &error)) {
        flags |= 0x200;
      }
    }
  }

  char buf1[NUMBUFLEN];
  const char *const file = tv_get_string_buf_chk(&argvars[1], buf1);
  if (file != 
# 4399 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 4399 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  && !error) {
    garray_T ga;
    ga_init(&ga, (int)sizeof(char_u *), 10);
    globpath((char_u *)tv_get_string(&argvars[0]), (char_u *)file, &ga, flags);

    if (rettv->v_type == VAR_STRING) {
      rettv->vval.v_string = (char_u *)ga_concat_strings_sep(&ga, "\n");
    } else {
      tv_list_alloc_ret(rettv, ga.ga_len);
      for (int i = 0; i < ga.ga_len; i++) {
        tv_list_append_string(rettv->vval.v_list,
                              ((const char **)(ga.ga_data))[i], -1);
      }
    }

    ga_clear_strings(&ga);
  } else {
    rettv->vval.v_string = 
# 4416 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 4416 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  }
}


static void f_glob2regpat(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const pat = tv_get_string_chk(&argvars[0]);

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = ((pat == 
# 4426 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0)
# 4426 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     )
                          ? 
# 4427 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
                          
# 4428 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         : file_pat_to_reg_pat((char_u *)pat, 
# 4428 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                              ((void *)0)
# 4428 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  , 
# 4428 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                    ((void *)0)
# 4428 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        ,
                                                
# 4429 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               0
# 4429 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    ));
}


static void f_has(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  static const char *const has_list[] = {




    "unix",
# 4449 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    "fname_case",


    "acl",

    "autochdir",
    "arabic",
    "autocmd",
    "browsefilter",
    "byte_offset",
    "cindent",
    "cmdline_compl",
    "cmdline_hist",
    "comments",
    "conceal",
    "cscope",
    "cursorbind",
    "cursorshape",



    "dialog_con",
    "diff",
    "digraphs",
    "eval",
    "ex_extra",
    "extra_search",
    "file_in_path",
    "filterpipe",
    "find_in_path",
    "float",
    "folding",

    "fork",

    "gettext",

    "iconv",

    "insert_expand",
    "jumplist",
    "keymap",
    "lambda",
    "langmap",
    "libcall",
    "linebreak",
    "lispindent",
    "listcmds",
    "localmap",






    "menu",
    "mksession",
    "modify_fname",
    "mouse",
    "multi_byte",
    "multi_lang",
    "num64",
    "packages",
    "path_extra",
    "persistent_undo",
    "postscript",
    "printer",
    "profile",
    "pythonx",
    "reltime",
    "quickfix",
    "rightleft",
    "scrollbind",
    "showcmd",
    "cmdline_info",
    "shada",
    "signs",
    "smartindent",
    "startuptime",
    "statusline",
    "spell",
    "syntax",



    "tablineat",
    "tag_binary",
    "termguicolors",
    "termresponse",
    "textobjects",
    "timers",
    "title",
    "user-commands",
    "user_commands",
    "vartabs",
    "vertsplit",
    "vimscript-1",
    "virtualedit",
    "visual",
    "visualextra",
    "vreplace",
    "wildignore",
    "wildmenu",
    "windows",
    "winaltkeys",
    "writebackup",
    "nvim",
  };

  
# 4558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      n = 
# 4558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          0
# 4558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  const char *const name = tv_get_string(&argvars[0]);
  for (size_t i = 0; i < ((sizeof(has_list)/sizeof((has_list)[0])) / ((size_t)(!(sizeof(has_list) % sizeof((has_list)[0]))))); i++) {
    if (strcasecmp((char *)(name), (char *)(has_list[i])) == 0) {
      n = 
# 4562 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         1
# 4562 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
      break;
    }
  }

  if (!n) {
    if (strncasecmp((char *)(name), (char *)("patch"), (size_t)(5)) == 0) {
      if (name[5] == '-'
          && strlen(name) >= 11
          && ascii_isdigit(name[6])
          && ascii_isdigit(name[8])
          && ascii_isdigit(name[10])) {
        int major = atoi(name + 6);
        int minor = atoi(name + 8);


        n = (major < 8
             || (major == 8
                 && (minor < 0
                     || (minor == 0
                         && has_vim_patch(atoi(name + 10))))));
      } else {
        n = has_vim_patch(atoi(name + 5));
      }
    } else if (strncasecmp((char *)(name), (char *)("nvim-"), (size_t)(5)) == 0) {

      n = has_nvim_version(name + 5);
    } else if (strcasecmp((char *)(name), (char *)("vim_starting")) == 0) {
      n = (starting != 0);
    } else if (strcasecmp((char *)(name), (char *)("ttyin")) == 0) {
      n = stdin_isatty;
    } else if (strcasecmp((char *)(name), (char *)("ttyout")) == 0) {
      n = stdout_isatty;
    } else if (strcasecmp((char *)(name), (char *)("multi_byte_encoding")) == 0) {
      n = 
# 4596 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         1
# 4596 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
    } else if (strcasecmp((char *)(name), (char *)("syntax_items")) == 0) {
      n = syntax_present(curwin);
    } else if (strcasecmp((char *)(name), (char *)("clipboard_working")) == 0) {
      n = eval_has_provider("clipboard");
    } else if (strcasecmp((char *)(name), (char *)("wsl")) == 0) {
      n = has_wsl();

    } else if (strcasecmp((char *)(name), (char *)("unnamedplus")) == 0) {
      n = eval_has_provider("clipboard");

    }
  }

  if (!n && eval_has_provider(name)) {
    n = 
# 4611 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       1
# 4611 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           ;
  }

  rettv->vval.v_number = n;
}

static 
# 4617 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
      _Bool 
# 4617 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           has_wsl(void)
{
  static TriState has_wsl = kNone;
  if (has_wsl == kNone) {
    Error err = { .type = kErrorTypeNone, .msg = 
# 4621 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 4621 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               };
    Object o = nlua_exec(((String) { .data = "return vim.loop.os_uname()['release']:lower()" ":match('microsoft') and true or false", .size = sizeof("return vim.loop.os_uname()['release']:lower()" ":match('microsoft') and true or false") - 1 })
                                                                                       ,
                         (Array){ .size = 0, .capacity = 0, .items = 
# 4624 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0) 
# 4624 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               }, &err);
    
# 4625 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 4625 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
    
# 4626 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 4626 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ;
    has_wsl = o.data.boolean ? kTrue : kFalse;
    api_free_object(o);
  }
  return has_wsl == kTrue;
}


static void f_has_key(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_DICT) {
    emsg(
# 4637 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 4637 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 4637 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 4637 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }
  if (argvars[0].vval.v_dict == 
# 4640 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 4640 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ) {
    return;
  }

  rettv->vval.v_number = tv_dict_find(argvars[0].vval.v_dict,
                                      tv_get_string(&argvars[1]),
                                      -1) != 
# 4646 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
# 4646 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                ;
}
# 4660 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static void f_haslocaldir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{

  CdScope scope = kCdScopeInvalid;



  int scope_number[] = {
    [kCdScopeWindow] = 0,
    [kCdScopeTabpage] = 0,
  };

  tabpage_T *tp = curtab;
  win_T *win = curwin;

  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;


  for (int i = kCdScopeWindow; i < kCdScopeGlobal; i++) {
    if (argvars[i].v_type == VAR_UNKNOWN) {
      break;
    }
    if (argvars[i].v_type != VAR_NUMBER) {
      emsg(
# 4684 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 4684 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 4684 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 4684 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }
    scope_number[i] = argvars[i].vval.v_number;
    if (scope_number[i] < -1) {
      emsg(
# 4689 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 4689 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 4689 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 4689 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }

    if (scope_number[i] >= 0 && scope == kCdScopeInvalid) {

      scope = i;
    } else if (scope_number[i] < 0) {
      scope = i + 1;
    }
  }


  if (scope == kCdScopeInvalid) {
    scope = kCdScopeWindow;
  }


  if (scope_number[kCdScopeTabpage] > 0) {
    tp = find_tabpage(scope_number[kCdScopeTabpage]);
    if (!tp) {
      emsg(
# 4710 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 4710 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E5000: Cannot find tab number.")
# 4710 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 4710 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             );
      return;
    }
  }


  if (scope_number[kCdScopeWindow] >= 0) {
    if (scope_number[kCdScopeTabpage] < 0) {
      emsg(
# 4718 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 4718 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E5001: Higher scope cannot be -1 if lower scope is >= 0.")
# 4718 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 4718 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       );
      return;
    }

    if (scope_number[kCdScopeWindow] > 0) {
      win = find_win_by_nr(&argvars[0], tp);
      if (!win) {
        emsg(
# 4725 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 4725 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)("E5002: Cannot find window number.")
# 4725 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 4725 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
        return;
      }
    }
  }

  switch (scope) {
  case kCdScopeWindow:
    
# 4733 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 4733 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
    rettv->vval.v_number = win->w_localdir ? 1 : 0;
    break;
  case kCdScopeTabpage:
    
# 4737 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void) (0))
# 4737 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
    rettv->vval.v_number = tp->tp_localdir ? 1 : 0;
    break;
  case kCdScopeGlobal:

    break;
  case kCdScopeInvalid:

    abort();
  }
}




static void f_hasmapto(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *mode;
  const char *const name = tv_get_string(&argvars[0]);
  
# 4756 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4756 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      abbr = 
# 4756 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 4756 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  char buf[NUMBUFLEN];
  if (argvars[1].v_type == VAR_UNKNOWN) {
    mode = "nvo";
  } else {
    mode = tv_get_string_buf(&argvars[1], buf);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      abbr = tv_get_number(&argvars[2]);
    }
  }

  if (map_to_exists(name, mode, abbr)) {
    rettv->vval.v_number = 
# 4768 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          1
# 4768 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    rettv->vval.v_number = 
# 4770 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          0
# 4770 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ;
  }
}




static void f_histadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  HistoryType histype;

  rettv->vval.v_number = 
# 4781 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        0
# 4781 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
  if (check_secure()) {
    return;
  }
  const char *str = tv_get_string_chk(&argvars[0]);
  histype = str != 
# 4786 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0) 
# 4786 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ? get_histtype(str, strlen(str), 
# 4786 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        0
# 4786 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             ) : HIST_INVALID;
  if (histype != HIST_INVALID) {
    char buf[NUMBUFLEN];
    str = tv_get_string_buf(&argvars[1], buf);
    if (*str != '\000') {
      init_history();
      add_to_history(histype, (char_u *)str, 
# 4792 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 4792 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , '\000');
      rettv->vval.v_number = 
# 4793 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            1
# 4793 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
      return;
    }
  }
}




static void f_histdel(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int n;
  const char *const str = tv_get_string_chk(&argvars[0]);
  if (str == 
# 4806 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 4806 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    n = 0;
  } else if (argvars[1].v_type == VAR_UNKNOWN) {

    n = clr_history(get_histtype(str, strlen(str), 
# 4810 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  0
# 4810 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ));
  } else if (argvars[1].v_type == VAR_NUMBER) {

    n = del_history_idx(get_histtype(str, strlen(str), 
# 4813 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      0
# 4813 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           ),
                        (int)tv_get_number(&argvars[1]));
  } else {

    char buf[NUMBUFLEN];
    n = del_history_entry(get_histtype(str, strlen(str), 
# 4818 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        0
# 4818 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             ),
                          (char_u *)tv_get_string_buf(&argvars[1], buf));
  }
  rettv->vval.v_number = n;
}




static void f_histget(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  HistoryType type;
  int idx;

  const char *const str = tv_get_string_chk(&argvars[0]);
  if (str == 
# 4833 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 4833 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_string = 
# 4834 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 4834 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    type = get_histtype(str, strlen(str), 
# 4836 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         0
# 4836 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              );
    if (argvars[1].v_type == VAR_UNKNOWN) {
      idx = get_history_idx(type);
    } else {
      idx = (int)tv_get_number_chk(&argvars[1], 
# 4840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 4840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   );
    }

    rettv->vval.v_string = vim_strsave(get_history_entry(type, idx));
  }
  rettv->v_type = VAR_STRING;
}




static void f_histnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const history = tv_get_string_chk(&argvars[0]);
  HistoryType i = history == 
# 4854 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
    
# 4855 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ? HIST_INVALID
    : get_histtype(history, strlen(history), 
# 4856 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 4856 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
  if (i != HIST_INVALID) {
    i = get_history_idx(i);
  }
  rettv->vval.v_number = i;
}




static void f_hlID(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = syn_name2id(tv_get_string(&argvars[0]));
}




static void f_hlexists(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = highlight_exists(tv_get_string(&argvars[0]));
}




static void f_hostname(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char hostname[256];

  os_get_hostname(hostname, 256);
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = vim_strsave((char_u *)hostname);
}




static void f_iconv(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  vimconv_T vimconv;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 4899 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 4899 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  const char *const str = tv_get_string(&argvars[0]);
  char buf1[NUMBUFLEN];
  char_u *const from = enc_canonize(enc_skip((char_u *)tv_get_string_buf(&argvars[1], buf1)));
  char buf2[NUMBUFLEN];
  char_u *const to = enc_canonize(enc_skip((char_u *)tv_get_string_buf(&argvars[2], buf2)));
  vimconv.vc_type = CONV_NONE;
  convert_setup(&vimconv, from, to);


  if (vimconv.vc_type == CONV_NONE) {
    rettv->vval.v_string = (char_u *)xstrdup(str);
  } else {
    rettv->vval.v_string = string_convert(&vimconv, (char_u *)str, 
# 4913 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  ((void *)0)
# 4913 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                      );
  }

  convert_setup(&vimconv, 
# 4916 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 4916 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             , 
# 4916 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 4916 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );
  xfree(from);
  xfree(to);
}




static void f_indent(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const linenr_T lnum = tv_get_lnum(argvars);
  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {
    rettv->vval.v_number = get_indent_lnum(lnum);
  } else {
    rettv->vval.v_number = -1;
  }
}




static void f_index(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  long idx = 0;
  
# 4940 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 4940 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      ic = 
# 4940 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           0
# 4940 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;

  rettv->vval.v_number = -1;
  if (argvars[0].v_type == VAR_BLOB) {
    
# 4944 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 4944 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 4944 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 4944 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
    int start = 0;

    if (argvars[2].v_type != VAR_UNKNOWN) {
      start = tv_get_number_chk(&argvars[2], &error);
      if (error) {
        return;
      }
    }
    blob_T *const b = argvars[0].vval.v_blob;
    if (b == 
# 4954 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 4954 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      return;
    }
    if (start < 0) {
      start = tv_blob_len(b) + start;
      if (start < 0) {
        start = 0;
      }
    }
    for (idx = start; idx < tv_blob_len(b); idx++) {
      typval_T tv;
      tv.v_type = VAR_NUMBER;
      tv.vval.v_number = tv_blob_get(b, idx);
      if (tv_equal(&tv, &argvars[1], ic, 
# 4967 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        0
# 4967 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             )) {
        rettv->vval.v_number = idx;
        return;
      }
    }
    return;
  } else if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 4974 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 4974 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listblobreq)
# 4974 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 4974 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        );
    return;
  }
  list_T *const l = argvars[0].vval.v_list;
  if (l != 
# 4978 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 4978 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    listitem_T *item = tv_list_first(l);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      
# 4981 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 4981 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          error = 
# 4981 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 4981 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;


      idx = tv_list_uidx(l, tv_get_number_chk(&argvars[2], &error));
      if (error || idx == -1) {
        item = 
# 4986 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 4986 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      } else {
        item = tv_list_find(l, idx);
        
# 4989 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       ((void) (0))
# 4989 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
      }
      if (argvars[3].v_type != VAR_UNKNOWN) {
        ic = !!tv_get_number_chk(&argvars[3], &error);
        if (error) {
          item = 
# 4994 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 4994 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
        }
      }
    }

    for (; item != 
# 4999 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 4999 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ; item = ((item)->li_next), idx++) {
      if (tv_equal((&(item)->li_tv), &argvars[1], ic, 
# 5000 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                          0
# 5000 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               )) {
        rettv->vval.v_number = idx;
        break;
      }
    }
  }
}

static 
# 5008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
      _Bool 
# 5008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           inputsecret_flag = 
# 5008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 5008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ;





static void f_input(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_user_input(argvars, rettv, 0, inputsecret_flag);
}




static void f_inputdialog(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_user_input(argvars, rettv, 1, inputsecret_flag);
}




static void f_inputlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int selected;
  int mouse_used;

  if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 5036 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 5036 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listarg)
# 5036 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 5036 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "inputlist()");
    return;
  }

  msg_start();
  msg_row = Rows - 1;
  lines_left = Rows;
  msg_scroll = 
# 5043 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 5043 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  msg_clr_eos();

  do { const list_T *const l_ = (argvars[0].vval.v_list); ; if (l_ != 
# 5046 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5046 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 5046 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5046 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { msg_puts(tv_get_string((&(li)->li_tv))); msg_putchar('\n'); } } } } while (0)


    ;


  selected = prompt_for_number(&mouse_used);
  if (mouse_used) {
    selected -= lines_left;
  }

  rettv->vval.v_number = selected;
}


static garray_T ga_userinput = { 0, 0, sizeof(tasave_T), 4, 
# 5061 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           ((void *)0) 
# 5061 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                };


static void f_inputrestore(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (!((&ga_userinput)->ga_len <= 0)) {
    ga_userinput.ga_len--;
    restore_typeahead((tasave_T *)(ga_userinput.ga_data)
                      + ga_userinput.ga_len);

  } else if (p_verbose > 1) {
    verb_msg(
# 5072 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 5072 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)("called inputrestore() more often than inputsave()")
# 5072 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 5072 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  );
    rettv->vval.v_number = 1;
  }
}


static void f_inputsave(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{

  tasave_T *p = ga_append_via_ptr(&ga_userinput, sizeof(tasave_T));
  save_typeahead(p);
}


static void f_inputsecret(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  cmdline_star++;
  inputsecret_flag = 
# 5089 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    1
# 5089 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  f_input(argvars, rettv, 
# 5090 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 5090 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             );
  cmdline_star--;
  inputsecret_flag = 
# 5092 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 5092 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
}




static void f_insert(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  list_T *l;
  
# 5101 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 5101 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 5101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  if (argvars[0].v_type == VAR_BLOB) {
    blob_T *const b = argvars[0].vval.v_blob;

    if (b == 
# 5106 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
        
# 5107 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       || var_check_lock(b->bv_lock, "insert() argument",
                          (
# 5108 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         (18446744073709551615UL)
# 5108 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ))) {
      return;
    }

    long before = 0;
    const int len = tv_blob_len(b);

    if (argvars[2].v_type != VAR_UNKNOWN) {
      before = (long)tv_get_number_chk(&argvars[2], &error);
      if (error) {
        return;
      }
      if (before < 0 || before > len) {
        semsg(
# 5121 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 5121 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 5121 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 5121 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , tv_get_string(&argvars[2]));
        return;
      }
    }
    const int val = tv_get_number_chk(&argvars[1], &error);
    if (error) {
      return;
    }
    if (val < 0 || val > 255) {
      semsg(
# 5130 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 5130 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 5130 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 5130 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , tv_get_string(&argvars[1]));
      return;
    }

    ga_grow(&b->bv_ga, 1);
    char_u *const p = (char_u *)b->bv_ga.ga_data;
    memmove(p + before + 1, p + before, (size_t)len - before);
    *(p + before) = val;
    b->bv_ga.ga_len++;

    tv_copy(&argvars[0], rettv);
  } else if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 5142 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 5142 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listblobarg)
# 5142 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 5142 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "insert()");
  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),
                             "insert() argument", (
# 5144 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     (18446744073709551615UL)
# 5144 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     ))) {
    long before = 0;
    if (argvars[2].v_type != VAR_UNKNOWN) {
      before = tv_get_number_chk(&argvars[2], &error);
    }
    if (error) {

      return;
    }

    listitem_T *item = 
# 5154 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 5154 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
    if (before != tv_list_len(l)) {
      item = tv_list_find(l, before);
      if (item == 
# 5157 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 5157 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
        semsg(
# 5158 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 5158 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_listidx)
# 5158 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 5158 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , (int64_t)before);
        l = 
# 5159 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 5159 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
      }
    }
    if (l != 
# 5162 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 5162 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      tv_list_insert_tv(l, &argvars[1], item);
      tv_copy(&argvars[0], rettv);
    }
  }
}


static void f_interrupt(typval_T *argvars FUNC_ATTR_UNUSED, typval_T *rettv FUNC_ATTR_UNUSED,
                        FunPtr fptr FUNC_ATTR_UNUSED)
{
  got_int = 
# 5173 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           1
# 5173 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
}




static void f_invert(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = ~tv_get_number_chk(&argvars[0], 
# 5181 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        ((void *)0)
# 5181 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            );
}




static void f_isdirectory(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = os_isdir((const char_u *)tv_get_string(&argvars[0]));
}




static void f_islocked(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  lval_T lv;
  dictitem_T *di;

  rettv->vval.v_number = -1;
  const char_u *const end = get_lval((char_u *)tv_get_string(&argvars[0]),
                                     
# 5202 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 5202 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ,
                                     &lv, 
# 5203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         0
# 5203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              , 
# 5203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                0
# 5203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     ,
                                     GLV_NO_AUTOLOAD|GLV_READ_ONLY,
                                     2);
  if (end != 
# 5206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 5206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && lv.ll_name != 
# 5206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  ((void *)0)
# 5206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      ) {
    if (*end != '\000') {
      emsg(
# 5208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 5208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_trailing)
# 5208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 5208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
    } else {
      if (lv.ll_tv == 
# 5210 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 5210 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
        di = find_var(lv.ll_name, lv.ll_name_len, 
# 5211 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 ((void *)0)
# 5211 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     , 
# 5211 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       1
# 5211 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           );
        if (di != 
# 5212 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 5212 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {




          rettv->vval.v_number = ((di->di_flags & DI_FLAGS_LOCK)
                                  || tv_islocked(&di->di_tv));
        }
      } else if (lv.ll_range) {
        emsg(
# 5221 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 5221 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)("E786: Range not allowed")
# 5221 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 5221 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        );
      } else if (lv.ll_newkey != 
# 5222 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0)
# 5222 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ) {
        semsg(
# 5223 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 5223 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_dictkey)
# 5223 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 5223 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , lv.ll_newkey);
      } else if (lv.ll_list != 
# 5224 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 5224 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ) {

        rettv->vval.v_number = tv_islocked((&(lv.ll_li)->li_tv));
      } else {

        rettv->vval.v_number = tv_islocked(&lv.ll_di->di_tv);
      }
    }
  }

  clear_lval(&lv);
}


static void f_isinf(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type == VAR_FLOAT
      && xisinf(argvars[0].vval.v_float)) {
    rettv->vval.v_number = argvars[0].vval.v_float > 0.0 ? 1 : -1;
  }
}


static void f_isnan(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = argvars[0].v_type == VAR_FLOAT
                         && xisnan(argvars[0].vval.v_float);
}


static void f_id(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  const int len = vim_vsnprintf_typval(
# 5257 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      ((void *)0)
# 5257 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          , 0, "%p", dummy_ap, argvars);
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = xmalloc(len + 1);
  vim_vsnprintf_typval((char *)rettv->vval.v_string, len + 1, "%p",
                       dummy_ap, argvars);
}




static void f_items(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_list(argvars, rettv, 2);
}


static void f_jobpid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER) {
    emsg(
# 5283 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5283 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 5283 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5283 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  Channel *data = find_job(argvars[0].vval.v_number, 
# 5287 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    1
# 5287 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );
  if (!data) {
    return;
  }

  Process *proc = &data->stream.proc;
  rettv->vval.v_number = proc->pid;
}


static void f_jobresize(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER || argvars[1].v_type != VAR_NUMBER
      || argvars[2].v_type != VAR_NUMBER) {

    emsg(
# 5309 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5309 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 5309 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5309 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }


  Channel *data = find_job(argvars[0].vval.v_number, 
# 5314 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    1
# 5314 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );
  if (!data) {
    return;
  }

  if (data->stream.proc.type != kProcessTypePty) {
    emsg(
# 5320 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5320 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_channotpty)
# 5320 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5320 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
    return;
  }

  pty_process_resize(&data->stream.pty, argvars[1].vval.v_number,
                     argvars[2].vval.v_number);
  rettv->vval.v_number = 1;
}

static const char *ignored_env_vars[] = {

  "COLUMNS",
  "LINES",
  "TERMCAP",
  "COLORFGBG",

  
# 5336 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)

# 5337 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
};



static const char *required_env_vars[] = {
# 5355 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
  
# 5355 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)

# 5356 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
};

static dict_T *create_environment(const dictitem_T *job_env, const 
# 5358 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  _Bool 
# 5358 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       clear_env, const 
# 5358 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                                        _Bool 
# 5358 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                             pty,
                                  const char * const pty_term_name)
{
  dict_T *env = tv_dict_alloc();

  if (!clear_env) {
    typval_T temp_env = ((typval_T) { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED, });
    f_environ(
# 5365 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 5365 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 , &temp_env, 
# 5365 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 5365 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
    tv_dict_extend(env, temp_env.vval.v_dict, "force");
    tv_dict_free(temp_env.vval.v_dict);

    if (pty) {



      for (size_t i = 0;
           i < ((sizeof(ignored_env_vars)/sizeof((ignored_env_vars)[0])) / ((size_t)(!(sizeof(ignored_env_vars) % sizeof((ignored_env_vars)[0]))))) && ignored_env_vars[i];
           i++) {
        dictitem_T *dv = tv_dict_find(env, ignored_env_vars[i], -1);
        if (dv) {
          tv_dict_item_remove(env, dv);
        }
      }



      dictitem_T *dv = tv_dict_find(env, ("COLORTERM"), (sizeof("COLORTERM") - 1));
      if (dv) {
        tv_dict_item_remove(env, dv);
        tv_dict_add_str(env, ("COLORTERM"), (sizeof("COLORTERM") - 1), p_tgc ? "truecolor" : "256");
      }

    }
  }





  if (pty) {
    dictitem_T *dv = tv_dict_find(env, ("TERM"), (sizeof("TERM") - 1));
    if (dv) {
      tv_dict_item_remove(env, dv);
    }
    tv_dict_add_str(env, ("TERM"), (sizeof("TERM") - 1), pty_term_name);
  }

  if (job_env) {
# 5419 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    tv_dict_extend(env, job_env->di_tv.vval.v_dict, "force");

  }

  if (pty) {


    for (size_t i = 0;
         i < ((sizeof(required_env_vars)/sizeof((required_env_vars)[0])) / ((size_t)(!(sizeof(required_env_vars) % sizeof((required_env_vars)[0]))))) && required_env_vars[i];
         i++) {
      size_t len = strlen(required_env_vars[i]);
      dictitem_T *dv = tv_dict_find(env, required_env_vars[i], len);
      if (!dv) {
        const char *env_var = os_getenv(required_env_vars[i]);
        if (env_var) {
          tv_dict_add_str(env, required_env_vars[i], len, env_var);
        }
      }
    }
  }

  return env;
}


static void f_jobstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  
# 5453 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5453 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      executable = 
# 5453 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   1
# 5453 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  char **argv = tv_to_argv(&argvars[0], 
# 5454 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 5454 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           , &executable);
  dict_T *env = 
# 5455 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 5455 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  if (!argv) {
    rettv->vval.v_number = executable ? 0 : -1;
    return;
  }

  if (argvars[1].v_type != VAR_DICT && argvars[1].v_type != VAR_UNKNOWN) {

    semsg(
# 5463 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 5463 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 5463 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 5463 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected dictionary");
    shell_free_argv(argv);
    return;
  }


  dict_T *job_opts = 
# 5469 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 5469 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  
# 5470 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5470 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      detach = 
# 5470 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 5470 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  
# 5471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      rpc = 
# 5471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 5471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  
# 5472 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5472 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      pty = 
# 5472 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 5472 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  
# 5473 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5473 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      clear_env = 
# 5473 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 5473 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  
# 5474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      overlapped = 
# 5474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   0
# 5474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  ChannelStdinMode stdin_mode = kChannelStdinPipe;
  CallbackReader on_stdout = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .buffer = { 0, 0, 0, 1, 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }, .buffered = 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            0
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .type = 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 5476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }),
                 on_stderr = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .buffer = { 0, 0, 0, 1, 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }, .buffered = 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            0
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .type = 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 5477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            });
  Callback on_exit = ((Callback){ .type = kCallbackNone });
  char *cwd = 
# 5479 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 5479 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  dictitem_T *job_env = 
# 5480 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 5480 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  if (argvars[1].v_type == VAR_DICT) {
    job_opts = argvars[1].vval.v_dict;

    detach = tv_dict_get_number(job_opts, "detach") != 0;
    rpc = tv_dict_get_number(job_opts, "rpc") != 0;
    pty = tv_dict_get_number(job_opts, "pty") != 0;
    clear_env = tv_dict_get_number(job_opts, "clear_env") != 0;
    overlapped = tv_dict_get_number(job_opts, "overlapped") != 0;

    char *s = tv_dict_get_string(job_opts, "stdin", 
# 5490 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   0
# 5490 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );
    if (s) {
      if (!strncmp(s, "null", NUMBUFLEN)) {
        stdin_mode = kChannelStdinNull;
      } else if (!strncmp(s, "pipe", NUMBUFLEN)) {

      } else {
        semsg(
# 5497 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 5497 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invargNval)
# 5497 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 5497 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , "stdin", s);
      }
    }

    if (pty && rpc) {
      semsg(
# 5502 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 5502 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 5502 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 5502 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "job cannot have both 'pty' and 'rpc' options set");
      shell_free_argv(argv);
      return;
    }
# 5516 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    char *new_cwd = tv_dict_get_string(job_opts, "cwd", 
# 5516 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       0
# 5516 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            );
    if (new_cwd && *new_cwd != '\000') {
      cwd = new_cwd;

      if (!os_isdir_executable((const char *)cwd)) {
        semsg(
# 5521 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 5521 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 5521 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 5521 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "expected valid directory");
        shell_free_argv(argv);
        return;
      }
    }

    job_env = tv_dict_find(job_opts, ("env"), (sizeof("env") - 1));
    if (job_env && job_env->di_tv.v_type != VAR_DICT) {
      semsg(
# 5529 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 5529 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 5529 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 5529 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "env");
      shell_free_argv(argv);
      return;
    }

    if (!common_job_callbacks(job_opts, &on_stdout, &on_stderr, &on_exit)) {
      shell_free_argv(argv);
      return;
    }
  }

  uint16_t width = 0, height = 0;
  char *term_name = 
# 5541 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 5541 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;

  if (pty) {
    width = (uint16_t)tv_dict_get_number(job_opts, "width");
    height = (uint16_t)tv_dict_get_number(job_opts, "height");


    term_name = tv_dict_get_string(job_opts, "TERM", 
# 5548 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    0
# 5548 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
    if (!term_name) {
      term_name = "ansi";
    }
  }

  env = create_environment(job_env, clear_env, pty, term_name);

  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit, pty,
                                    rpc, overlapped, detach, stdin_mode, cwd,
                                    width, height, env, &rettv->vval.v_number);
  if (chan) {
    channel_create_event(chan, 
# 5560 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 5560 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
  }
}


static void f_jobstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER) {

    emsg(
# 5576 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5576 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 5576 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5576 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  Channel *data = find_job(argvars[0].vval.v_number, 
# 5580 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    0
# 5580 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
  if (!data) {
    return;
  }

  const char *error = 
# 5585 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 5585 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  if (data->is_rpc) {

    (void)channel_close(data->id, kChannelPartRpc, &error);
  }
  process_stop(&data->stream.proc);
  rettv->vval.v_number = 1;
  if (error) {
    emsg(error);
  }
}


static void f_jobwait(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }
  if (argvars[0].v_type != VAR_LIST || (argvars[1].v_type != VAR_NUMBER
                                        && argvars[1].v_type != VAR_UNKNOWN)) {
    emsg(
# 5608 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5608 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 5608 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5608 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  ui_busy_start();
  list_T *args = argvars[0].vval.v_list;
  Channel **jobs = xcalloc(tv_list_len(args), sizeof(*jobs));
  MultiQueue *waiting_jobs = multiqueue_new_parent(loop_on_put, &main_loop);


  int i = 0;
  do { const list_T *const l_ = (args); ; if (l_ != 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *arg = l_->lv_first; arg != 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; arg = arg->li_next) { { Channel *chan = 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; if ((&(arg)->li_tv)->v_type != VAR_NUMBER || !(chan = find_channel((&(arg)->li_tv)->vval.v_number)) || chan->streamtype != kChannelStreamProc) { jobs[i] = 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; } else if (process_is_stopped(&chan->stream.proc)) { process_wait(&chan->stream.proc, -1, 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ); jobs[i] = 
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5619 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; } else { jobs[i] = chan; channel_incref(chan); if (chan->stream.proc.status < 0) { multiqueue_process_events(chan->events); multiqueue_replace_parent(chan->events, waiting_jobs); } } i++; } } } } while (0)
# 5640 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    ;

  int remaining = -1;
  uint64_t before = 0;
  if (argvars[1].v_type == VAR_NUMBER && argvars[1].vval.v_number >= 0) {
    remaining = argvars[1].vval.v_number;
    before = os_hrtime();
  }

  for (i = 0; i < tv_list_len(args); i++) {
    if (remaining == 0) {
      break;
    }
    if (jobs[i] == 
# 5653 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 5653 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
      continue;
    }
    int status = process_wait(&jobs[i]->stream.proc, remaining,
                              waiting_jobs);
    if (status < 0) {
      break;
    }
    if (remaining > 0) {
      uint64_t now = os_hrtime();
      remaining = 
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 (((
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 0
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 )<(
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 remaining - (int)((now - before) / 1000000)
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ))?(
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 0
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ):(
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 remaining - (int)((now - before) / 1000000)
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ))
# 5663 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                    ;
      before = now;
    }
  }

  list_T *const rv = tv_list_alloc(tv_list_len(args));







  for (i = 0; i < tv_list_len(args); i++) {
    if (jobs[i] == 
# 5677 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 5677 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
      tv_list_append_number(rv, -3);
      continue;
    }
    multiqueue_process_events(jobs[i]->events);
    multiqueue_replace_parent(jobs[i]->events, main_loop.events);

    tv_list_append_number(rv, jobs[i]->stream.proc.status);
    channel_decref(jobs[i]);
  }

  multiqueue_free(waiting_jobs);
  xfree(jobs);
  ui_busy_stop();
  tv_list_ref(rv);
  rettv->v_type = VAR_LIST;
  rettv->vval.v_list = rv;
}




static void f_join(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 5702 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5702 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 5702 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5702 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }
  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN
                           ? " "
                           : tv_get_string_chk(&argvars[1]));

  rettv->v_type = VAR_STRING;

  if (sep != 
# 5711 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 5711 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    garray_T ga;
    ga_init(&ga, (int)sizeof(char), 80);
    tv_list_join(&ga, argvars[0].vval.v_list, sep);
    ga_append(&ga, '\000');
    rettv->vval.v_string = (char_u *)ga.ga_data;
  } else {
    rettv->vval.v_string = 
# 5718 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 5718 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  }
}


static void f_json_decode(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char numbuf[NUMBUFLEN];
  const char *s = 
# 5726 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 5726 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  char *tofree = 
# 5727 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 5727 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  size_t len;
  if (argvars[0].v_type == VAR_LIST) {
    if (!encode_vim_list_to_buf(argvars[0].vval.v_list, &len, &tofree)) {
      emsg(
# 5731 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 5731 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)("E474: Failed to convert list to string")
# 5731 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 5731 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     );
      return;
    }
    s = tofree;
    if (s == 
# 5735 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 5735 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      
# 5736 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     ((void) (0))
# 5736 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
      s = "";
    }
  } else {
    s = tv_get_string_buf_chk(&argvars[0], numbuf);
    if (s) {
      len = strlen(s);
    } else {
      return;
    }
  }
  if (json_decode_string(s, len, rettv) == 0) {
    semsg(
# 5748 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 5748 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E474: Failed to parse %.*s")
# 5748 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 5748 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        , (int)len, s);
    rettv->v_type = VAR_NUMBER;
    rettv->vval.v_number = 0;
  }
  
# 5752 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void) (0))
# 5752 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     ;
  xfree(tofree);
}


static void f_json_encode(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)encode_tv2json(&argvars[0], 
# 5760 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                              ((void *)0)
# 5760 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  );
}




static void f_keys(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_list(argvars, rettv, 0);
}




static void f_last_buffer_nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int n = 0;

  for (buf_T *buf = firstbuf; buf != 
# 5778 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5778 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; buf = buf->b_next) {
    if (n < buf->handle) {
      n = buf->handle;
    }
  }

  rettv->vval.v_number = n;
}




static void f_len(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  switch (argvars[0].v_type) {
  case VAR_STRING:
  case VAR_NUMBER:
    rettv->vval.v_number = (varnumber_T)strlen(tv_get_string(&argvars[0]));
    break;
  case VAR_BLOB:
    rettv->vval.v_number = tv_blob_len(argvars[0].vval.v_blob);
    break;
  case VAR_LIST:
    rettv->vval.v_number = tv_list_len(argvars[0].vval.v_list);
    break;
  case VAR_DICT:
    rettv->vval.v_number = tv_dict_len(argvars[0].vval.v_dict);
    break;
  case VAR_UNKNOWN:
  case VAR_BOOL:
  case VAR_SPECIAL:
  case VAR_FLOAT:
  case VAR_PARTIAL:
  case VAR_FUNC:
    emsg(
# 5812 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5812 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E701: Invalid type for len()")
# 5812 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5812 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         );
    break;
  }
}

static void libcall_common(typval_T *argvars, typval_T *rettv, int out_type)
{
  rettv->v_type = out_type;
  if (out_type != VAR_NUMBER) {
    rettv->vval.v_string = 
# 5821 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 5821 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  }

  if (check_secure()) {
    return;
  }


  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {
    return;
  }

  const char *libname = (char *)argvars[0].vval.v_string;
  const char *funcname = (char *)argvars[1].vval.v_string;

  VarType in_type = argvars[2].v_type;


  char *str_in = (in_type == VAR_STRING)
      ? (char *)argvars[2].vval.v_string : 
# 5840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 5840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ;
  int int_in = argvars[2].vval.v_number;


  char **str_out = (out_type == VAR_STRING)
      ? (char **)&rettv->vval.v_string : 
# 5845 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0)
# 5845 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            ;
  int int_out = 0;

  
# 5848 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 5848 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      success = os_libcall(libname, funcname,
                            str_in, int_in,
                            str_out, &int_out);

  if (!success) {
    semsg(
# 5853 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 5853 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_libcall)
# 5853 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 5853 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , funcname);
    return;
  }

  if (out_type == VAR_NUMBER) {
    rettv->vval.v_number = (varnumber_T)int_out;
  }
}




static void f_libcall(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  libcall_common(argvars, rettv, VAR_STRING);
}




static void f_libcallnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  libcall_common(argvars, rettv, VAR_NUMBER);
}


static void f_line(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum = 0;
  pos_T *fp = 
# 5882 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 5882 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  int fnum;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    tabpage_T *tp;
    win_T *save_curwin;
    tabpage_T *save_curtab;


    win_T *wp = win_id2wp_tp(&argvars[1], &tp);
    if (wp != 
# 5892 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 5892 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  && tp != 
# 5892 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 5892 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ) {
      if (switch_win_noblock(&save_curwin, &save_curtab, wp, tp, 
# 5893 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                1
# 5893 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                    )
          == 1) {
        check_cursor();
        fp = var2fpos(&argvars[0], 
# 5896 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  1
# 5896 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      , &fnum);
      }
      restore_win_noblock(save_curwin, save_curtab, 
# 5898 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   1
# 5898 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
    }
  } else {

    fp = var2fpos(&argvars[0], 
# 5902 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 5902 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  , &fnum);
  }

  if (fp != 
# 5905 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 5905 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    lnum = fp->lnum;
  }
  rettv->vval.v_number = lnum;
}




static void f_line2byte(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const linenr_T lnum = tv_get_lnum(argvars);
  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count + 1) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = ml_find_line_or_offset(curbuf, lnum, 
# 5920 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                               ((void *)0)
# 5920 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                   , 
# 5920 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     0
# 5920 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                          );
  }
  if (rettv->vval.v_number >= 0) {
    rettv->vval.v_number++;
  }
}




static void f_lispindent(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const pos_T pos = curwin->w_cursor;
  const linenr_T lnum = tv_get_lnum(argvars);
  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count) {
    curwin->w_cursor.lnum = lnum;
    rettv->vval.v_number = get_lisp_indent();
    curwin->w_cursor = pos;
  } else {
    rettv->vval.v_number = -1;
  }
}


static void f_list2str(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  garray_T ga;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 5949 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 5949 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 5951 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 5951 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 5951 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 5951 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  list_T *const l = argvars[0].vval.v_list;
  if (l == 
# 5956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 5956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    return;
  }

  ga_init(&ga, 1, 80);
  char_u buf[21 + 1];

  do { const list_T *const l_ = (l); ; if (l_ != 
# 5963 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5963 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 5963 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 5963 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { buf[utf_char2bytes(tv_get_number((&(li)->li_tv)), buf)] = '\000'; ga_concat(&ga, (char *)buf); } } } } while (0)


    ;
  ga_append(&ga, '\000');

  rettv->vval.v_string = ga.ga_data;
}




static void f_localtime(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = (varnumber_T)time(
# 5977 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 5977 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              );
}


static void get_maparg(typval_T *argvars, typval_T *rettv, int exact)
{
  char_u *keys_buf = 
# 5983 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 5983 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  char_u *rhs;
  int mode;
  int abbr = 0;
  int get_dict = 0;
  mapblock_T *mp;
  int buffer_local;


  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 5993 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 5993 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  char_u *keys = (char_u *)tv_get_string(&argvars[0]);
  if (*keys == '\000') {
    return;
  }

  char buf[NUMBUFLEN];
  const char *which;
  if (argvars[1].v_type != VAR_UNKNOWN) {
    which = tv_get_string_buf_chk(&argvars[1], buf);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      abbr = tv_get_number(&argvars[2]);
      if (argvars[3].v_type != VAR_UNKNOWN) {
        get_dict = tv_get_number(&argvars[3]);
      }
    }
  } else {
    which = "";
  }
  if (which == 
# 6013 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6013 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }

  mode = get_map_mode((char_u **)&which, 0);

  keys = replace_termcodes(keys, strlen((char *)(keys)), &keys_buf, 
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         1
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             , 
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                               1
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                   , 
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     1
# 6019 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                         ,
                           ((vim_strchr(p_cpo, 'B') == 
# 6020 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 6020 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ) ? 0 : 0x01));
  rhs = check_map(keys, mode, exact, 
# 6021 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    0
# 6021 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , abbr, &mp, &buffer_local);
  xfree(keys_buf);

  if (!get_dict) {

    if (rhs != 
# 6026 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6026 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      if (*rhs == '\000') {
        rettv->vval.v_string = vim_strsave((char_u *)"<Nop>");
      } else {
        rettv->vval.v_string = (char_u *)str2special_save((char *)rhs, 
# 6030 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                      0
# 6030 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                           , 
# 6030 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                             0
# 6030 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                  );
      }
    }
  } else {
    tv_dict_alloc_ret(rettv);
    if (rhs != 
# 6035 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6035 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {

      mapblock_fill_dict(rettv->vval.v_dict, mp, buffer_local, 
# 6037 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                              1
# 6037 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                  );
    }
  }
}


static void f_luaeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  const char *const str = tv_get_string_chk(&argvars[0]);
  if (str == 
# 6047 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6047 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  nlua_typval_eval(cstr_as_string((char *)str), &argvars[1], rettv);
}




static void f_map(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  filter_map(argvars, rettv, 1);
}




static void f_maparg(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_maparg(argvars, rettv, 1);
}




static void f_mapcheck(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_maparg(argvars, rettv, 0);
}


static void find_some_match(typval_T *const argvars, typval_T *const rettv,
                            const SomeMatchType type)
{
  char_u *str = 
# 6082 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 6082 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  long len = 0;
  char_u *expr = 
# 6084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 6084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  regmatch_T regmatch;
  char_u *save_cpo;
  long start = 0;
  long nth = 1;
  colnr_T startcol = 0;
  
# 6090 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 6090 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      match = 
# 6090 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6090 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  list_T *l = 
# 6091 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 6091 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  listitem_T *li = 
# 6092 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 6092 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  long idx = 0;
  char_u *tofree = 
# 6094 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 6094 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;


  save_cpo = p_cpo;
  p_cpo = (char_u *)"";

  rettv->vval.v_number = -1;
  switch (type) {

  case kSomeMatchList:
    tv_list_alloc_ret(rettv, kListLenMayKnow);
    break;

  case kSomeMatchStrPos:
    tv_list_alloc_ret(rettv, 4);
    tv_list_append_string(rettv->vval.v_list, "", 0);
    tv_list_append_number(rettv->vval.v_list, -1);
    tv_list_append_number(rettv->vval.v_list, -1);
    tv_list_append_number(rettv->vval.v_list, -1);
    break;
  case kSomeMatchStr:
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = 
# 6116 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 6116 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
    break;
  case kSomeMatch:
  case kSomeMatchEnd:

    break;
  }

  if (argvars[0].v_type == VAR_LIST) {
    if ((l = argvars[0].vval.v_list) == 
# 6125 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0)
# 6125 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ) {
      goto theend;
    }
    li = tv_list_first(l);
  } else {
    expr = str = (char_u *)tv_get_string(&argvars[0]);
    len = (long)strlen((char *)(str));
  }

  char patbuf[NUMBUFLEN];
  const char *const pat = tv_get_string_buf_chk(&argvars[1], patbuf);
  if (pat == 
# 6136 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6136 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    goto theend;
  }

  if (argvars[2].v_type != VAR_UNKNOWN) {
    
# 6141 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 6141 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 6141 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 6141 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

    start = tv_get_number_chk(&argvars[2], &error);
    if (error) {
      goto theend;
    }
    if (l != 
# 6147 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6147 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      idx = tv_list_uidx(l, start);
      if (idx == -1) {
        goto theend;
      }
      li = tv_list_find(l, idx);
    } else {
      if (start < 0) {
        start = 0;
      }
      if (start > len) {
        goto theend;
      }



      if (argvars[3].v_type != VAR_UNKNOWN) {
        startcol = start;
      } else {
        str += start;
        len -= start;
      }
    }

    if (argvars[3].v_type != VAR_UNKNOWN) {
      nth = tv_get_number_chk(&argvars[3], &error);
    }
    if (error) {
      goto theend;
    }
  }

  regmatch.regprog = vim_regcomp((char_u *)pat, 1 + 2);
  if (regmatch.regprog != 
# 6180 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 6180 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ) {
    regmatch.rm_ic = p_ic;

    for (;;) {
      if (l != 
# 6184 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6184 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
        if (li == 
# 6185 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 6185 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
          match = 
# 6186 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 6186 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
          break;
        }
        xfree(tofree);
        tofree = expr = str = (char_u *)encode_tv2echo((&(li)->li_tv),
                                                       
# 6191 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 6191 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          );
        if (str == 
# 6192 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 6192 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
          break;
        }
      }

      match = vim_regexec_nl(&regmatch, str, startcol);

      if (match && --nth <= 0) {
        break;
      }
      if (l == 
# 6202 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0) 
# 6202 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   && !match) {
        break;
      }


      if (l != 
# 6207 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6207 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
        li = ((li)->li_next);
        idx++;
      } else {
        startcol = (colnr_T)(regmatch.startp[0]
                             + utfc_ptr2len(regmatch.startp[0]) - str);
        if (startcol > (colnr_T)len || str + startcol <= regmatch.startp[0]) {
          match = 
# 6214 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 6214 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
          break;
        }
      }
    }

    if (match) {
      switch (type) {
      case kSomeMatchStrPos: {
        list_T *const ret_l = rettv->vval.v_list;
        listitem_T *li1 = tv_list_first(ret_l);
        listitem_T *li2 = ((li1)->li_next);
        listitem_T *li3 = ((li2)->li_next);
        listitem_T *li4 = ((li3)->li_next);
        xfree((&(li1)->li_tv)->vval.v_string);

        const size_t rd = (size_t)(regmatch.endp[0] - regmatch.startp[0]);
        (&(li1)->li_tv)->vval.v_string = xmemdupz((const char *)regmatch.startp[0], rd);
        (&(li3)->li_tv)->vval.v_number = (varnumber_T)(
                                                            regmatch.startp[0] - expr);
        (&(li4)->li_tv)->vval.v_number = (varnumber_T)(
                                                            regmatch.endp[0] - expr);
        if (l != 
# 6236 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 6236 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
          (&(li2)->li_tv)->vval.v_number = (varnumber_T)idx;
        }
        break;
      }
      case kSomeMatchList:

        for (int i = 0; i < 10; i++) {
          if (regmatch.endp[i] == 
# 6244 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0)
# 6244 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     ) {
            tv_list_append_string(rettv->vval.v_list, 
# 6245 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     ((void *)0)
# 6245 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         , 0);
          } else {
            tv_list_append_string(rettv->vval.v_list,
                                  (const char *)regmatch.startp[i],
                                  (regmatch.endp[i] - regmatch.startp[i]));
          }
        }
        break;
      case kSomeMatchStr:

        if (l != 
# 6255 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 6255 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
          tv_copy((&(li)->li_tv), rettv);
        } else {
          rettv->vval.v_string = (char_u *)xmemdupz((const char *)regmatch.startp[0],
                                                    (size_t)(regmatch.endp[0] -
                                                             regmatch.startp[0]));
        }
        break;
      case kSomeMatch:
      case kSomeMatchEnd:
        if (l != 
# 6265 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 6265 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
          rettv->vval.v_number = idx;
        } else {
          if (type == kSomeMatch) {
            rettv->vval.v_number =
              (varnumber_T)(regmatch.startp[0] - str);
          } else {
            rettv->vval.v_number =
              (varnumber_T)(regmatch.endp[0] - str);
          }
          rettv->vval.v_number += (varnumber_T)(str - expr);
        }
        break;
      }
    }
    vim_regfree(regmatch.regprog);
  }

theend:
  if (type == kSomeMatchStrPos && l == 
# 6284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      ((void *)0) 
# 6284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           && rettv->vval.v_list != 
# 6284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                    ((void *)0)
# 6284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        ) {

    list_T *const ret_l = rettv->vval.v_list;
    tv_list_item_remove(ret_l, ((tv_list_first(ret_l))->li_next));
  }

  xfree(tofree);
  p_cpo = save_cpo;
}




static void f_match(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  find_some_match(argvars, rettv, kSomeMatch);
}




static void f_matchadd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char grpbuf[NUMBUFLEN];
  char patbuf[NUMBUFLEN];

  const char *const grp = tv_get_string_buf_chk(&argvars[0], grpbuf);

  const char *const pat = tv_get_string_buf_chk(&argvars[1], patbuf);

  int prio = 10;
  int id = -1;
  
# 6316 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 6316 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 6316 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6316 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  const char *conceal_char = 
# 6317 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 6317 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
  win_T *win = curwin;

  rettv->vval.v_number = -1;

  if (grp == 
# 6322 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 6322 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || pat == 
# 6322 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 6322 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ) {
    return;
  }
  if (argvars[2].v_type != VAR_UNKNOWN) {
    prio = tv_get_number_chk(&argvars[2], &error);
    if (argvars[3].v_type != VAR_UNKNOWN) {
      id = tv_get_number_chk(&argvars[3], &error);
      if (argvars[4].v_type != VAR_UNKNOWN
          && matchadd_dict_arg(&argvars[4], &conceal_char, &win) == 0) {
        return;
      }
    }
  }
  if (error) {
    return;
  }
  if (id >= 1 && id <= 3) {
    semsg(
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E798: ID is reserved for \":match\": %" 
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         "l" "d"
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         )
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           , (int64_t)id);
    return;
  }

  rettv->vval.v_number = match_add(win, grp, pat, prio, id, 
# 6343 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           ((void *)0)
# 6343 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               , conceal_char);
}

static void f_matchaddpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;

  char buf[NUMBUFLEN];
  const char *const group = tv_get_string_buf_chk(&argvars[0], buf);
  if (group == 
# 6352 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 6352 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }

  if (argvars[1].v_type != VAR_LIST) {
    semsg(
# 6357 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6357 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listarg)
# 6357 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6357 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "matchaddpos()");
    return;
  }

  list_T *l;
  l = argvars[1].vval.v_list;
  if (l == 
# 6363 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 6363 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    return;
  }

  
# 6367 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 6367 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 6367 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6367 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  int prio = 10;
  int id = -1;
  const char *conceal_char = 
# 6370 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 6370 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
  win_T *win = curwin;

  if (argvars[2].v_type != VAR_UNKNOWN) {
    prio = tv_get_number_chk(&argvars[2], &error);
    if (argvars[3].v_type != VAR_UNKNOWN) {
      id = tv_get_number_chk(&argvars[3], &error);
      if (argvars[4].v_type != VAR_UNKNOWN
          && matchadd_dict_arg(&argvars[4], &conceal_char, &win) == 0) {
        return;
      }
    }
  }
  if (error == 
# 6383 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 6383 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }


  if (id == 1 || id == 2) {
    semsg(
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E798: ID is reserved for \"match\": %" 
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         "l" "d"
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         )
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6389 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          , (int64_t)id);
    return;
  }

  rettv->vval.v_number = match_add(win, group, 
# 6393 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
# 6393 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , prio, id, l, conceal_char);
}




static void f_matcharg(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const int id = tv_get_number(&argvars[0]);

  tv_list_alloc_ret(rettv, (id >= 1 && id <= 3
                            ? 2
                            : 0));

  if (id >= 1 && id <= 3) {
    matchitem_T *const m = get_match(curwin, id);

    if (m != 
# 6410 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6410 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      tv_list_append_string(rettv->vval.v_list,
                            (const char *)syn_id2name(m->hlg_id), -1);
      tv_list_append_string(rettv->vval.v_list, (const char *)m->pattern, -1);
    } else {
      tv_list_append_string(rettv->vval.v_list, 
# 6415 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 6415 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   , 0);
      tv_list_append_string(rettv->vval.v_list, 
# 6416 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 6416 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   , 0);
    }
  }
}




static void f_matchdelete(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *win = get_optional_window(argvars, 1);
  if (win == 
# 6427 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6427 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = match_delete(win,
                                        (int)tv_get_number(&argvars[0]), 
# 6431 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                        1
# 6431 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                            );
  }
}




static void f_matchend(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  find_some_match(argvars, rettv, kSomeMatchEnd);
}




static void f_matchlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  find_some_match(argvars, rettv, kSomeMatchList);
}




static void f_matchstr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  find_some_match(argvars, rettv, kSomeMatchStr);
}


static void f_matchstrpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  find_some_match(argvars, rettv, kSomeMatchStrPos);
}
# 6474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static void max_min(const typval_T *const tv, typval_T *const rettv, const 
# 6474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                          _Bool 
# 6474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                               domax)
  FUNC_ATTR_NONNULL_ALL
{
  
# 6477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 6477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 6477 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6477 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  rettv->vval.v_number = 0;
  varnumber_T n = (domax ? 
# 6480 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          (-9223372036854775807L -1) 
# 6480 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        : 
# 6480 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          (9223372036854775807L)
# 6480 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
  if (tv->v_type == VAR_LIST) {
    if (tv_list_len(tv->vval.v_list) == 0) {
      return;
    }
    do { const list_T *const l_ = (tv->vval.v_list); ; if (l_ != 
# 6485 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 6485 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for (const listitem_T *li = l_->lv_first; li != 
# 6485 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 6485 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; li = li->li_next) { { const varnumber_T i = tv_get_number_chk((&(li)->li_tv), &error); if (error) { return; } if (domax ? i > n : i < n) { n = i; } } } } } while (0)







      ;
  } else if (tv->v_type == VAR_DICT) {
    if (tv_dict_len(tv->vval.v_dict) == 0) {
      return;
    }
    do { hashtab_T *const dihi_ht_ = (&(tv->vval.v_dict)->dv_hashtab); size_t dihi_todo_ = dihi_ht_->ht_used; for (hashitem_T *dihi_ = dihi_ht_->ht_array; dihi_todo_; dihi_++) { if (!((dihi_)->hi_key == 
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0) 
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   || (dihi_)->hi_key == (char_u *)&hash_removed)) { dihi_todo_--; { { { dictitem_T *const di = ((dictitem_T *)((dihi_)->hi_key - 
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   __builtin_offsetof (
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   dictitem_T
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   , 
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   di_key
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   )
# 6498 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   )); { { const varnumber_T i = tv_get_number_chk(&di->di_tv, &error); if (error) { return; } if (domax ? i > n : i < n) { n = i; } } } } } } } } } while (0)







      ;
  } else {
    semsg(
# 6508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listdictarg)
# 6508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , domax ? "max()" : "min()");
    return;
  }
  rettv->vval.v_number = n;
}




static void f_max(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  max_min(argvars, rettv, 1);
}




static void f_min(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  max_min(argvars, rettv, 0);
}




static void f_mkdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int prot = 0755;

  rettv->vval.v_number = 0;
  if (check_secure()) {
    return;
  }

  char buf[NUMBUFLEN];
  const char *const dir = tv_get_string_buf(&argvars[0], buf);
  if (*dir == '\000') {
    return;
  }

  if (*path_tail((char_u *)dir) == '\000') {

    *path_tail_with_sep((char_u *)dir) = '\000';
  }

  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (argvars[2].v_type != VAR_UNKNOWN) {
      prot = tv_get_number_chk(&argvars[2], 
# 6555 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                           ((void *)0)
# 6555 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               );
      if (prot == -1) {
        return;
      }
    }
    if (strcmp(tv_get_string(&argvars[1]), "p") == 0) {
      char *failed_dir;
      int ret = os_mkdir_recurse(dir, prot, &failed_dir);
      if (ret != 0) {
        semsg(
# 6564 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 6564 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_mkdir)
# 6564 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 6564 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , failed_dir, uv_strerror(ret));
        xfree(failed_dir);
        rettv->vval.v_number = 0;
        return;
      } else {
        rettv->vval.v_number = 1;
        return;
      }
    }
  }
  rettv->vval.v_number = vim_mkdir_emsg(dir, prot);
}


static void f_mode(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char *mode = get_mode();



  if (!non_zero_arg(&argvars[0])) {
    mode[1] = '\000';
  }

  rettv->vval.v_string = (char_u *)mode;
  rettv->v_type = VAR_STRING;
}


static void f_msgpackdump(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 6597 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6597 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listarg)
# 6597 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6597 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "msgpackdump()");
    return;
  }
  list_T *const list = argvars[0].vval.v_list;
  msgpack_packer *packer;
  if (argvars[1].v_type != VAR_UNKNOWN
      && strequal(tv_get_string(&argvars[1]), "B")) {
    tv_blob_alloc_ret(rettv);
    packer = msgpack_packer_new(rettv->vval.v_blob, &encode_blob_write);
  } else {
    packer = msgpack_packer_new(tv_list_alloc_ret(rettv, kListLenMayKnow),
                                &encode_list_write);
  }
  const char *const msg = 
# 6610 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         dcgettext (((void *)0), 
# 6610 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         (char *)("msgpackdump() argument, index %i")
# 6610 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         , 5)
# 6610 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              ;

  char msgbuf[sizeof("msgpackdump() argument, index ") * 4 + NUMBUFLEN];
  int idx = 0;
  do { list_T *const l_ = (list); ; if (l_ != 
# 6614 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 6614 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for ( listitem_T *li = l_->lv_first; li != 
# 6614 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 6614 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { vim_snprintf(msgbuf, sizeof(msgbuf), (char *)msg, idx); idx++; if (encode_vim_to_msgpack(packer, (&(li)->li_tv), msgbuf) == 0) { break; } } } } } while (0)





    ;
  msgpack_packer_free(packer);
}

static int msgpackparse_convert_item(const msgpack_object data, const msgpack_unpack_return result,
                                     list_T *const ret_list, const 
# 6625 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  _Bool 
# 6625 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       fail_if_incomplete)
  FUNC_ATTR_NONNULL_ALL
{
  switch (result) {
  case MSGPACK_UNPACK_PARSE_ERROR:
    semsg(
# 6630 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6630 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 6630 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6630 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Failed to parse msgpack string");
    return 0;
  case MSGPACK_UNPACK_NOMEM_ERROR:
    emsg(
# 6633 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 6633 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_outofmem)
# 6633 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 6633 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
    return 0;
  case MSGPACK_UNPACK_CONTINUE:
    if (fail_if_incomplete) {
      semsg(
# 6637 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 6637 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 6637 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 6637 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "Incomplete msgpack string");
      return 0;
    }
    return 2;
  case MSGPACK_UNPACK_SUCCESS: {
    typval_T tv = { .v_type = VAR_UNKNOWN };
    if (msgpack_to_vim(data, &tv) == 0) {
      semsg(
# 6644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 6644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 6644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 6644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "Failed to convert msgpack string");
      return 0;
    }
    tv_list_append_owned_tv(ret_list, tv);
    return 1;
  }
  default:
    abort();
  }
}

static void msgpackparse_unpack_list(const list_T *const list, list_T *const ret_list)
  FUNC_ATTR_NONNULL_ARG(2)
{
  if (tv_list_len(list) == 0) {
    return;
  }
  if ((&(tv_list_first(list))->li_tv)->v_type != VAR_STRING) {
    semsg(
# 6662 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6662 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 6662 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6662 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "List item is not a string");
    return;
  }
  ListReaderState lrstate = encode_init_lrstate(list);
  msgpack_unpacker *const unpacker = msgpack_unpacker_new((1024+1));
  if (unpacker == 
# 6667 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 6667 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
    emsg(
# 6668 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 6668 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_outofmem)
# 6668 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 6668 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
    return;
  }
  msgpack_unpacked unpacked;
  msgpack_unpacked_init(&unpacked);
  do {
    if (!msgpack_unpacker_reserve_buffer(unpacker, (1024+1))) {
      emsg(
# 6675 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 6675 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_outofmem)
# 6675 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 6675 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
      goto end;
    }
    size_t read_bytes;
    const int rlret = encode_read_from_list(&lrstate, msgpack_unpacker_buffer(unpacker), (1024+1),
                                            &read_bytes);
    if (rlret == 0) {
      semsg(
# 6682 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 6682 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 6682 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 6682 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "List item is not a string");
      goto end;
    }
    msgpack_unpacker_buffer_consumed(unpacker, read_bytes);
    if (read_bytes == 0) {
      break;
    }
    while (unpacker->off < unpacker->used) {
      const msgpack_unpack_return result
        = msgpack_unpacker_next(unpacker, &unpacked);
      const int conv_result = msgpackparse_convert_item(unpacked.data, result,
                                                        ret_list, rlret == 1);
      if (conv_result == 2) {
        break;
      } else if (conv_result == 0) {
        goto end;
      }
    }
    if (rlret == 1) {
      break;
    }
  } while (
# 6703 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          1
# 6703 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              );

end:
  msgpack_unpacker_free(unpacker);
  msgpack_unpacked_destroy(&unpacked);
}

static void msgpackparse_unpack_blob(const blob_T *const blob, list_T *const ret_list)
  FUNC_ATTR_NONNULL_ARG(2)
{
  const int len = tv_blob_len(blob);
  if (len == 0) {
    return;
  }
  msgpack_unpacked unpacked;
  msgpack_unpacked_init(&unpacked);
  for (size_t offset = 0; offset < (size_t)len;) {
    const msgpack_unpack_return result
      = msgpack_unpack_next(&unpacked, blob->bv_ga.ga_data, len, &offset);
    if (msgpackparse_convert_item(unpacked.data, result, ret_list, 
# 6722 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  1
# 6722 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                      )
        != 1) {
      break;
    }
  }

  msgpack_unpacked_destroy(&unpacked);
}


static void f_msgpackparse(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  if (argvars[0].v_type != VAR_LIST && argvars[0].v_type != VAR_BLOB) {
    semsg(
# 6736 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6736 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listblobarg)
# 6736 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6736 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "msgpackparse()");
    return;
  }
  list_T *const ret_list = tv_list_alloc_ret(rettv, kListLenMayKnow);
  if (argvars[0].v_type == VAR_LIST) {
    msgpackparse_unpack_list(argvars[0].vval.v_list, ret_list);
  } else {
    msgpackparse_unpack_blob(argvars[0].vval.v_blob, ret_list);
  }
}




static void f_nextnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum;

  for (lnum = tv_get_lnum(argvars);; lnum++) {
    if (lnum < 0 || lnum > curbuf->b_ml.ml_line_count) {
      lnum = 0;
      break;
    }
    if (*skipwhite(ml_get(lnum)) != '\000') {
      break;
    }
  }
  rettv->vval.v_number = lnum;
}




static void f_nr2char(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (!tv_check_num(&argvars[1])) {
      return;
    }
  }

  
# 6777 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 6777 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 6777 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6777 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  const varnumber_T num = tv_get_number_chk(&argvars[0], &error);
  if (error) {
    return;
  }
  if (num < 0) {
    emsg(
# 6783 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 6783 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E5070: Character number must not be less than zero")
# 6783 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 6783 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               );
    return;
  }
  if (num > 0x7fffffff) {
    semsg(
# 6787 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 6787 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E5071: Character number must not be greater than INT_MAX (%i)")
# 6787 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 6787 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                           ,
          0x7fffffff);
    return;
  }

  char buf[21];
  const int len = utf_char2bytes((int)num, (char_u *)buf);

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = xmemdupz(buf, (size_t)len);
}




static void f_or(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = tv_get_number_chk(&argvars[0], 
# 6804 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       ((void *)0)
# 6804 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           )
                         | tv_get_number_chk(&argvars[1], 
# 6805 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 6805 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );
}




static void f_pathshorten(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  const char *const s = tv_get_string_chk(&argvars[0]);
  if (!s) {
    return;
  }
  rettv->vval.v_string = shorten_dir((char_u *)xstrdup(s));
}




static void f_pow(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  float_T fx;
  float_T fy;

  rettv->v_type = VAR_FLOAT;
  if (tv_get_float_chk(argvars, &fx) && tv_get_float_chk(&argvars[1], &fy)) {
    rettv->vval.v_float = pow(fx, fy);
  } else {
    rettv->vval.v_float = 0.0;
  }
}




static void f_prevnonblank(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum = tv_get_lnum(argvars);
  if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count) {
    lnum = 0;
  } else {
    while (lnum >= 1 && *skipwhite(ml_get(lnum)) == '\000') {
      lnum--;
    }
  }
  rettv->vval.v_number = lnum;
}




static void f_printf(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 6859 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 6859 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  {
    int len;
    int saved_did_emsg = did_emsg;


    did_emsg = 
# 6865 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 6865 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
    char buf[NUMBUFLEN];
    const char *fmt = tv_get_string_buf(&argvars[0], buf);
    len = vim_vsnprintf_typval(
# 6868 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 6868 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  , 0, fmt, dummy_ap, argvars + 1);
    if (!did_emsg) {
      char *s = xmalloc(len + 1);
      rettv->vval.v_string = (char_u *)s;
      (void)vim_vsnprintf_typval(s, len + 1, fmt, dummy_ap, argvars + 1);
    }
    did_emsg |= saved_did_emsg;
  }
}


static void f_prompt_setcallback(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf;
  Callback prompt_callback = { .type = kCallbackNone };

  if (check_secure()) {
    return;
  }
  buf = tv_get_buf(&argvars[0], 
# 6887 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 6887 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    );
  if (buf == 
# 6888 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6888 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != '\000') {
    if (!callback_from_typval(&prompt_callback, &argvars[1])) {
      return;
    }
  }

  callback_free(&buf->b_prompt_callback);
  buf->b_prompt_callback = prompt_callback;
}


static void f_prompt_setinterrupt(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf;
  Callback interrupt_callback = { .type = kCallbackNone };

  if (check_secure()) {
    return;
  }
  buf = tv_get_buf(&argvars[0], 
# 6911 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 6911 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    );
  if (buf == 
# 6912 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6912 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  if (argvars[1].v_type != VAR_STRING || *argvars[1].vval.v_string != '\000') {
    if (!callback_from_typval(&interrupt_callback, &argvars[1])) {
      return;
    }
  }

  callback_free(&buf->b_prompt_interrupt);
  buf->b_prompt_interrupt= interrupt_callback;
}


void f_prompt_getprompt(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 6932 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 6932 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  buf_T *const buf = tv_get_buf_from_arg(&argvars[0]);
  if (buf == 
# 6935 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6935 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  if (!bt_prompt(buf)) {
    return;
  }

  rettv->vval.v_string = vim_strsave(buf_prompt_text(buf));
}


static void f_prompt_setprompt(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf;
  const char_u *text;

  if (check_secure()) {
    return;
  }
  buf = tv_get_buf(&argvars[0], 
# 6955 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 6955 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    );
  if (buf == 
# 6956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 6956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  text = (const char_u *)tv_get_string(&argvars[1]);
  xfree(buf->b_prompt_text);
  buf->b_prompt_text = vim_strsave(text);
}


static void f_pum_getpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);
  pum_set_event_info(rettv->vval.v_dict);
}




static void f_pumvisible(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (pum_visible()) {
    rettv->vval.v_number = 1;
  }
}




static void f_pyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  script_host_eval("python", argvars, rettv);
}




static void f_py3eval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  script_host_eval("python3", argvars, rettv);
}


static void f_pyxeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  init_pyxversion();
  if (p_pyx == 2) {
    f_pyeval(argvars, rettv, 
# 7003 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 7003 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                );
  } else {
    f_py3eval(argvars, rettv, 
# 7005 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 7005 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
  }
}




static void f_perleval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  script_host_eval("perl", argvars, rettv);
}


static void f_rubyeval(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  script_host_eval("ruby", argvars, rettv);
}




static void f_range(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  varnumber_T start;
  varnumber_T end;
  varnumber_T stride = 1;
  varnumber_T i;
  
# 7032 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7032 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 7032 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 7032 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  start = tv_get_number_chk(&argvars[0], &error);
  if (argvars[1].v_type == VAR_UNKNOWN) {
    end = start - 1;
    start = 0;
  } else {
    end = tv_get_number_chk(&argvars[1], &error);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      stride = tv_get_number_chk(&argvars[2], &error);
    }
  }

  if (error) {
    return;
  }
  if (stride == 0) {
    emsg(
# 7049 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 7049 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E726: Stride is zero")
# 7049 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 7049 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
  } else if (stride > 0 ? end + 1 < start : end - 1 > start) {
    emsg(
# 7051 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 7051 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E727: Start past end")
# 7051 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 7051 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
  } else {
    tv_list_alloc_ret(rettv, (end - start) / stride);
    for (i = start; stride > 0 ? i <= end : i >= end; i += stride) {
      tv_list_append_number(rettv->vval.v_list, i);
    }
  }
}


static varnumber_T readdir_checkitem(typval_T *expr, const char *name)
{
  typval_T save_val;
  typval_T rettv;
  typval_T argv[2];
  varnumber_T retval = 0;
  
# 7067 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7067 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 7067 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 7067 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  prepare_vimvar(VV_VAL, &save_val);
  set_vim_var_string(VV_VAL, name, -1);
  argv[0].v_type = VAR_STRING;
  argv[0].vval.v_string = (char_u *)name;

  if (eval_expr_typval(expr, argv, 1, &rettv) == 0) {
    goto theend;
  }

  retval = tv_get_number_chk(&rettv, &error);
  if (error) {
    retval = -1;
  }

  tv_clear(&rettv);

theend:
  set_vim_var_string(VV_VAL, 
# 7086 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 7086 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                , 0);
  restore_vimvar(VV_VAL, &save_val);
  return retval;
}


static void f_readdir(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  typval_T *expr;
  const char *path;
  garray_T ga;
  Directory dir;

  tv_list_alloc_ret(rettv, kListLenUnknown);
  path = tv_get_string(&argvars[0]);
  expr = &argvars[1];
  ga_init(&ga, (int)sizeof(char *), 20);

  if (!os_scandir(&dir, path)) {
    smsg(
# 7105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 7105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_notopen)
# 7105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 7105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    , path);
  } else {
    for (;;) {
      
# 7108 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 7108 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          ignore;

      path = os_scandir_next(&dir);
      if (path == 
# 7111 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 7111 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
        break;
      }

      ignore = (path[0] == '.'
                && (path[1] == '\000' || (path[1] == '.' && path[2] == '\000')));
      if (!ignore && expr->v_type != VAR_UNKNOWN) {
        varnumber_T r = readdir_checkitem(expr, path);

        if (r < 0) {
          break;
        }
        if (r == 0) {
          ignore = 
# 7124 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  1
# 7124 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
        }
      }

      if (!ignore) {
        ga_grow(&ga, 1);
        ((char **)ga.ga_data)[ga.ga_len++] = xstrdup(path);
      }
    }

    os_closedir(&dir);
  }

  if (rettv->vval.v_list != 
# 7137 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0) 
# 7137 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                && ga.ga_len > 0) {
    sort_strings((char_u **)ga.ga_data, ga.ga_len);
    for (int i = 0; i < ga.ga_len; i++) {
      path = ((const char **)ga.ga_data)[i];
      tv_list_append_string(rettv->vval.v_list, path, -1);
    }
  }
  ga_clear_strings(&ga);
}




static void f_readfile(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 7152 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7152 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      binary = 
# 7152 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 7152 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  
# 7153 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7153 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      blob = 
# 7153 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 7153 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  FILE *fd;
  char_u buf[((1024+1)/256) * 256];
  int io_size = sizeof(buf);
  int readlen;
  char_u *prev = 
# 7158 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 7158 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  long prevlen = 0;
  long prevsize = 0;
  long maxline = MAXLNUM;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (strcmp(tv_get_string(&argvars[1]), "b") == 0) {
      binary = 
# 7165 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 7165 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
    } else if (strcmp(tv_get_string(&argvars[1]), "B") == 0) {
      blob = 
# 7167 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            1
# 7167 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;
    }
    if (argvars[2].v_type != VAR_UNKNOWN) {
      maxline = tv_get_number(&argvars[2]);
    }
  }



  const char *const fname = tv_get_string(&argvars[0]);

  if (os_isdir((const char_u *)fname)) {
    semsg(
# 7179 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 7179 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_isadir2)
# 7179 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 7179 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , fname);
    return;
  }
  if (*fname == '\000' || (fd = os_fopen(fname, "rb")) == 
# 7182 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 7182 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             ) {
    semsg(
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_notopen)
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , *fname == '\000' ? 
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       dcgettext (((void *)0), 
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       (char *)("<empty>")
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       , 5) 
# 7183 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    : fname);
    return;
  }

  if (blob) {
    tv_blob_alloc_ret(rettv);
    if (!read_blob(fd, rettv->vval.v_blob)) {
      semsg(
# 7190 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 7190 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_notread)
# 7190 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 7190 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , fname);

      tv_blob_free(rettv->vval.v_blob);
      rettv->vval.v_blob = 
# 7193 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 7193 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
    }
    fclose(fd);
    return;
  }

  list_T *const l = tv_list_alloc_ret(rettv, kListLenUnknown);

  while (maxline < 0 || tv_list_len(l) < maxline) {
    readlen = (int)fread(buf, 1, io_size, fd);






    char_u *p;
    char_u *start;
    for (p = buf, start = buf;
         p < buf + readlen || (readlen <= 0 && (prevlen > 0 || binary));
         p++) {
      if (*p == '\n' || readlen <= 0) {
        char_u *s = 
# 7215 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 7215 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
        size_t len = p - start;


        if (readlen > 0 && !binary) {
          while (len > 0 && start[len - 1] == '\r') {
            len--;
          }

          if (len == 0) {
            while (prevlen > 0 && prev[prevlen - 1] == '\r') {
              prevlen--;
            }
          }
        }
        if (prevlen == 0) {
          
# 7231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         ((void) (0))
# 7231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
          s = vim_strnsave(start, len);
        } else {



          s = xrealloc(prev, prevlen + len + 1);
          memcpy(s + prevlen, start, len);
          s[prevlen + len] = '\000';
          prev = 
# 7240 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 7240 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
          prevlen = prevsize = 0;
        }

        tv_list_append_owned_tv(l, (typval_T) {
          .v_type = VAR_STRING,
          .v_lock = VAR_UNLOCKED,
          .vval.v_string = s,
        });

        start = p + 1;
        if (maxline < 0) {
          if (tv_list_len(l) > -maxline) {
            
# 7253 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void) (0))
# 7253 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ;
            tv_list_item_remove(l, tv_list_first(l));
          }
        } else if (tv_list_len(l) >= maxline) {
          
# 7257 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         ((void) (0))
# 7257 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ;
          break;
        }
        if (readlen <= 0) {
          break;
        }
      } else if (*p == '\000') {
        *p = '\n';


      } else if (*p == 0xbf && !binary) {


        char_u back1 = p >= buf + 1 ? p[-1]
                                    : prevlen >= 1 ? prev[prevlen - 1] : '\000';
        char_u back2 = p >= buf + 2 ? p[-2]
                                    : p == buf + 1 && prevlen >= 1 ? prev[prevlen - 1]
                                                                   : prevlen >=
                       2 ? prev[prevlen - 2] : '\000';

        if (back2 == 0xef && back1 == 0xbb) {
          char_u *dest = p - 2;



          if (start == dest) {
            start = p + 1;
          } else {

            int adjust_prevlen = 0;

            if (dest < buf) {
              adjust_prevlen = (int)(buf - dest);

              dest = buf;
            }
            if (readlen > p - buf + 1) {
              memmove(dest, p + 1, readlen - (p - buf) - 1);
            }
            readlen -= 3 - adjust_prevlen;
            prevlen -= adjust_prevlen;
            p = dest - 1;
          }
        }
      }
    }

    if ((maxline >= 0 && tv_list_len(l) >= maxline) || readlen <= 0) {
      break;
    }
    if (start < p) {

      if (p - start + prevlen >= prevsize) {




        if (prevsize == 0) {
          prevsize = (long)(p - start);
        } else {
          long grow50pc = (prevsize * 3) / 2;
          long growmin = (long)((p - start) * 2 + prevlen);
          prevsize = grow50pc > growmin ? grow50pc : growmin;
        }
        prev = xrealloc(prev, prevsize);
      }

      memmove(prev + prevlen, start, p - start);
      prevlen += (long)(p - start);
    }
  }

  xfree(prev);
  fclose(fd);
}


static void f_getreginfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *strregname;
  if (argvars[0].v_type != VAR_UNKNOWN) {
    strregname = tv_get_string_chk(&argvars[0]);
    if (strregname == 
# 7339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 7339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
      return;
    }
  } else {
    strregname = (const char *)get_vim_var_str(VV_REG);
  }

  int regname = (strregname == 
# 7346 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0) 
# 7346 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ? '"' : *strregname);
  if (regname == 0 || regname == '@') {
    regname = '"';
  }

  tv_dict_alloc_ret(rettv);
  dict_T *const dict = rettv->vval.v_dict;

  list_T *const list = get_reg_contents(regname, kGRegExprSrc | kGRegList);
  if (list == 
# 7355 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 7355 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return;
  }
  (void)tv_dict_add_list(dict, ("regcontents"), (sizeof("regcontents") - 1), list);

  char buf[NUMBUFLEN + 2];
  buf[0] = '\000';
  buf[1] = '\000';
  colnr_T reglen = 0;
  switch (get_reg_type(regname, &reglen)) {
  case kMTLineWise:
    buf[0] = 'V';
    break;
  case kMTCharWise:
    buf[0] = 'v';
    break;
  case kMTBlockWise:
    vim_snprintf(buf, sizeof(buf), "%c%d", 22, reglen + 1);
    break;
  case kMTUnknown:
    abort();
  }
  (void)tv_dict_add_str(dict, ("regtype"), (sizeof("regtype") - 1), buf);

  buf[0] = get_register_name(get_unname_register());
  buf[1] = '\000';
  if (regname == '"') {
    (void)tv_dict_add_str(dict, ("points_to"), (sizeof("points_to") - 1), buf);
  } else {
    (void)tv_dict_add_bool(dict, ("isunnamed"), (sizeof("isunnamed") - 1),
                           regname == buf[0] ? kBoolVarTrue : kBoolVarFalse);
  }
}


static void f_reg_executing(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  return_register(reg_executing, rettv);
}


static void f_reg_recording(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  return_register(reg_recording, rettv);
}







static int list2proftime(typval_T *arg, proftime_T *tm) FUNC_ATTR_NONNULL_ALL
{
  if (arg->v_type != VAR_LIST || tv_list_len(arg->vval.v_list) != 2) {
    return 0;
  }

  
# 7413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 7413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 7413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  varnumber_T n1 = tv_list_find_nr(arg->vval.v_list, 0L, &error);
  varnumber_T n2 = tv_list_find_nr(arg->vval.v_list, 1L, &error);
  if (error) {
    return 0;
  }



  union {
    struct { int32_t low, high; } split;
    proftime_T prof;
  } u = { .split.high = n1, .split.low = n2 };

  *tm = u.prof;

  return 1;
}







static void f_reltime(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  proftime_T res;
  proftime_T start;

  if (argvars[0].v_type == VAR_UNKNOWN) {

    res = profile_start();
  } else if (argvars[1].v_type == VAR_UNKNOWN) {
    if (list2proftime(&argvars[0], &res) == 0) {
      return;
    }
    res = profile_end(res);
  } else {

    if (list2proftime(&argvars[0], &start) == 0
        || list2proftime(&argvars[1], &res) == 0) {
      return;
    }
    res = profile_sub(res, start);
  }




  union {
    struct { int32_t low, high; } split;
    proftime_T prof;
  } u = { .prof = res };




  do { _Static_assert(sizeof(u.prof) == sizeof(u) && sizeof(u.split) == sizeof(u), "type punning will produce incorrect results on this platform"); } while (0)
                                                                               ;

  tv_list_alloc_ret(rettv, 2);
  tv_list_append_number(rettv->vval.v_list, u.split.high);
  tv_list_append_number(rettv->vval.v_list, u.split.low);
}


static void f_reltimestr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  proftime_T tm;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 7486 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 7486 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (list2proftime(&argvars[0], &tm) == 1) {
    rettv->vval.v_string = (char_u *)xstrdup(profile_msg(tm));
  }
}




static void f_remove(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  list_T *l;
  listitem_T *item, *item2;
  listitem_T *li;
  long idx;
  long end;
  dict_T *d;
  dictitem_T *di;
  const char *const arg_errmsg = "remove() argument";

  if (argvars[0].v_type == VAR_DICT) {
    if (argvars[2].v_type != VAR_UNKNOWN) {
      semsg(
# 7508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 7508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_toomanyarg)
# 7508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 7508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , "remove()");
    } else if ((d = argvars[0].vval.v_dict) != 
# 7509 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
               
# 7510 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              && !var_check_lock(d->dv_lock, arg_errmsg, (
# 7510 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         (18446744073709551615UL)
# 7510 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         ))) {
      const char *key = tv_get_string_chk(&argvars[1]);
      if (key != 
# 7512 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 7512 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
        di = tv_dict_find(d, key, -1);
        if (di == 
# 7514 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 7514 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
          semsg(
# 7515 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 7515 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_dictkey)
# 7515 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 7515 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , key);
        } else if (!var_check_fixed(di->di_flags, arg_errmsg, (
# 7516 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                             (18446744073709551615UL)
# 7516 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             ))
                   && !var_check_ro(di->di_flags, arg_errmsg, (
# 7517 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                             (18446744073709551615UL)
# 7517 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             ))) {
          *rettv = di->di_tv;
          di->di_tv = ((typval_T) { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED, });
          tv_dict_item_remove(d, di);
          if (tv_dict_is_watched(d)) {
            tv_dict_watcher_notify(d, key, 
# 7522 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 7522 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              , rettv);
          }
        }
      }
    }
  } else if (argvars[0].v_type == VAR_BLOB) {
    blob_T *const b = argvars[0].vval.v_blob;

    if (b != 
# 7530 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 7530 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && var_check_lock(b->bv_lock, arg_errmsg, (
# 7530 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           (18446744073709551615UL)
# 7530 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           ))) {
      return;
    }

    
# 7534 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 7534 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 7534 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 7534 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
    idx = (long)tv_get_number_chk(&argvars[1], &error);

    if (!error) {
      const int len = tv_blob_len(b);

      if (idx < 0) {

        idx = len + idx;
      }
      if (idx < 0 || idx >= len) {
        semsg(
# 7545 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 7545 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_blobidx)
# 7545 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 7545 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , (int64_t)idx);
        return;
      }
      if (argvars[2].v_type == VAR_UNKNOWN) {

        char_u *const p = (char_u *)b->bv_ga.ga_data;
        rettv->vval.v_number = (varnumber_T)(*(p + idx));
        memmove(p + idx, p + idx + 1, (size_t)len - idx - 1);
        b->bv_ga.ga_len--;
      } else {

        end = (long)tv_get_number_chk(&argvars[2], &error);
        if (error) {
          return;
        }
        if (end < 0) {

          end = len + end;
        }
        if (end >= len || idx > end) {
          semsg(
# 7565 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 7565 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_blobidx)
# 7565 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 7565 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , (int64_t)end);
          return;
        }
        blob_T *const blob = tv_blob_alloc();
        blob->bv_ga.ga_len = end - idx + 1;
        ga_grow(&blob->bv_ga, end - idx + 1);

        char_u *const p = (char_u *)b->bv_ga.ga_data;
        memmove((char_u *)blob->bv_ga.ga_data, p + idx,
                (size_t)(end - idx + 1));
        tv_blob_set_ret(rettv, blob);

        if (len - end - 1 > 0) {
          memmove(p + idx, p + end + 1, (size_t)(len - end - 1));
        }
        b->bv_ga.ga_len -= end - idx + 1;
      }
    }
  } else if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 7584 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 7584 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listdictblobarg)
# 7584 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 7584 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             , "remove()");
  } else if (!var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),
                             arg_errmsg, (
# 7586 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        (18446744073709551615UL)
# 7586 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ))) {
    
# 7587 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 7587 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 7587 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 7587 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

    idx = tv_get_number_chk(&argvars[1], &error);
    if (error) {

    } else if ((item = tv_list_find(l, idx)) == 
# 7592 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 7592 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ) {
      semsg(
# 7593 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 7593 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_listidx)
# 7593 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 7593 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , (int64_t)idx);
    } else {
      if (argvars[2].v_type == VAR_UNKNOWN) {

        tv_list_drop_items(l, item, item);
        *rettv = *(&(item)->li_tv);
        xfree(item);
      } else {

        end = tv_get_number_chk(&argvars[2], &error);
        if (error) {

        } else if ((item2 = tv_list_find(l, end)) == 
# 7605 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    ((void *)0)
# 7605 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        ) {
          semsg(
# 7606 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 7606 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_listidx)
# 7606 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 7606 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , (int64_t)end);
        } else {
          int cnt = 0;

          for (li = item; li != 
# 7610 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 7610 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ; li = ((li)->li_next)) {
            cnt++;
            if (li == item2) {
              break;
            }
          }
          if (li == 
# 7616 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 7616 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
            emsg(
# 7617 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                dcgettext (((void *)0), 
# 7617 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                (char *)(e_invrange)
# 7617 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                , 5)
# 7617 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             );
          } else {
            tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),
                               cnt);
          }
        }
      }
    }
  }
}




static void f_rename(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    rettv->vval.v_number = -1;
  } else {
    char buf[NUMBUFLEN];
    rettv->vval.v_number = vim_rename((const char_u *)tv_get_string(&argvars[0]),
                                      (const char_u *)tv_get_string_buf(&argvars[1], buf));
  }
}




static void f_repeat(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  varnumber_T n = tv_get_number(&argvars[1]);
  if (argvars[0].v_type == VAR_LIST) {
    tv_list_alloc_ret(rettv, (n > 0) * n * tv_list_len(argvars[0].vval.v_list));
    while (n-- > 0) {
      tv_list_extend(rettv->vval.v_list, argvars[0].vval.v_list, 
# 7651 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                ((void *)0)
# 7651 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                    );
    }
  } else {
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = 
# 7655 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 7655 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
    if (n <= 0) {
      return;
    }

    const char *const p = tv_get_string(&argvars[0]);

    const size_t slen = strlen(p);
    if (slen == 0) {
      return;
    }
    const size_t len = slen * n;

    if (len / n != slen) {
      return;
    }

    char *const r = xmallocz(len);
    for (varnumber_T i = 0; i < n; i++) {
      memmove(r + i * slen, p, slen);
    }

    rettv->vval.v_string = (char_u *)r;
  }
}




static void f_resolve(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  const char *fname = tv_get_string(&argvars[0]);
# 7698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
  {
    
# 7699 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 7699 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        is_relative_to_current = 
# 7699 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 0
# 7699 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      ;
    
# 7700 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 7700 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        has_trailing_pathsep = 
# 7700 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 7700 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;
    int limit = 100;

    char *p = xstrdup(fname);

    if (p[0] == '.' && (vim_ispathsep(p[1])
                        || (p[1] == '.' && (vim_ispathsep(p[2]))))) {
      is_relative_to_current = 
# 7707 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 7707 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ;
    }

    ptrdiff_t len = (ptrdiff_t)strlen(p);
    if (len > 1 && after_pathsep(p, p + len)) {
      has_trailing_pathsep = 
# 7712 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            1
# 7712 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
      p[len - 1] = '\000';
    }

    char *q = (char *)path_next_component(p);
    char *remain = 
# 7717 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 7717 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
    if (*q != '\000') {


      remain = xstrdup(q - 1);
      q[-1] = '\000';
    }

    char *const buf = xmallocz(4096);

    char *cpy;
    for (;;) {
      for (;;) {
        len = readlink(p, buf, 4096);
        if (len <= 0) {
          break;
        }
        buf[len] = '\000';

        if (limit-- == 0) {
          xfree(p);
          xfree(remain);
          emsg(
# 7739 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              dcgettext (((void *)0), 
# 7739 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              (char *)("E655: Too many symbolic links (cycle?)")
# 7739 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              , 5)
# 7739 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
          rettv->vval.v_string = 
# 7740 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0)
# 7740 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;
          xfree(buf);
          return;
        }



        if (remain == 
# 7747 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0) 
# 7747 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          && has_trailing_pathsep) {
          add_pathsep(buf);
        }



        q = (char *)path_next_component(vim_ispathsep(*buf) ? buf + 1 : buf);
        if (*q != '\000') {
          cpy = remain;
          remain = (remain
                    ? (char *)concat_str((char_u *)q - 1, (char_u *)remain)
                    : xstrdup(q - 1));
          xfree(cpy);
          q[-1] = '\000';
        }

        q = (char *)path_tail((char_u *)p);
        if (q > p && *q == '\000') {

          q[-1] = '\000';
          q = (char *)path_tail((char_u *)p);
        }
        if (q > p && !path_is_absolute((const char_u *)buf)) {


          const size_t p_len = strlen(p);
          const size_t buf_len = strlen(buf);
          p = xrealloc(p, p_len + buf_len + 1);
          memcpy(path_tail((char_u *)p), buf, buf_len + 1);
        } else {
          xfree(p);
          p = xstrdup(buf);
        }
      }

      if (remain == 
# 7782 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 7782 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
        break;
      }


      q = (char *)path_next_component(remain + 1);
      len = q - remain - (*q != '\000');
      const size_t p_len = strlen(p);
      cpy = xmallocz(p_len + len);
      memcpy(cpy, p, p_len + 1);
      xstrlcat(cpy + p_len, remain, len + 1);
      xfree(p);
      p = cpy;


      if (*q != '\000') {
        memmove((remain), (q - 1), strlen((char *)(q - 1)) + 1);
      } else {
        do { void **ptr_ = (void **)&(remain); xfree(*ptr_); *ptr_ = 
# 7800 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       ((void *)0)
# 7800 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       ; (void)(*ptr_); } while (0);
      }
    }



    if (!vim_ispathsep(*p)) {
      if (is_relative_to_current
          && *p != '\000'
          && !(p[0] == '.'
               && (p[1] == '\000'
                   || vim_ispathsep(p[1])
                   || (p[1] == '.'
                       && (p[2] == '\000'
                           || vim_ispathsep(p[2])))))) {

        cpy = (char *)concat_str((const char_u *)"./", (const char_u *)p);
        xfree(p);
        p = cpy;
      } else if (!is_relative_to_current) {

        q = p;
        while (q[0] == '.' && vim_ispathsep(q[1])) {
          q += 2;
        }
        if (q > p) {
          memmove((p), (p + 2), strlen((char *)(p + 2)) + 1);
        }
      }
    }



    if (!has_trailing_pathsep) {
      q = p + strlen(p);
      if (after_pathsep(p, q)) {
        *path_tail_with_sep((char_u *)p) = '\000';
      }
    }

    rettv->vval.v_string = (char_u *)p;
    xfree(buf);
  }






  simplify_filename(rettv->vval.v_string);
}




static void f_reverse(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type == VAR_BLOB) {
    blob_T *const b = argvars[0].vval.v_blob;
    const int len = tv_blob_len(b);

    for (int i = 0; i < len / 2; i++) {
      const char_u tmp = tv_blob_get(b, i);
      tv_blob_set(b, i, tv_blob_get(b, len - i - 1));
      tv_blob_set(b, len - i - 1, tmp);
    }
    tv_blob_set_ret(rettv, b);
  } else if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 7868 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 7868 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listblobarg)
# 7868 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 7868 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "reverse()");
  } else {
    list_T *const l = argvars[0].vval.v_list;
    if (!var_check_lock(tv_list_locked(l), "reverse() argument",
                        (
# 7872 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       (18446744073709551615UL)
# 7872 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ))) {
      tv_list_reverse(l);
      tv_list_set_ret(rettv, l);
    }
  }
}
# 7893 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static int get_search_arg(typval_T *varp, int *flagsp)
{
  int dir = FORWARD;
  int mask;

  if (varp->v_type != VAR_UNKNOWN) {
    char nbuf[NUMBUFLEN];
    const char *flags = tv_get_string_buf_chk(varp, nbuf);
    if (flags == 
# 7901 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 7901 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      return 0;
    }
    while (*flags != '\000') {
      switch (*flags) {
      case 'b':
        dir = BACKWARD; break;
      case 'w':
        p_ws = 
# 7909 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 7909 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ; break;
      case 'W':
        p_ws = 
# 7911 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 7911 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ; break;
      default:
        mask = 0;
        if (flagsp != 
# 7914 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 7914 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ) {
          switch (*flags) {
          case 'c':
            mask = 0x10; break;
          case 'e':
            mask = 0x40; break;
          case 'm':
            mask = 0x04; break;
          case 'n':
            mask = 0x01; break;
          case 'p':
            mask = 0x20; break;
          case 'r':
            mask = 0x02; break;
          case 's':
            mask = 0x08; break;
          case 'z':
            mask = 0x80; break;
          }
        }
        if (mask == 0) {
          semsg(
# 7935 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 7935 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_invarg2)
# 7935 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 7935 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , flags);
          dir = 0;
        } else {
          *flagsp |= mask;
        }
      }
      if (dir == 0) {
        break;
      }
      flags++;
    }
  }
  return dir;
}


static int search_cmn(typval_T *argvars, pos_T *match_pos, int *flagsp)
{
  int flags;
  pos_T pos;
  pos_T save_cursor;
  
# 7956 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 7956 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      save_p_ws = p_ws;
  int dir;
  int retval = 0;
  long lnum_stop = 0;
  proftime_T tm;
  long time_limit = 0;
  int options = 0x400;
  int subpatnum;
  searchit_arg_T sia;

  const char *const pat = tv_get_string(&argvars[0]);
  dir = get_search_arg(&argvars[1], flagsp);
  if (dir == 0) {
    goto theend;
  }
  flags = *flagsp;
  if (flags & 0x10) {
    options |= 0x100;
  }
  if (flags & 0x40) {
    options |= 0x40;
  }
  if (flags & 0x80) {
    options |= 0x1000;
  }


  if (argvars[1].v_type != VAR_UNKNOWN && argvars[2].v_type != VAR_UNKNOWN) {
    lnum_stop = tv_get_number_chk(&argvars[2], 
# 7984 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
# 7984 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
    if (lnum_stop < 0) {
      goto theend;
    }
    if (argvars[3].v_type != VAR_UNKNOWN) {
      time_limit = tv_get_number_chk(&argvars[3], 
# 7989 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 ((void *)0)
# 7989 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     );
      if (time_limit < 0) {
        goto theend;
      }
    }
  }


  tm = profile_setlimit(time_limit);







  if (((flags & (0x02 | 0x04)) != 0)
      || ((flags & 0x01) && (flags & 0x08))) {
    semsg(
# 8007 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8007 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8007 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8007 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , tv_get_string(&argvars[1]));
    goto theend;
  }

  pos = save_cursor = curwin->w_cursor;
  memset(&sia, 0, sizeof(sia));
  sia.sa_stop_lnum = (linenr_T)lnum_stop;
  sia.sa_tm = &tm;
  subpatnum = searchit(curwin, curbuf, &pos, 
# 8015 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
# 8015 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                , dir, (char_u *)pat, 1,
                       options, 0, &sia);
  if (subpatnum != 0) {
    if (flags & 0x20) {
      retval = subpatnum;
    } else {
      retval = pos.lnum;
    }
    if (flags & 0x08) {
      setpcmark();
    }
    curwin->w_cursor = pos;
    if (match_pos != 
# 8027 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 8027 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {

      match_pos->lnum = pos.lnum;
      match_pos->col = pos.col + 1;
    }


    check_cursor();
  }


  if (flags & 0x01) {
    curwin->w_cursor = save_cursor;
  } else {
    curwin->w_set_curswant = 
# 8041 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            1
# 8041 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
  }
theend:
  p_ws = save_p_ws;

  return retval;
}


static void f_rpcnotify(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number < 0) {
    semsg(
# 8060 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8060 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8060 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8060 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Channel id must be a positive integer");
    return;
  }

  if (argvars[1].v_type != VAR_STRING) {
    semsg(
# 8065 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8065 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8065 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8065 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Event type must be a string");
    return;
  }

  Array args = { .size = 0, .capacity = 0, .items = 
# 8069 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0) 
# 8069 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              };

  for (typval_T *tv = argvars + 2; tv->v_type != VAR_UNKNOWN; tv++) {
    (*((((args).size == (args).capacity) ? (((args).capacity = ((args).capacity ? (args).capacity << 1 : 8), (args).items = xrealloc((args).items, sizeof((args).items[0]) * (args).capacity)), 0) : 0), ((args).items + ((args).size++))) = (vim_to_object(tv)));
  }

  if (!rpc_send_event((uint64_t)argvars[0].vval.v_number,
                      tv_get_string(&argvars[1]), args)) {
    semsg(
# 8077 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8077 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8077 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8077 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Channel doesn't exist");
    return;
  }

  rettv->vval.v_number = 1;
}


static void f_rpcrequest(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;
  const int l_provider_call_nesting = provider_call_nesting;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER || argvars[0].vval.v_number <= 0) {
    semsg(
# 8096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Channel id must be a positive integer");
    return;
  }

  if (argvars[1].v_type != VAR_STRING) {
    semsg(
# 8101 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8101 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "Method name must be a string");
    return;
  }

  Array args = { .size = 0, .capacity = 0, .items = 
# 8105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0) 
# 8105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              };

  for (typval_T *tv = argvars + 2; tv->v_type != VAR_UNKNOWN; tv++) {
    (*((((args).size == (args).capacity) ? (((args).capacity = ((args).capacity ? (args).capacity << 1 : 8), (args).items = xrealloc((args).items, sizeof((args).items[0]) * (args).capacity)), 0) : 0), ((args).items + ((args).size++))) = (vim_to_object(tv)));
  }

  sctx_T save_current_sctx;
  uint8_t *save_sourcing_name, *save_autocmd_fname, *save_autocmd_match;
  linenr_T save_sourcing_lnum;
  int save_autocmd_bufnr;
  funccal_entry_T funccal_entry;

  if (l_provider_call_nesting) {


    save_current_sctx = current_sctx;
    save_sourcing_name = sourcing_name;
    save_sourcing_lnum = sourcing_lnum;
    save_autocmd_fname = autocmd_fname;
    save_autocmd_match = autocmd_match;
    save_autocmd_bufnr = autocmd_bufnr;
    save_funccal(&funccal_entry);

    current_sctx = provider_caller_scope.script_ctx;
    sourcing_name = provider_caller_scope.sourcing_name;
    sourcing_lnum = provider_caller_scope.sourcing_lnum;
    autocmd_fname = provider_caller_scope.autocmd_fname;
    autocmd_match = provider_caller_scope.autocmd_match;
    autocmd_bufnr = provider_caller_scope.autocmd_bufnr;
    set_current_funccal((funccall_T *)(provider_caller_scope.funccalp));
  }


  Error err = { .type = kErrorTypeNone, .msg = 
# 8138 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 8138 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             };

  uint64_t chan_id = (uint64_t)argvars[0].vval.v_number;
  const char *method = tv_get_string(&argvars[1]);

  Object result = rpc_send_call(chan_id, method, args, &err);

  if (l_provider_call_nesting) {
    current_sctx = save_current_sctx;
    sourcing_name = save_sourcing_name;
    sourcing_lnum = save_sourcing_lnum;
    autocmd_fname = save_autocmd_fname;
    autocmd_match = save_autocmd_match;
    autocmd_bufnr = save_autocmd_bufnr;
    restore_funccal();
  }

  if (((&err)->type != kErrorTypeNone)) {
    const char *name = 
# 8156 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 8156 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
    Channel *chan = find_channel(chan_id);
    if (chan) {
      name = rpc_client_name(chan);
    }
    msg_ext_set_kind("rpc_error");
    if (name) {
      semsg_multiline("Error invoking '%s' on channel %" 
# 8163 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        "l" "u" 
# 8163 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               " (%s):\n%s",
                      method, chan_id, name, err.msg);
    } else {
      semsg_multiline("Error invoking '%s' on channel %" 
# 8166 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        "l" "u" 
# 8166 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               ":\n%s",
                      method, chan_id, err.msg);
    }

    goto end;
  }

  if (!object_to_vim(result, rettv, &err)) {
    semsg(
# 8174 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8174 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("Error converting the call result: %s")
# 8174 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8174 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , err.msg);
  }

end:
  api_free_object(result);
  api_clear_error(&err);
}


static void f_rpcstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_STRING
      || (argvars[1].v_type != VAR_LIST && argvars[1].v_type != VAR_UNKNOWN)) {

    emsg(
# 8195 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8195 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 8195 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8195 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  list_T *args = 
# 8199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 8199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  int argsl = 0;
  if (argvars[1].v_type == VAR_LIST) {
    args = argvars[1].vval.v_list;
    argsl = tv_list_len(args);

    int i = 0;
    do { const list_T *const l_ = (args); ; if (l_ != 
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for (const listitem_T *arg = l_->lv_first; arg != 
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; arg = arg->li_next) { { if ((&(arg)->li_tv)->v_type != VAR_STRING) { semsg(
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   dcgettext (((void *)0), 
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   (char *)("E5010: List item %d of the second argument is not a string")
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   , 5)
# 8206 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   , i); return; } i++; } } } } while (0)






      ;
  }

  if (argvars[0].vval.v_string == 
# 8216 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0) 
# 8216 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      || argvars[0].vval.v_string[0] == '\000') {
    emsg(
# 8217 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8217 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_api_spawn_failed)
# 8217 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8217 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             );
    return;
  }


  int argvl = argsl + 2;
  char **argv = xmalloc(sizeof(char_u *) * argvl);


  argv[0] = xstrdup((char *)argvars[0].vval.v_string);

  int i = 1;

  if (argsl > 0) {
    do { const list_T *const l_ = (args); ; if (l_ != 
# 8231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 8231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for (const listitem_T *arg = l_->lv_first; arg != 
# 8231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 8231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; arg = arg->li_next) { { argv[i++] = xstrdup(tv_get_string((&(arg)->li_tv))); } } } } while (0)

      ;
  }


  argv[i] = 
# 8237 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 8237 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;

  Channel *chan = channel_job_start(argv, ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0)
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , .buffer = { 0, 0, 0, 1, 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0) 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         }, .buffered = 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         0
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , .type = 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0) 
# 8239 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         }),
                                    ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   , .buffer = { 0, 0, 0, 1, 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0) 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   }, .buffered = 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   0
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   , .type = 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0) 
# 8240 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   }), ((Callback){ .type = kCallbackNone }),
                                    
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   0
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        , 
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          1
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              , 
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                0
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     , 
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       0
# 8241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            ,
                                    kChannelStdinPipe, 
# 8242 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 8242 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          , 0, 0, 
# 8242 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  ((void *)0)
# 8242 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                      ,
                                    &rettv->vval.v_number);
  if (chan) {
    channel_create_event(chan, 
# 8245 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 8245 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
  }
}


static void f_rpcstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_NUMBER) {

    emsg(
# 8261 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8261 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 8261 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8261 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }


  uint64_t id = argvars[0].vval.v_number;
  if (find_job(id, 
# 8267 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 8267 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       )) {
    f_jobstop(argvars, rettv, 
# 8268 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 8268 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
  } else {
    const char *error;
    rettv->vval.v_number = channel_close(argvars[0].vval.v_number,
                                         kChannelPartRpc, &error);
    if (!rettv->vval.v_number) {
      emsg(error);
    }
  }
}


static void f_screenattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int c;

  int row = (int)tv_get_number_chk(&argvars[0], 
# 8284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 8284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ) - 1;
  int col = (int)tv_get_number_chk(&argvars[1], 
# 8285 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               ((void *)0)
# 8285 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ) - 1;
  if (row < 0 || row >= default_grid.Rows
      || col < 0 || col >= default_grid.Columns) {
    c = -1;
  } else {
    ScreenGrid *grid = &default_grid;
    screenchar_adjust_grid(&grid, &row, &col);
    c = grid->attrs[grid->line_offset[row] + col];
  }
  rettv->vval.v_number = c;
}


static void f_screenchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int c;

  int row = tv_get_number_chk(&argvars[0], 
# 8302 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8302 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  int col = tv_get_number_chk(&argvars[1], 
# 8303 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8303 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  if (row < 0 || row >= default_grid.Rows
      || col < 0 || col >= default_grid.Columns) {
    c = -1;
  } else {
    ScreenGrid *grid = &default_grid;
    screenchar_adjust_grid(&grid, &row, &col);
    c = utf_ptr2char(grid->chars[grid->line_offset[row] + col]);
  }
  rettv->vval.v_number = c;
}


static void f_screenchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int row = tv_get_number_chk(&argvars[0], 
# 8318 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8318 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  int col = tv_get_number_chk(&argvars[1], 
# 8319 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8319 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  if (row < 0 || row >= default_grid.Rows
      || col < 0 || col >= default_grid.Columns) {
    tv_list_alloc_ret(rettv, 0);
    return;
  }
  ScreenGrid *grid = &default_grid;
  screenchar_adjust_grid(&grid, &row, &col);
  int pcc[6];
  int c = utfc_ptr2char(grid->chars[grid->line_offset[row] + col], pcc);
  int composing_len = 0;
  while (pcc[composing_len] != 0) {
    composing_len++;
  }
  tv_list_alloc_ret(rettv, composing_len + 1);
  tv_list_append_number(rettv->vval.v_list, c);
  for (int i = 0; i < composing_len; i++) {
    tv_list_append_number(rettv->vval.v_list, pcc[i]);
  }
}




static void f_screencol(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = ui_current_col() + 1;
}


static void f_screenpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  pos_T pos;
  int row = 0;
  int scol = 0, ccol = 0, ecol = 0;

  tv_dict_alloc_ret(rettv);
  dict_T *dict = rettv->vval.v_dict;

  win_T *wp = find_win_by_nr_or_id(&argvars[0]);
  if (wp == 
# 8359 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 8359 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    return;
  }

  pos.lnum = tv_get_number(&argvars[1]);
  pos.col = tv_get_number(&argvars[2]) - 1;
  pos.coladd = 0;
  textpos2screenpos(wp, &pos, &row, &scol, &ccol, &ecol, 
# 8366 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        0
# 8366 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );

  tv_dict_add_nr(dict, ("row"), (sizeof("row") - 1), row);
  tv_dict_add_nr(dict, ("col"), (sizeof("col") - 1), scol);
  tv_dict_add_nr(dict, ("curscol"), (sizeof("curscol") - 1), ccol);
  tv_dict_add_nr(dict, ("endcol"), (sizeof("endcol") - 1), ecol);
}


static void f_screenrow(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = ui_current_row() + 1;
}


static void f_screenstring(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_string = 
# 8383 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 8383 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  rettv->v_type = VAR_STRING;
  int row = tv_get_number_chk(&argvars[0], 
# 8385 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8385 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  int col = tv_get_number_chk(&argvars[1], 
# 8386 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 8386 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              ) - 1;
  if (row < 0 || row >= default_grid.Rows
      || col < 0 || col >= default_grid.Columns) {
    return;
  }
  ScreenGrid *grid = &default_grid;
  screenchar_adjust_grid(&grid, &row, &col);
  rettv->vval.v_string = vim_strsave(grid->chars[grid->line_offset[row] + col]);
}


static void f_search(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int flags = 0;

  rettv->vval.v_number = search_cmn(argvars, 
# 8401 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            ((void *)0)
# 8401 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                , &flags);
}




static void f_searchdecl(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int locally = 1;
  int thisblock = 0;
  
# 8411 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 8411 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 8411 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 8411 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  rettv->vval.v_number = 1;

  const char *const name = tv_get_string_chk(&argvars[0]);
  if (argvars[1].v_type != VAR_UNKNOWN) {
    locally = tv_get_number_chk(&argvars[1], &error) == 0;
    if (!error && argvars[2].v_type != VAR_UNKNOWN) {
      thisblock = tv_get_number_chk(&argvars[2], &error) != 0;
    }
  }
  if (!error && name != 
# 8422 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 8422 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
    rettv->vval.v_number = find_decl((char_u *)name, strlen(name), locally,
                                     thisblock, 0x400) == 0;
  }
}




static int searchpair_cmn(typval_T *argvars, pos_T *match_pos)
{
  
# 8433 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 8433 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      save_p_ws = p_ws;
  int dir;
  int flags = 0;
  int retval = 0;
  long lnum_stop = 0;
  long time_limit = 0;



  char nbuf1[NUMBUFLEN];
  char nbuf2[NUMBUFLEN];
  const char *spat = tv_get_string_chk(&argvars[0]);
  const char *mpat = tv_get_string_buf_chk(&argvars[1], nbuf1);
  const char *epat = tv_get_string_buf_chk(&argvars[2], nbuf2);
  if (spat == 
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  || mpat == 
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0) 
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  || epat == 
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             ((void *)0)
# 8447 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 ) {
    goto theend;
  }


  dir = get_search_arg(&argvars[3], &flags);
  if (dir == 0) {
    goto theend;
  }



  if ((flags & (0x40 | 0x20)) != 0
      || ((flags & 0x01) && (flags & 0x08))) {
    semsg(
# 8461 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8461 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8461 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8461 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , tv_get_string(&argvars[3]));
    goto theend;
  }


  if (flags & 0x02) {
    p_ws = 
# 8467 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          0
# 8467 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ;
  }


  const typval_T *skip;
  if (argvars[3].v_type == VAR_UNKNOWN
      || argvars[4].v_type == VAR_UNKNOWN) {
    skip = 
# 8474 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 8474 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  } else {
    skip = &argvars[4];
    if (skip->v_type != VAR_FUNC
        && skip->v_type != VAR_PARTIAL
        && skip->v_type != VAR_STRING) {
      semsg(
# 8480 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 8480 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 8480 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 8480 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , tv_get_string(&argvars[4]));
      goto theend;
    }
    if (argvars[5].v_type != VAR_UNKNOWN) {
      lnum_stop = tv_get_number_chk(&argvars[5], 
# 8484 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                ((void *)0)
# 8484 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    );
      if (lnum_stop < 0) {
        semsg(
# 8486 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 8486 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 8486 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 8486 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , tv_get_string(&argvars[5]));
        goto theend;
      }
      if (argvars[6].v_type != VAR_UNKNOWN) {
        time_limit = tv_get_number_chk(&argvars[6], 
# 8490 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 8490 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
        if (time_limit < 0) {
          semsg(
# 8492 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               dcgettext (((void *)0), 
# 8492 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               (char *)(e_invarg2)
# 8492 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               , 5)
# 8492 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , tv_get_string(&argvars[6]));
          goto theend;
        }
      }
    }
  }

  retval = do_searchpair(spat, mpat, epat, dir, skip,
                         flags, match_pos, lnum_stop, time_limit);

theend:
  p_ws = save_p_ws;

  return retval;
}




static void f_searchpair(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = searchpair_cmn(argvars, 
# 8513 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                ((void *)0)
# 8513 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    );
}




static void f_searchpairpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  pos_T match_pos;
  int lnum = 0;
  int col = 0;

  tv_list_alloc_ret(rettv, 2);

  if (searchpair_cmn(argvars, &match_pos) > 0) {
    lnum = match_pos.lnum;
    col = match_pos.col;
  }

  tv_list_append_number(rettv->vval.v_list, (varnumber_T)lnum);
  tv_list_append_number(rettv->vval.v_list, (varnumber_T)col);
}
# 8549 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
long do_searchpair(const char *spat, const char *mpat, const char *epat, int dir,
                   const typval_T *skip, int flags, pos_T *match_pos, linenr_T lnum_stop,
                   long time_limit)
  FUNC_ATTR_NONNULL_ARG(1, 2, 3)
{
  char_u *save_cpo;
  char_u *pat, *pat2 = 
# 8555 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 8555 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , *pat3 = 
# 8555 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 8555 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
  long retval = 0;
  pos_T pos;
  pos_T firstpos;
  pos_T foundpos;
  pos_T save_cursor;
  pos_T save_pos;
  int n;
  int nest = 1;
  
# 8564 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 8564 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      use_skip = 
# 8564 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 8564 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  int options = 0x400;
  proftime_T tm;


  save_cpo = p_cpo;
  p_cpo = empty_option;


  tm = profile_setlimit(time_limit);



  const size_t pat2_len = strlen(spat) + strlen(epat) + 17;
  pat2 = xmalloc(pat2_len);
  const size_t pat3_len = strlen(spat) + strlen(mpat) + strlen(epat) + 25;
  pat3 = xmalloc(pat3_len);
  snprintf((char *)pat2, pat2_len, "\\m\\(%s\\m\\)\\|\\(%s\\m\\)", spat, epat);
  if (*mpat == '\000') {
    strcpy((char *)(pat3), (char *)(pat2));
  } else {
    snprintf((char *)pat3, pat3_len,
             "\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)", spat, epat, mpat);
  }
  if (flags & 0x10) {
    options |= 0x100;
  }

  if (skip != 
# 8592 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 8592 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {

    if (skip->v_type == VAR_STRING || skip->v_type == VAR_FUNC) {
      use_skip = skip->vval.v_string != 
# 8595 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       ((void *)0) 
# 8595 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            && *skip->vval.v_string != '\000';
    }
  }

  save_cursor = curwin->w_cursor;
  pos = curwin->w_cursor;
  clearpos(&firstpos);
  clearpos(&foundpos);
  pat = pat3;
  for (;;) {
    searchit_arg_T sia;
    memset(&sia, 0, sizeof(sia));
    sia.sa_stop_lnum = lnum_stop;
    sia.sa_tm = &tm;

    n = searchit(curwin, curbuf, &pos, 
# 8610 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      ((void *)0)
# 8610 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          , dir, pat, 1L,
                 options, 0, &sia);
    if (n == 0 || (firstpos.lnum != 0 && equalpos(pos, firstpos))) {

      break;
    }

    if (firstpos.lnum == 0) {
      firstpos = pos;
    }
    if (equalpos(pos, foundpos)) {



      if (dir == BACKWARD) {
        decl(&pos);
      } else {
        incl(&pos);
      }
    }
    foundpos = pos;


    options &= ~0x100;


    if (use_skip) {
      save_pos = curwin->w_cursor;
      curwin->w_cursor = pos;
      
# 8639 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 8639 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          err = 
# 8639 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 8639 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
      const 
# 8640 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           _Bool 
# 8640 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                r = eval_expr_to_bool(skip, &err);
      curwin->w_cursor = save_pos;
      if (err) {

        curwin->w_cursor = save_cursor;
        retval = -1;
        break;
      }
      if (r) {
        continue;
      }
    }

    if ((dir == BACKWARD && n == 3) || (dir == FORWARD && n == 2)) {


      nest++;
      pat = pat2;
    } else {


      if (--nest == 1) {
        pat = pat3;
      }
    }

    if (nest == 0) {

      if (flags & 0x04) {
        retval++;
      } else {
        retval = pos.lnum;
      }
      if (flags & 0x08) {
        setpcmark();
      }
      curwin->w_cursor = pos;
      if (!(flags & 0x02)) {
        break;
      }
      nest = 1;
    }
  }

  if (match_pos != 
# 8684 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 8684 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {

    match_pos->lnum = curwin->w_cursor.lnum;
    match_pos->col = curwin->w_cursor.col + 1;
  }


  if ((flags & 0x01) || retval == 0) {
    curwin->w_cursor = save_cursor;
  }

  xfree(pat2);
  xfree(pat3);
  if (p_cpo == empty_option) {
    p_cpo = save_cpo;
  } else {

    free_string_option(save_cpo);
  }

  return retval;
}




static void f_searchpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  pos_T match_pos;
  int flags = 0;

  const int n = search_cmn(argvars, &match_pos, &flags);

  tv_list_alloc_ret(rettv, 2 + (!!(flags & 0x20)));

  const int lnum = (n > 0 ? match_pos.lnum : 0);
  const int col = (n > 0 ? match_pos.col : 0);

  tv_list_append_number(rettv->vval.v_list, (varnumber_T)lnum);
  tv_list_append_number(rettv->vval.v_list, (varnumber_T)col);
  if (flags & 0x20) {
    tv_list_append_number(rettv->vval.v_list, (varnumber_T)n);
  }
}


static void f_serverlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  size_t n;
  char **addrs = server_address_list(&n);


  list_T *const l = tv_list_alloc_ret(rettv, n);
  for (size_t i = 0; i < n; i++) {
    tv_list_append_allocated_string(l, addrs[i]);
  }
  xfree(addrs);
}


static void f_serverstart(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 8747 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 8747 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  if (check_secure()) {
    return;
  }

  char *address;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    if (argvars[0].v_type != VAR_STRING) {
      emsg(
# 8757 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 8757 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 8757 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 8757 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    } else {
      address = xstrdup(tv_get_string(argvars));
    }
  } else {
    address = server_address_new();
  }

  int result = server_start(address);
  xfree(address);

  if (result != 0) {
    semsg("Failed to start server: %s",
          result > 0 ? "Unknown system error" : uv_strerror(result));
    return;
  }



  size_t n;
  char **addrs = server_address_list(&n);
  rettv->vval.v_string = (char_u *)addrs[n - 1];

  n--;
  for (size_t i = 0; i < n; i++) {
    xfree(addrs[i]);
  }
  xfree(addrs);
}


static void f_serverstop(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type != VAR_STRING) {
    emsg(
# 8796 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8796 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 8796 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8796 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  rettv->v_type = VAR_NUMBER;
  rettv->vval.v_number = 0;
  if (argvars[0].vval.v_string) {
    
# 8803 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 8803 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        rv = server_stop((char *)argvars[0].vval.v_string);
    rettv->vval.v_number = (rv ? 1 : 0);
  }
}


static void f_setbufline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum;
  buf_T *buf;

  buf = tv_get_buf(&argvars[0], 
# 8814 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 8814 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    );
  if (buf == 
# 8815 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 8815 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = 1;
  } else {
    lnum = tv_get_lnum_buf(&argvars[1], buf);
    set_buffer_lines(buf, lnum, 
# 8819 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 8819 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    , &argvars[2], rettv);
  }
}




static void f_setbufvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()
      || !tv_check_str_or_nr(&argvars[0])) {
    return;
  }
  const char *varname = tv_get_string_chk(&argvars[1]);
  buf_T *const buf = tv_get_buf(&argvars[0], 
# 8833 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 8833 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
  typval_T *varp = &argvars[2];

  if (buf != 
# 8836 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 8836 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 && varname != 
# 8836 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 8836 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ) {
    if (*varname == '&') {
      long numval;
      
# 8839 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 8839 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          error = 
# 8839 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 8839 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
      aco_save_T aco;


      aucmd_prepbuf(&aco, buf);

      varname++;
      numval = tv_get_number_chk(varp, &error);
      char nbuf[NUMBUFLEN];
      const char *const strval = tv_get_string_buf_chk(varp, nbuf);
      if (!error && strval != 
# 8849 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 8849 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ) {
        set_option_value(varname, numval, strval, OPT_LOCAL);
      }


      aucmd_restbuf(&aco);
    } else {
      const size_t varname_len = strlen((char *)(varname));
      char *const bufvarname = xmalloc(varname_len + 3);
      buf_T *const save_curbuf = curbuf;
      curbuf = buf;
      memcpy(bufvarname, "b:", 2);
      memcpy(bufvarname + 2, varname, varname_len + 1);
      set_var(bufvarname, varname_len + 2, varp, 
# 8862 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                1
# 8862 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    );
      xfree(bufvarname);
      curbuf = save_curbuf;
    }
  }
}

static void f_setcharsearch(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *d;
  dictitem_T *di;

  if (argvars[0].v_type != VAR_DICT) {
    emsg(
# 8875 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8875 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 8875 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8875 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }

  if ((d = argvars[0].vval.v_dict) != 
# 8879 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     ((void *)0)
# 8879 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         ) {
    char_u *const csearch = (char_u *)tv_dict_get_string(d, "char", 
# 8880 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                   0
# 8880 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        );
    if (csearch != 
# 8881 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 8881 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
      int pcc[6];
      const int c = utfc_ptr2char(csearch, pcc);
      set_last_csearch(c, csearch, utfc_ptr2len(csearch));
    }

    di = tv_dict_find(d, ("forward"), (sizeof("forward") - 1));
    if (di != 
# 8888 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 8888 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      set_csearch_direction(tv_get_number(&di->di_tv) ? FORWARD : BACKWARD);
    }

    di = tv_dict_find(d, ("until"), (sizeof("until") - 1));
    if (di != 
# 8893 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 8893 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      set_csearch_until(!!tv_get_number(&di->di_tv));
    }
  }
}




static void f_setcmdpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const int pos = (int)tv_get_number(&argvars[0]) - 1;

  if (pos >= 0) {
    rettv->vval.v_number = set_cmdline_pos(pos);
  }
}


static void f_setenv(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char namebuf[NUMBUFLEN];
  char valbuf[NUMBUFLEN];
  const char *name = tv_get_string_buf(&argvars[0], namebuf);

  if (argvars[1].v_type == VAR_SPECIAL
      && argvars[1].vval.v_special == kSpecialVarNull) {
    os_unsetenv(name);
  } else {
    os_setenv(name, tv_get_string_buf(&argvars[1], valbuf), 1);
  }
}


static void f_setfperm(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = 0;

  const char *const fname = tv_get_string_chk(&argvars[0]);
  if (fname == 
# 8932 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 8932 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }

  char modebuf[NUMBUFLEN];
  const char *const mode_str = tv_get_string_buf_chk(&argvars[1], modebuf);
  if (mode_str == 
# 8938 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 8938 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
    return;
  }
  if (strlen(mode_str) != 9) {
    semsg(
# 8942 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 8942 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 8942 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 8942 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , mode_str);
    return;
  }

  int mask = 1;
  int mode = 0;
  for (int i = 8; i >= 0; i--) {
    if (mode_str[i] != '-') {
      mode |= mask;
    }
    mask = mask << 1;
  }
  rettv->vval.v_number = os_setperm(fname, mode) == 1;
}




static void f_setline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  linenr_T lnum = tv_get_lnum(&argvars[0]);
  set_buffer_lines(curbuf, lnum, 
# 8963 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                0
# 8963 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     , &argvars[1], rettv);
}
# 8981 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)
  FUNC_ATTR_NONNULL_ARG(2, 3)
{
  static char *e_invact = "E927: Invalid action: '%s'";
  const char *title = 
# 8985 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 8985 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  int action = ' ';
  static int recursive = 0;
  rettv->vval.v_number = -1;
  dict_T *what = 
# 8989 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 8989 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  typval_T *list_arg = &args[0];
  if (list_arg->v_type != VAR_LIST) {
    emsg(
# 8993 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8993 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 8993 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8993 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  } else if (recursive != 0) {
    emsg(
# 8996 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 8996 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_au_recursive)
# 8996 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 8996 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         );
    return;
  }

  typval_T *action_arg = &args[1];
  if (action_arg->v_type == VAR_UNKNOWN) {

    goto skip_args;
  } else if (action_arg->v_type != VAR_STRING) {
    emsg(
# 9005 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9005 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_stringreq)
# 9005 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9005 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
    return;
  }
  const char *const act = tv_get_string_chk(action_arg);
  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')
      && act[1] == '\000') {
    action = *act;
  } else {
    semsg(
# 9013 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 9013 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invact)
# 9013 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 9013 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    , act);
    return;
  }

  typval_T *const what_arg = &args[2];
  if (what_arg->v_type == VAR_UNKNOWN) {

    goto skip_args;
  } else if (what_arg->v_type == VAR_STRING) {
    title = tv_get_string_chk(what_arg);
    if (!title) {

      return;
    }
  } else if (what_arg->v_type == VAR_DICT && what_arg->vval.v_dict != 
# 9027 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                     ((void *)0)
# 9027 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                         ) {
    what = what_arg->vval.v_dict;
  } else {
    emsg(
# 9030 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9030 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 9030 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9030 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }

skip_args:
  if (!title) {
    title = (wp ? ":setloclist()" : ":setqflist()");
  }

  recursive++;
  list_T *const l = list_arg->vval.v_list;
  if (set_errorlist(wp, l, action, (char_u *)title, what) == 1) {
    rettv->vval.v_number = 0;
  }
  recursive--;
}




static void f_setloclist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *win;

  rettv->vval.v_number = -1;

  win = find_win_by_nr_or_id(&argvars[0]);
  if (win != 
# 9057 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 9057 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    set_qf_ll_list(win, &argvars[1], rettv);
  }
}




static void f_setmatches(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *d;
  list_T *s = 
# 9068 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 9068 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  win_T *win = get_optional_window(argvars, 1);

  rettv->vval.v_number = -1;
  if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 9073 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9073 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 9073 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9073 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }
  if (win == 
# 9076 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 9076 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }

  list_T *const l = argvars[0].vval.v_list;


  int li_idx = 0;
  do { const list_T *const l_ = (l); ; if (l_ != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { if ((&(li)->li_tv)->v_type != VAR_DICT || (d = (&(li)->li_tv)->vval.v_dict) == 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { semsg(
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 dcgettext (((void *)0), 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 (char *)("E474: List item %d is either not a dictionary " "or an empty one")
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 , 5)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , li_idx); return; } if (!(tv_dict_find(d, ("group"), (sizeof("group") - 1)) != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0) 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 && (tv_dict_find(d, ("pattern"), (sizeof("pattern") - 1)) != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0) 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 || tv_dict_find(d, ("pos1"), (sizeof("pos1") - 1)) != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) && tv_dict_find(d, ("priority"), (sizeof("priority") - 1)) != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0) 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 && tv_dict_find(d, ("id"), (sizeof("id") - 1)) != 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 )) { semsg(
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 dcgettext (((void *)0), 
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 (char *)("E474: List item %d is missing one of the required keys")
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 , 5)
# 9084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , li_idx); return; } li_idx++; } } } } while (0)
# 9101 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    ;

  clear_matches(win);
  
# 9104 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9104 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      match_add_failed = 
# 9104 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         0
# 9104 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  do { const list_T *const l_ = (l); ; if (l_ != 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { int i = 0; d = (&(li)->li_tv)->vval.v_dict; dictitem_T *const di = tv_dict_find(d, ("pattern"), (sizeof("pattern") - 1)); if (di == 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { if (s == 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { s = tv_list_alloc(9); } for (i = 1; i < 9; i++) { char buf[30]; snprintf(buf, sizeof(buf), "pos%d", i); dictitem_T *const pos_di = tv_dict_find(d, buf, -1); if (pos_di != 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { if (pos_di->di_tv.v_type != VAR_LIST) { return; } tv_list_append_tv(s, &pos_di->di_tv); tv_list_ref(s); } else { break; } } } char group_buf[NUMBUFLEN]; const char *const group = tv_dict_get_string_buf(d, "group", group_buf); const int priority = (int)tv_dict_get_number(d, "priority"); const int id = (int)tv_dict_get_number(d, "id"); dictitem_T *const conceal_di = tv_dict_find(d, ("conceal"), (sizeof("conceal") - 1)); const char *const conceal = (conceal_di != 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0) 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ? tv_get_string(&conceal_di->di_tv) : 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ); if (i == 0) { if (match_add(win, group, tv_dict_get_string(d, "pattern", 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 0
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ), priority, id, 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , conceal) != id) { match_add_failed = 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 1
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; } } else { if (match_add(win, group, 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , priority, id, s, conceal) != id) { match_add_failed = 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 1
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; } tv_list_unref(s); s = 
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; } } } } } while (0)
# 9161 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
    ;
  if (!match_add_failed) {
    rettv->vval.v_number = 0;
  }
}




static void f_setpos(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  pos_T pos;
  int fnum;
  colnr_T curswant = -1;

  rettv->vval.v_number = -1;
  const char *const name = tv_get_string_chk(argvars);
  if (name != 
# 9178 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 9178 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    if (list2fpos(&argvars[1], &pos, &fnum, &curswant) == 1) {
      if (pos.col != MAXCOL && --pos.col < 0) {
        pos.col = 0;
      }
      if (name[0] == '.' && name[1] == '\000') {

        curwin->w_cursor = pos;
        if (curswant >= 0) {
          curwin->w_curswant = curswant - 1;
          curwin->w_set_curswant = 
# 9188 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  0
# 9188 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ;
        }
        check_cursor();
        rettv->vval.v_number = 0;
      } else if (name[0] == '\'' && name[1] != '\000' && name[2] == '\000') {

        if (setmark_pos((uint8_t)name[1], &pos, fnum) == 1) {
          rettv->vval.v_number = 0;
        }
      } else {
        emsg(
# 9198 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 9198 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)(e_invarg)
# 9198 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 9198 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
      }
    }
  }
}




static void f_setqflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  set_qf_ll_list(
# 9209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 9209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    , argvars, rettv);
}


static int get_yank_type(char_u **const pp, MotionType *const yank_type, long *const block_len)
  FUNC_ATTR_NONNULL_ALL
{
  char_u *stropt = *pp;
  switch (*stropt) {
  case 'v':
  case 'c':
    *yank_type = kMTCharWise;
    break;
  case 'V':
  case 'l':
    *yank_type = kMTLineWise;
    break;
  case 'b':
  case 22:
    *yank_type = kMTBlockWise;
    if (ascii_isdigit(stropt[1])) {
      stropt++;
      *block_len = getdigits_long(&stropt, 
# 9231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          0
# 9231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               , 0) - 1;
      stropt--;
    }
    break;
  default:
    return 0;
  }
  *pp = stropt;
  return 1;
}




static void f_setreg(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int regname;
  
# 9248 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9248 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      append = 
# 9248 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 9248 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  MotionType yank_type;
  long block_len;

  block_len = -1;
  yank_type = kMTUnknown;

  rettv->vval.v_number = 1;

  const char *const strregname = tv_get_string_chk(argvars);
  if (strregname == 
# 9258 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 9258 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
    return;
  }
  regname = (uint8_t)(*strregname);
  if (regname == 0 || regname == '@') {
    regname = '"';
  }

  const typval_T *regcontents = 
# 9266 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 9266 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ;
  int pointreg = 0;
  if (argvars[1].v_type == VAR_DICT) {
    dict_T *const d = argvars[1].vval.v_dict;

    if (tv_dict_len(d) == 0) {

      char_u *lstval[2] = { 
# 9273 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 9273 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               , 
# 9273 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0) 
# 9273 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      };
      write_reg_contents_lst(regname, lstval, 
# 9274 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             0
# 9274 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , kMTUnknown, -1);
      return;
    }

    dictitem_T *const di = tv_dict_find(d, "regcontents", -1);
    if (di != 
# 9279 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 9279 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      regcontents = &di->di_tv;
    }

    const char *stropt = tv_dict_get_string(d, "regtype", 
# 9283 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         0
# 9283 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              );
    if (stropt != 
# 9284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      const int ret = get_yank_type((char_u **)&stropt, &yank_type, &block_len);

      if (ret == 0 || *(++stropt) != '\000') {
        semsg(
# 9288 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 9288 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invargval)
# 9288 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 9288 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , "value");
        return;
      }
    }

    if (regname == '"') {
      stropt = tv_dict_get_string(d, "points_to", 
# 9294 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                 0
# 9294 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      );
      if (stropt != 
# 9295 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 9295 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ) {
        pointreg = *stropt;
        regname = pointreg;
      }
    } else if (tv_dict_get_number(d, "isunnamed")) {
      pointreg = regname;
    }
  } else {
    regcontents = &argvars[1];
  }

  
# 9306 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9306 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      set_unnamed = 
# 9306 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 9306 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  if (argvars[2].v_type != VAR_UNKNOWN) {
    if (yank_type != kMTUnknown) {
      semsg(
# 9309 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 9309 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_toomanyarg)
# 9309 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 9309 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , "setreg");
      return;
    }

    const char *stropt = tv_get_string_chk(&argvars[2]);
    if (stropt == 
# 9314 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9314 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      return;
    }
    for (; *stropt != '\000'; stropt++) {
      switch (*stropt) {
      case 'a':
      case 'A':
        append = 
# 9321 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                1
# 9321 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
        break;
      case 'u':
      case '"':
        set_unnamed = 
# 9325 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     1
# 9325 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
        break;
      default:
        get_yank_type((char_u **)&stropt, &yank_type, &block_len);
      }
    }
  }

  if (regcontents != 
# 9333 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0) 
# 9333 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         && regcontents->v_type == VAR_LIST) {
    list_T *const ll = regcontents->vval.v_list;

    const int len = tv_list_len(ll);



    char **lstval = xmalloc(sizeof(char *) * ((len + 1) * 2));
    const char **curval = (const char **)lstval;
    char **allocval = lstval + len + 2;
    char **curallocval = allocval;

    do { const list_T *const l_ = (ll); ; if (l_ != 
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for (const listitem_T *li = l_->lv_first; li != 
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; li = li->li_next) { { char buf[NUMBUFLEN]; *curval = tv_get_string_buf_chk((&(li)->li_tv), buf); if (*curval == 
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 9345 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { goto free_lstval; } if (*curval == buf) { *curallocval = xstrdup(*curval); *curval = *curallocval; curallocval++; } curval++; } } } } while (0)
# 9359 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      ;
    *curval++ = 
# 9360 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 9360 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

    write_reg_contents_lst(regname, (char_u **)lstval, append, yank_type,
                           block_len);

free_lstval:
    while (curallocval > allocval) {
      xfree(*--curallocval);
    }
    xfree(lstval);
  } else if (regcontents != 
# 9370 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 9370 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ) {
    const char *const strval = tv_get_string_chk(regcontents);
    if (strval == 
# 9372 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9372 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      return;
    }
    write_reg_contents_ex(regname, (const char_u *)strval, strlen((char *)(strval)),
                          append, yank_type, block_len);
  }
  if (pointreg != 0) {
    get_yank_register(pointreg, YREG_YANK);
  }
  rettv->vval.v_number = 0;

  if (set_unnamed) {

    if (op_reg_set_previous(regname)) {
    }
  }
}




static void f_settabvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = 0;

  if (check_secure()) {
    return;
  }

  tabpage_T *const tp = find_tabpage((int)tv_get_number_chk(&argvars[0], 
# 9401 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                        ((void *)0)
# 9401 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                            ));
  const char *const varname = tv_get_string_chk(&argvars[1]);
  typval_T *const varp = &argvars[2];

  if (varname != 
# 9405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 9405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     && tp != 
# 9405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 9405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ) {
    tabpage_T *const save_curtab = curtab;
    goto_tabpage_tp(tp, 
# 9407 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       0
# 9407 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , 
# 9407 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 9407 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );

    const size_t varname_len = strlen(varname);
    char *const tabvarname = xmalloc(varname_len + 3);
    memcpy(tabvarname, "t:", 2);
    memcpy(tabvarname + 2, varname, varname_len + 1);
    set_var(tabvarname, varname_len + 2, varp, 
# 9413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              1
# 9413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  );
    xfree(tabvarname);


    if (valid_tabpage(save_curtab)) {
      goto_tabpage_tp(save_curtab, 
# 9418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  0
# 9418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       , 
# 9418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         0
# 9418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              );
    }
  }
}




static void f_settabwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  setwinvar(argvars, rettv, 1);
}


static void f_settagstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  static char *e_invact2 = "E962: Invalid action: '%s'";
  win_T *wp;
  dict_T *d;
  int action = 'r';

  rettv->vval.v_number = -1;


  wp = find_win_by_nr_or_id(&argvars[0]);
  if (wp == 
# 9443 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 9443 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    return;
  }


  if (argvars[1].v_type != VAR_DICT) {
    emsg(
# 9449 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9449 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 9449 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9449 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }
  d = argvars[1].vval.v_dict;
  if (d == 
# 9453 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 9453 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    return;
  }



  if (argvars[2].v_type == VAR_UNKNOWN) {
    action = 'r';
  } else if (argvars[2].v_type == VAR_STRING) {
    const char *actstr;
    actstr = tv_get_string_chk(&argvars[2]);
    if (actstr == 
# 9464 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9464 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      return;
    }
    if ((*actstr == 'r' || *actstr == 'a' || *actstr == 't')
        && actstr[1] == '\000') {
      action = *actstr;
    } else {
      semsg(
# 9471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 9471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invact2)
# 9471 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 9471 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , actstr);
      return;
    }
  } else {
    emsg(
# 9475 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9475 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_stringreq)
# 9475 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9475 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
    return;
  }

  if (set_tagstack(wp, d, action) == 1) {
    rettv->vval.v_number = 0;
  }
}




static void f_setwinvar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  setwinvar(argvars, rettv, 0);
}


static void f_sha256(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *p = tv_get_string(&argvars[0]);
  const char *hash = sha256_bytes((const uint8_t *)p, strlen(p), 
# 9496 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                ((void *)0)
# 9496 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                    , 0);


  rettv->vval.v_string = (char_u *)xstrdup(hash);
  rettv->v_type = VAR_STRING;
}




static void f_shellescape(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const 
# 9508 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 9508 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            do_special = non_zero_arg(&argvars[1]);

  rettv->vval.v_string = vim_strsave_shellescape((const char_u *)tv_get_string(
                                                                              &argvars[0]), do_special,
                                                 do_special);
  rettv->v_type = VAR_STRING;
}




static void f_shiftwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = 0;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    long col;

    col = (long)tv_get_number_chk(argvars, 
# 9526 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                          ((void *)0)
# 9526 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                              );
    if (col < 0) {
      return;
    }
    rettv->vval.v_number = get_sw_value_col(curbuf, col);
    return;
  }
  rettv->vval.v_number = get_sw_value(curbuf);
}


static void f_sign_define(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *name;

  if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_UNKNOWN) {

    tv_list_alloc_ret(rettv, kListLenMayKnow);

    sign_define_multiple(argvars[0].vval.v_list, rettv->vval.v_list);
    return;
  }


  rettv->vval.v_number = -1;

  name = tv_get_string_chk(&argvars[0]);
  if (name == 
# 9553 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 9553 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return;
  }

  if (argvars[1].v_type != VAR_UNKNOWN && argvars[1].v_type != VAR_DICT) {
    emsg(
# 9558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 9558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }

  rettv->vval.v_number = sign_define_from_dict(name,
                                               argvars[1].v_type ==
                                               VAR_DICT ? argvars[1].vval.v_dict : 
# 9564 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                                  ((void *)0)
# 9564 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                                      );
}


static void f_sign_getdefined(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *name = 
# 9570 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 9570 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;

  tv_list_alloc_ret(rettv, 0);

  if (argvars[0].v_type != VAR_UNKNOWN) {
    name = tv_get_string(&argvars[0]);
  }

  sign_getlist((const char_u *)name, rettv->vval.v_list);
}


static void f_sign_getplaced(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  buf_T *buf = 
# 9584 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 9584 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  dict_T *dict;
  dictitem_T *di;
  linenr_T lnum = 0;
  int sign_id = 0;
  const char *group = 
# 9589 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 9589 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  
# 9590 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9590 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      notanum = 
# 9590 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 9590 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

  tv_list_alloc_ret(rettv, 0);

  if (argvars[0].v_type != VAR_UNKNOWN) {

    buf = get_buf_arg(&argvars[0]);
    if (buf == 
# 9597 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 9597 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      return;
    }

    if (argvars[1].v_type != VAR_UNKNOWN) {
      if (argvars[1].v_type != VAR_DICT
          || ((dict = argvars[1].vval.v_dict) == 
# 9603 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                ((void *)0)
# 9603 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    )) {
        emsg(
# 9604 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 9604 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)(e_dictreq)
# 9604 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 9604 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        );
        return;
      }
      if ((di = tv_dict_find(dict, "lnum", -1)) != 
# 9607 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  ((void *)0)
# 9607 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      ) {

        lnum = (linenr_T)tv_get_number_chk(&di->di_tv, &notanum);
        if (notanum) {
          return;
        }
        (void)lnum;
        lnum = tv_get_lnum(&di->di_tv);
      }
      if ((di = tv_dict_find(dict, "id", -1)) != 
# 9616 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                ((void *)0)
# 9616 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    ) {

        sign_id = (int)tv_get_number_chk(&di->di_tv, &notanum);
        if (notanum) {
          return;
        }
      }
      if ((di = tv_dict_find(dict, "group", -1)) != 
# 9623 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 9623 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ) {
        group = tv_get_string_chk(&di->di_tv);
        if (group == 
# 9625 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 9625 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {
          return;
        }
        if (*group == '\0') {
          group = 
# 9629 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9629 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
        }
      }
    }
  }

  sign_get_placed(buf, lnum, sign_id, (const char_u *)group,
                  rettv->vval.v_list);
}


static void f_sign_jump(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int sign_id;
  char *sign_group = 
# 9643 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 9643 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  buf_T *buf;
  
# 9645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      notanum = 
# 9645 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 9645 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

  rettv->vval.v_number = -1;


  sign_id = (int)tv_get_number_chk(&argvars[0], &notanum);
  if (notanum) {
    return;
  }
  if (sign_id <= 0) {
    emsg(
# 9655 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9655 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 9655 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9655 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }


  const char *sign_group_chk = tv_get_string_chk(&argvars[1]);
  if (sign_group_chk == 
# 9661 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 9661 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ) {
    return;
  }
  if (sign_group_chk[0] == '\0') {
    sign_group = 
# 9665 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 9665 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  } else {
    sign_group = xstrdup(sign_group_chk);
  }


  buf = get_buf_arg(&argvars[2]);
  if (buf == 
# 9672 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 9672 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    goto cleanup;
  }

  rettv->vval.v_number = sign_jump(sign_id, (char_u *)sign_group, buf);

cleanup:
  xfree(sign_group);
}


static void f_sign_place(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *dict = 
# 9685 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 9685 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  rettv->vval.v_number = -1;

  if (argvars[4].v_type != VAR_UNKNOWN
      && (argvars[4].v_type != VAR_DICT
          || ((dict = argvars[4].vval.v_dict) == 
# 9691 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                ((void *)0)
# 9691 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    ))) {
    emsg(
# 9692 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9692 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_dictreq)
# 9692 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9692 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }

  rettv->vval.v_number = sign_place_from_dict(&argvars[0], &argvars[1], &argvars[2], &argvars[3],
                                              dict);
}


static void f_sign_placelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int sign_id;

  tv_list_alloc_ret(rettv, kListLenMayKnow);

  if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 9708 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9708 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 9708 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9708 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }


  do { const list_T *const l_ = (argvars[0].vval.v_list); ; if (l_ != 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { sign_id = -1; if ((&(li)->li_tv)->v_type == VAR_DICT) { sign_id = sign_place_from_dict(
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , (&(li)->li_tv)->vval.v_dict); } else { emsg(
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 dcgettext (((void *)0), 
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 (char *)(e_dictreq)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 , 5)
# 9713 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ); } tv_list_append_number(rettv->vval.v_list, sign_id); } } } } while (0)







    ;
}


static void f_sign_undefine(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *name;

  if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_UNKNOWN) {

    tv_list_alloc_ret(rettv, kListLenMayKnow);

    sign_undefine_multiple(argvars[0].vval.v_list, rettv->vval.v_list);
    return;
  }

  rettv->vval.v_number = -1;

  if (argvars[0].v_type == VAR_UNKNOWN) {

    free_signs();
    rettv->vval.v_number = 0;
  } else {

    name = tv_get_string_chk(&argvars[0]);
    if (name == 
# 9746 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 9746 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
      return;
    }

    if (sign_undefine_by_name((const char_u *)name) == 1) {
      rettv->vval.v_number = 0;
    }
  }
}


static void f_sign_unplace(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *dict = 
# 9759 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 9759 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;

  rettv->vval.v_number = -1;

  if (argvars[0].v_type != VAR_STRING) {
    emsg(
# 9764 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9764 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 9764 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9764 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }

  if (argvars[1].v_type != VAR_UNKNOWN) {
    if (argvars[1].v_type != VAR_DICT) {
      emsg(
# 9770 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 9770 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_dictreq)
# 9770 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 9770 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
      return;
    }
    dict = argvars[1].vval.v_dict;
  }

  rettv->vval.v_number = sign_unplace_from_dict(&argvars[0], dict);
}


static void f_sign_unplacelist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int retval;

  tv_list_alloc_ret(rettv, kListLenMayKnow);

  if (argvars[0].v_type != VAR_LIST) {
    emsg(
# 9787 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9787 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_listreq)
# 9787 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9787 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    );
    return;
  }

  do { const list_T *const l_ = (argvars[0].vval.v_list); ; if (l_ != 
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ) { for (const listitem_T *li = l_->lv_first; li != 
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ; li = li->li_next) { { retval = -1; if ((&(li)->li_tv)->v_type == VAR_DICT) { retval = sign_unplace_from_dict(
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void *)0)
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 , (&(li)->li_tv)->vval.v_dict); } else { emsg(
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 dcgettext (((void *)0), 
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 (char *)(e_dictreq)
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 , 5)
# 9791 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
 ); } tv_list_append_number(rettv->vval.v_list, retval); } } } } while (0)







    ;
}




static void f_simplify(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const p = tv_get_string(&argvars[0]);
  rettv->vval.v_string = (char_u *)xstrdup(p);
  simplify_filename(rettv->vval.v_string);
  rettv->v_type = VAR_STRING;
}


static void f_sockconnect(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_STRING || argvars[1].v_type != VAR_STRING) {
    emsg(
# 9817 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 9817 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 9817 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 9817 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }
  if (argvars[2].v_type != VAR_DICT && argvars[2].v_type != VAR_UNKNOWN) {

    semsg(
# 9822 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 9822 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 9822 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 9822 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected dictionary");
    return;
  }

  const char *mode = tv_get_string(&argvars[0]);
  const char *address = tv_get_string(&argvars[1]);

  
# 9829 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9829 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      tcp;
  if (strcmp(mode, "tcp") == 0) {
    tcp = 
# 9831 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         1
# 9831 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             ;
  } else if (strcmp(mode, "pipe") == 0) {
    tcp = 
# 9833 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         0
# 9833 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ;
  } else {
    semsg(
# 9835 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 9835 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 9835 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 9835 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "invalid mode");
    return;
  }

  
# 9839 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9839 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      rpc = 
# 9839 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 9839 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  CallbackReader on_data = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , .buffer = { 0, 0, 0, 1, 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0) 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          }, .buffered = 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          0
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , .type = 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0) 
# 9840 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          });
  if (argvars[2].v_type == VAR_DICT) {
    dict_T *opts = argvars[2].vval.v_dict;
    rpc = tv_dict_get_number(opts, "rpc") != 0;

    if (!tv_dict_get_callback(opts, ("on_data"), (sizeof("on_data") - 1), &on_data.cb)) {
      return;
    }
    on_data.buffered = tv_dict_get_number(opts, "data_buffered");
    if (on_data.buffered && on_data.cb.type == kCallbackNone) {
      on_data.self = opts;
    }
  }

  const char *error = 
# 9854 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 9854 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  uint64_t id = channel_connect(tcp, address, rpc, on_data, 50, &error);

  if (error) {
    semsg(
# 9858 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 9858 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("connection failed: %s")
# 9858 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 9858 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   , error);
  }

  rettv->vval.v_number = (varnumber_T)id;
  rettv->v_type = VAR_NUMBER;
}


typedef struct {
  int item_compare_ic;
  
# 9868 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9868 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      item_compare_lc;
  
# 9869 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9869 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      item_compare_numeric;
  
# 9870 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9870 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      item_compare_numbers;
  
# 9871 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9871 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      item_compare_float;
  const char *item_compare_func;
  partial_T *item_compare_partial;
  dict_T *item_compare_selfdict;
  
# 9875 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 9875 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      item_compare_func_err;
} sortinfo_T;
static sortinfo_T *sortinfo = 
# 9877 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             ((void *)0)
# 9877 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 ;






static int item_compare(const void *s1, const void *s2, 
# 9884 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       _Bool 
# 9884 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            keep_zero)
{
  ListSortItem *const si1 = (ListSortItem *)s1;
  ListSortItem *const si2 = (ListSortItem *)s2;

  typval_T *const tv1 = (&(si1->item)->li_tv);
  typval_T *const tv2 = (&(si2->item)->li_tv);

  int res;

  if (sortinfo->item_compare_numbers) {
    const varnumber_T v1 = tv_get_number(tv1);
    const varnumber_T v2 = tv_get_number(tv2);

    res = v1 == v2 ? 0 : v1 > v2 ? 1 : -1;
    goto item_compare_end;
  }

  if (sortinfo->item_compare_float) {
    const float_T v1 = tv_get_float(tv1);
    const float_T v2 = tv_get_float(tv2);

    res = v1 == v2 ? 0 : v1 > v2 ? 1 : -1;
    goto item_compare_end;
  }

  char *tofree1 = 
# 9910 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9910 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  char *tofree2 = 
# 9911 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 9911 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  char *p1;
  char *p2;




  if (tv1->v_type == VAR_STRING) {
    if (tv2->v_type != VAR_STRING || sortinfo->item_compare_numeric) {
      p1 = "'";
    } else {
      p1 = (char *)tv1->vval.v_string;
    }
  } else {
    tofree1 = p1 = encode_tv2string(tv1, 
# 9925 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0)
# 9925 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            );
  }
  if (tv2->v_type == VAR_STRING) {
    if (tv1->v_type != VAR_STRING || sortinfo->item_compare_numeric) {
      p2 = "'";
    } else {
      p2 = (char *)tv2->vval.v_string;
    }
  } else {
    tofree2 = p2 = encode_tv2string(tv2, 
# 9934 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0)
# 9934 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            );
  }
  if (p1 == 
# 9936 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 9936 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    p1 = "";
  }
  if (p2 == 
# 9939 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 9939 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    p2 = "";
  }
  if (!sortinfo->item_compare_numeric) {
    if (sortinfo->item_compare_lc) {
      res = strcoll(p1, p2);
    } else {
      res = sortinfo->item_compare_ic ? strcasecmp((char *)(p1), (char *)(p2)): strcmp((char *)(p1), (char *)(p2));
    }
  } else {
    double n1, n2;
    n1 = strtod(p1, &p1);
    n2 = strtod(p2, &p2);
    res = n1 == n2 ? 0 : n1 > n2 ? 1 : -1;
  }

  xfree(tofree1);
  xfree(tofree2);

item_compare_end:


  if (res == 0 && !keep_zero) {


    res = si1->idx > si2->idx ? 1 : -1;
  }
  return res;
}

static int item_compare_keeping_zero(const void *s1, const void *s2)
{
  return item_compare(s1, s2, 
# 9971 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             1
# 9971 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                 );
}

static int item_compare_not_keeping_zero(const void *s1, const void *s2)
{
  return item_compare(s1, s2, 
# 9976 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             0
# 9976 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
}

static int item_compare2(const void *s1, const void *s2, 
# 9979 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                        _Bool 
# 9979 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             keep_zero)
{
  ListSortItem *si1, *si2;
  int res;
  typval_T rettv;
  typval_T argv[3];
  const char *func_name;
  partial_T *partial = sortinfo->item_compare_partial;


  if (sortinfo->item_compare_func_err) {
    return 0;
  }

  si1 = (ListSortItem *)s1;
  si2 = (ListSortItem *)s2;

  if (partial == 
# 9996 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 9996 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
    func_name = sortinfo->item_compare_func;
  } else {
    func_name = (const char *)partial_name(partial);
  }



  tv_copy((&(si1->item)->li_tv), &argv[0]);
  tv_copy((&(si2->item)->li_tv), &argv[1]);

  rettv.v_type = VAR_UNKNOWN;
  funcexe_T funcexe = (funcexe_T) { .argv_func = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , .firstline = 0, .lastline = 0, .doesrange = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , .evaluate = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     0
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , .partial = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , .selfdict = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , .basetv = 
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10008 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , };
  funcexe.evaluate = 
# 10009 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    1
# 10009 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  funcexe.partial = partial;
  funcexe.selfdict = sortinfo->item_compare_selfdict;
  res = call_func((const char_u *)func_name, -1, &rettv, 2, argv, &funcexe);
  tv_clear(&argv[0]);
  tv_clear(&argv[1]);

  if (res == 0) {
    res = 999;
  } else {
    res = tv_get_number_chk(&rettv, &sortinfo->item_compare_func_err);
  }
  if (sortinfo->item_compare_func_err) {
    res = 999;
  }
  tv_clear(&rettv);



  if (res == 0 && !keep_zero) {


    res = si1->idx > si2->idx ? 1 : -1;
  }

  return res;
}

static int item_compare2_keeping_zero(const void *s1, const void *s2)
{
  return item_compare2(s1, s2, 
# 10039 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 10039 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
}

static int item_compare2_not_keeping_zero(const void *s1, const void *s2)
{
  return item_compare2(s1, s2, 
# 10044 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 10044 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );
}




static void do_sort_uniq(typval_T *argvars, typval_T *rettv, 
# 10050 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                            _Bool 
# 10050 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                 sort)
{
  ListSortItem *ptrs;
  long len;
  long i;



  sortinfo_T info;
  sortinfo_T *old_sortinfo = sortinfo;
  sortinfo = &info;

  const char *const arg_errmsg = (sort
                                  ? "sort() argument"
                                  : "uniq() argument");

  if (argvars[0].v_type != VAR_LIST) {
    semsg(
# 10067 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 10067 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_listarg)
# 10067 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 10067 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , sort ? "sort()" : "uniq()");
  } else {
    list_T *const l = argvars[0].vval.v_list;
    if (var_check_lock(tv_list_locked(l), arg_errmsg, (
# 10070 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     (18446744073709551615UL)
# 10070 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     ))) {
      goto theend;
    }
    tv_list_set_ret(rettv, l);

    len = tv_list_len(l);
    if (len <= 1) {
      goto theend;
    }

    info.item_compare_ic = 
# 10080 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          0
# 10080 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ;
    info.item_compare_lc = 
# 10081 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          0
# 10081 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               ;
    info.item_compare_numeric = 
# 10082 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 10082 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;
    info.item_compare_numbers = 
# 10083 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               0
# 10083 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;
    info.item_compare_float = 
# 10084 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                             0
# 10084 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ;
    info.item_compare_func = 
# 10085 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 10085 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                ;
    info.item_compare_partial = 
# 10086 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                               ((void *)0)
# 10086 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ;
    info.item_compare_selfdict = 
# 10087 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                ((void *)0)
# 10087 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;

    if (argvars[1].v_type != VAR_UNKNOWN) {

      if (argvars[1].v_type == VAR_FUNC) {
        info.item_compare_func = (const char *)argvars[1].vval.v_string;
      } else if (argvars[1].v_type == VAR_PARTIAL) {
        info.item_compare_partial = argvars[1].vval.v_partial;
      } else {
        
# 10096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 10096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            error = 
# 10096 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    0
# 10096 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;

        i = tv_get_number_chk(&argvars[1], &error);
        if (error) {
          goto theend;
        }
        if (i == 1) {
          info.item_compare_ic = 
# 10103 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                1
# 10103 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                    ;
        } else if (argvars[1].v_type != VAR_NUMBER) {
          info.item_compare_func = tv_get_string(&argvars[1]);
        } else if (i != 0) {
          emsg(
# 10107 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              dcgettext (((void *)0), 
# 10107 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              (char *)(e_invarg)
# 10107 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              , 5)
# 10107 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         );
          goto theend;
        }
        if (info.item_compare_func != 
# 10110 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     ((void *)0)
# 10110 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         ) {
          if (*info.item_compare_func == '\000') {

            info.item_compare_func = 
# 10113 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10113 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
          } else if (strcmp(info.item_compare_func, "n") == 0) {
            info.item_compare_func = 
# 10115 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10115 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
            info.item_compare_numeric = 
# 10116 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       1
# 10116 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ;
          } else if (strcmp(info.item_compare_func, "N") == 0) {
            info.item_compare_func = 
# 10118 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10118 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
            info.item_compare_numbers = 
# 10119 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       1
# 10119 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           ;
          } else if (strcmp(info.item_compare_func, "f") == 0) {
            info.item_compare_func = 
# 10121 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10121 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
            info.item_compare_float = 
# 10122 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     1
# 10122 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         ;
          } else if (strcmp(info.item_compare_func, "i") == 0) {
            info.item_compare_func = 
# 10124 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10124 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
            info.item_compare_ic = 
# 10125 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  1
# 10125 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      ;
          } else if (strcmp(info.item_compare_func, "l") == 0) {
            info.item_compare_func = 
# 10127 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                    ((void *)0)
# 10127 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                        ;
            info.item_compare_lc = 
# 10128 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  1
# 10128 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      ;
          }
        }
      }

      if (argvars[2].v_type != VAR_UNKNOWN) {

        if (argvars[2].v_type != VAR_DICT) {
          emsg(
# 10136 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              dcgettext (((void *)0), 
# 10136 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              (char *)(e_dictreq)
# 10136 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              , 5)
# 10136 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          );
          goto theend;
        }
        info.item_compare_selfdict = argvars[2].vval.v_dict;
      }
    }


    ptrs = xmalloc((size_t)(len * sizeof(ListSortItem)));

    if (sort) {
      info.item_compare_func_err = 
# 10147 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  0
# 10147 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ;
      tv_list_item_sort(l, ptrs,
                        ((info.item_compare_func == 
# 10149 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
                          
# 10150 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         && info.item_compare_partial == 
# 10150 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 10150 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             )
                         ? item_compare_not_keeping_zero
                         : item_compare2_not_keeping_zero),
                        &info.item_compare_func_err);
      if (info.item_compare_func_err) {
        emsg(
# 10155 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            dcgettext (((void *)0), 
# 10155 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            (char *)("E702: Sort compare function failed")
# 10155 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            , 5)
# 10155 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   );
      }
    } else {
      ListSorter item_compare_func_ptr;


      info.item_compare_func_err = 
# 10161 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  0
# 10161 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ;
      if (info.item_compare_func != 
# 10162 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
          
# 10163 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         || info.item_compare_partial != 
# 10163 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0)
# 10163 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             ) {
        item_compare_func_ptr = item_compare2_keeping_zero;
      } else {
        item_compare_func_ptr = item_compare_keeping_zero;
      }

      int idx = 0;
      for (listitem_T *li = ((tv_list_first(l))->li_next)
           ; li != 
# 10171 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 10171 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;) {
        listitem_T *const prev_li = ((li)->li_prev);
        if (item_compare_func_ptr(&prev_li, &li) == 0) {
          if (info.item_compare_func_err) {
            emsg(
# 10175 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                dcgettext (((void *)0), 
# 10175 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                (char *)("E882: Uniq compare function failed")
# 10175 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                , 5)
# 10175 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       );
            break;
          }
          li = tv_list_item_remove(l, li);
        } else {
          idx++;
          li = ((li)->li_next);
        }
      }
    }

    xfree(ptrs);
  }

theend:
  sortinfo = old_sortinfo;
}


static void f_sort(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  do_sort_uniq(argvars, rettv, 
# 10196 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 10196 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
}


static void f_stdioopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_DICT) {
    emsg(
# 10203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 10203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 10203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 10203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
    return;
  }


  
# 10208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      rpc = 
# 10208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 10208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;
  CallbackReader on_stdin = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , .buffer = { 0, 0, 0, 1, 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0) 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           }, .buffered = 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           0
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           , .type = 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0) 
# 10209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           });
  dict_T *opts = argvars[0].vval.v_dict;
  rpc = tv_dict_get_number(opts, "rpc") != 0;

  if (!tv_dict_get_callback(opts, ("on_stdin"), (sizeof("on_stdin") - 1), &on_stdin.cb)) {
    return;
  }
  on_stdin.buffered = tv_dict_get_number(opts, "stdin_buffered");
  if (on_stdin.buffered && on_stdin.cb.type == kCallbackNone) {
    on_stdin.self = opts;
  }

  const char *error;
  uint64_t id = channel_from_stdio(rpc, on_stdin, &error);
  if (!id) {
    semsg(e_stdiochan2, error);
  }


  rettv->vval.v_number = (varnumber_T)id;
  rettv->v_type = VAR_NUMBER;
}


static void f_uniq(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  do_sort_uniq(argvars, rettv, 
# 10235 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 10235 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   );
}


static void f_reltimefloat(typval_T *argvars, typval_T *rettv, FunPtr fptr)
  FUNC_ATTR_NONNULL_ALL
{
  proftime_T tm;

  rettv->v_type = VAR_FLOAT;
  rettv->vval.v_float = 0;
  if (list2proftime(&argvars[0], &tm) == 1) {
    rettv->vval.v_float = (float_T)profile_signed(tm) / 1000000000.0;
  }
}




static void f_soundfold(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  const char *const s = tv_get_string(&argvars[0]);
  rettv->vval.v_string = (char_u *)eval_soundfold(s);
}




static void f_spellbadword(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *word = "";
  hlf_T attr = HLF_COUNT;
  size_t len = 0;
  const int wo_spell_save = curwin->w_onebuf_opt.wo_spell;

  if (!curwin->w_onebuf_opt.wo_spell) {
    did_set_spelllang(curwin);
    curwin->w_onebuf_opt.wo_spell = 
# 10273 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       1
# 10273 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  }

  if (*curwin->w_s->b_p_spl == '\000') {
    emsg(
# 10277 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 10277 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_no_spell)
# 10277 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 10277 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
    curwin->w_onebuf_opt.wo_spell = wo_spell_save;
    return;
  }

  if (argvars[0].v_type == VAR_UNKNOWN) {

    len = spell_move_to(curwin, FORWARD, 
# 10284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        1
# 10284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            , 
# 10284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              1
# 10284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , &attr);
    if (len != 0) {
      word = (char *)get_cursor_pos_ptr();
      curwin->w_set_curswant = 
# 10287 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              1
# 10287 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  ;
    }
  } else if (*curbuf->b_s.b_p_spl != '\000') {
    const char *str = tv_get_string_chk(&argvars[0]);
    int capcol = -1;

    if (str != 
# 10293 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 10293 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {

      while (*str != '\000') {
        len = spell_check(curwin, (char_u *)str, &attr, &capcol, 
# 10296 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                0
# 10296 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                     );
        if (attr != HLF_COUNT) {
          word = str;
          break;
        }
        str += len;
        capcol -= len;
        len = 0;
      }
    }
  }
  curwin->w_onebuf_opt.wo_spell = wo_spell_save;

  
# 10309 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 ((void) (0))
# 10309 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  tv_list_alloc_ret(rettv, 2);
  tv_list_append_string(rettv->vval.v_list, word, len);
  tv_list_append_string(rettv->vval.v_list,
                        (attr == HLF_SPB ? "bad"
                                         : attr == HLF_SPR ? "rare"
                                                           : attr == HLF_SPL ? "local"
                                                                             : attr ==
                         HLF_SPC ? "caps"
                                 :
                         
# 10319 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 10319 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ), -1);
}




static void f_spellsuggest(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 10327 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10327 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      typeerr = 
# 10327 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 10327 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  int maxcount;
  garray_T ga = { 0, 0, 0, 1, 
# 10329 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 10329 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               };
  
# 10330 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10330 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      need_capital = 
# 10330 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     0
# 10330 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  const int wo_spell_save = curwin->w_onebuf_opt.wo_spell;

  if (!curwin->w_onebuf_opt.wo_spell) {
    did_set_spelllang(curwin);
    curwin->w_onebuf_opt.wo_spell = 
# 10335 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       1
# 10335 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
  }

  if (*curwin->w_s->b_p_spl == '\000') {
    emsg(
# 10339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 10339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_no_spell)
# 10339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 10339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
    curwin->w_onebuf_opt.wo_spell = wo_spell_save;
    return;
  }

  if (*curwin->w_s->b_p_spl != '\000') {
    const char *const str = tv_get_string(&argvars[0]);
    if (argvars[1].v_type != VAR_UNKNOWN) {
      maxcount = tv_get_number_chk(&argvars[1], &typeerr);
      if (maxcount <= 0) {
        goto f_spellsuggest_return;
      }
      if (argvars[2].v_type != VAR_UNKNOWN) {
        need_capital = tv_get_number_chk(&argvars[2], &typeerr);
        if (typeerr) {
          goto f_spellsuggest_return;
        }
      }
    } else {
      maxcount = 25;
    }

    spell_suggest_list(&ga, (char_u *)str, maxcount, need_capital, 
# 10361 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                  0
# 10361 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       );
  }

f_spellsuggest_return:
  tv_list_alloc_ret(rettv, (ptrdiff_t)ga.ga_len);
  for (int i = 0; i < ga.ga_len; i++) {
    char *const p = ((char **)ga.ga_data)[i];
    tv_list_append_allocated_string(rettv->vval.v_list, p);
  }
  ga_clear(&ga);
  curwin->w_onebuf_opt.wo_spell = wo_spell_save;
}

static void f_split(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *save_cpo;
  int match;
  colnr_T col = 0;
  
# 10379 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10379 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      keepempty = 
# 10379 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 10379 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  
# 10380 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10380 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      typeerr = 
# 10380 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 10380 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;


  save_cpo = p_cpo;
  p_cpo = (char_u *)"";

  const char *str = tv_get_string(&argvars[0]);
  const char *pat = 
# 10387 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 10387 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  char patbuf[NUMBUFLEN];
  if (argvars[1].v_type != VAR_UNKNOWN) {
    pat = tv_get_string_buf_chk(&argvars[1], patbuf);
    if (pat == 
# 10391 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 10391 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      typeerr = 
# 10392 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               1
# 10392 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
    }
    if (argvars[2].v_type != VAR_UNKNOWN) {
      keepempty = (
# 10395 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  _Bool
# 10395 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      )tv_get_number_chk(&argvars[2], &typeerr);
    }
  }
  if (pat == 
# 10398 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 10398 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || *pat == '\000') {
    pat = "[\\x01- ]\\+";
  }

  tv_list_alloc_ret(rettv, kListLenMayKnow);

  if (typeerr) {
    goto theend;
  }

  regmatch_T regmatch = {
    .regprog = vim_regcomp((char_u *)pat, 1 + 2),
    .startp = { 
# 10410 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 10410 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    },
    .endp = { 
# 10411 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 10411 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  },
    .rm_ic = 
# 10412 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            0
# 10412 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ,
  };
  if (regmatch.regprog != 
# 10414 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 10414 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ) {
    while (*str != '\000' || keepempty) {
      if (*str == '\000') {
        match = 
# 10417 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 10417 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
      } else {
        match = vim_regexec_nl(&regmatch, (char_u *)str, col);
      }
      const char *end;
      if (match) {
        end = (const char *)regmatch.startp[0];
      } else {
        end = str + strlen(str);
      }
      if (keepempty || end > str || (tv_list_len(rettv->vval.v_list) > 0
                                     && *str != '\000'
                                     && match
                                     && end < (const char *)regmatch.endp[0])) {
        tv_list_append_string(rettv->vval.v_list, str, end - str);
      }
      if (!match) {
        break;
      }

      if (regmatch.endp[0] > (char_u *)str) {
        col = 0;
      } else {

        col = utfc_ptr2len(regmatch.endp[0]);
      }
      str = (const char *)regmatch.endp[0];
    }

    vim_regfree(regmatch.regprog);
  }

theend:
  p_cpo = save_cpo;
}


static void f_stdpath(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 10457 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 10457 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;

  const char *const p = tv_get_string_chk(&argvars[0]);
  if (p == 
# 10460 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          ((void *)0)
# 10460 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
              ) {
    return;
  }

  if (strequal(p, "config")) {
    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGConfigHome);
  } else if (strequal(p, "data")) {
    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGDataHome);
  } else if (strequal(p, "cache")) {
    rettv->vval.v_string = (char_u *)get_xdg_home(kXDGCacheHome);
  } else if (strequal(p, "config_dirs")) {
    get_xdg_var_list(kXDGConfigDirs, rettv);
  } else if (strequal(p, "data_dirs")) {
    get_xdg_var_list(kXDGDataDirs, rettv);
  } else {
    semsg(
# 10475 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 10475 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E6100: \"%s\" is not a valid stdpath")
# 10475 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 10475 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , p);
  }
}




static void f_str2float(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u *p = skipwhite((const char_u *)tv_get_string(&argvars[0]));
  
# 10485 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10485 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      isneg = (*p == '-');

  if (*p == '+' || *p == '-') {
    p = skipwhite(p + 1);
  }
  (void)string2float((char *)p, &rettv->vval.v_float);
  if (isneg) {
    rettv->vval.v_float *= -1;
  }
  rettv->v_type = VAR_FLOAT;
}


static void f_str2list(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, kListLenUnknown);
  const char_u *p = (const char_u *)tv_get_string(&argvars[0]);

  for (; *p != '\000'; p += utf_ptr2len(p)) {
    tv_list_append_number(rettv->vval.v_list, utf_ptr2char(p));
  }
}


static void f_str2nr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int base = 10;
  varnumber_T n;
  int what = 0;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    base = tv_get_number(&argvars[1]);
    if (base != 2 && base != 8 && base != 10 && base != 16) {
      emsg(
# 10518 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 10518 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_invarg)
# 10518 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 10518 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
      return;
    }
    if (argvars[2].v_type != VAR_UNKNOWN && tv_get_number(&argvars[2])) {
      what |= STR2NR_QUOTE;
    }
  }

  char_u *p = skipwhite((const char_u *)tv_get_string(&argvars[0]));
  
# 10527 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10527 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      isneg = (*p == '-');
  if (*p == '+' || *p == '-') {
    p = skipwhite(p + 1);
  }
  switch (base) {
  case 2:
    what |= STR2NR_BIN | STR2NR_FORCE;
    break;
  case 8:
    what |= STR2NR_OCT | STR2NR_OOCT | STR2NR_FORCE;
    break;
  case 16:
    what |= STR2NR_HEX | STR2NR_FORCE;
    break;
  }
  vim_str2nr(p, 
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   , 
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , what, &n, 
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     ((void *)0)
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , 0, 
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              0
# 10542 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   );

  if (isneg) {
    rettv->vval.v_number = -n;
  } else {
    rettv->vval.v_number = n;
  }
}




static void f_strftime(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  time_t seconds;

  rettv->v_type = VAR_STRING;

  char *p = (char *)tv_get_string(&argvars[0]);
  if (argvars[1].v_type == VAR_UNKNOWN) {
    seconds = time(
# 10562 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 10562 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      );
  } else {
    seconds = (time_t)tv_get_number(&argvars[1]);
  }

  struct tm curtime;
  struct tm *curtime_ptr = os_localtime_r(&seconds, &curtime);

  if (curtime_ptr == 
# 10570 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 10570 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ) {
    rettv->vval.v_string = vim_strsave((char_u *)
# 10571 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                dcgettext (((void *)0), 
# 10571 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                (char *)("(Invalid)")
# 10571 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                , 5)
# 10571 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                              );
  } else {
    vimconv_T conv;
    char_u *enc;

    conv.vc_type = CONV_NONE;
    enc = enc_locale();
    convert_setup(&conv, p_enc, enc);
    if (conv.vc_type != CONV_NONE) {
      p = (char *)string_convert(&conv, (char_u *)p, 
# 10580 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    ((void *)0)
# 10580 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );
    }
    char result_buf[256];
    if (p != 
# 10583 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 10583 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
      (void)strftime(result_buf, sizeof(result_buf), p, curtime_ptr);
    } else {
      result_buf[0] = '\000';
    }

    if (conv.vc_type != CONV_NONE) {
      xfree(p);
    }
    convert_setup(&conv, enc, p_enc);
    if (conv.vc_type != CONV_NONE) {
      rettv->vval.v_string = string_convert(&conv, (char_u *)result_buf, 
# 10594 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                        ((void *)0)
# 10594 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                            );
    } else {
      rettv->vval.v_string = (char_u *)xstrdup(result_buf);
    }


    convert_setup(&conv, 
# 10600 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 10600 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , 
# 10600 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 10600 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  );
    xfree(enc);
  }
}


static void f_strgetchar(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;

  const char *const str = tv_get_string_chk(&argvars[0]);
  if (str == 
# 10611 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 10611 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    return;
  }
  
# 10614 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10614 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 10614 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 10614 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  varnumber_T charidx = tv_get_number_chk(&argvars[1], &error);
  if (error) {
    return;
  }

  const size_t len = strlen((char *)(str));
  size_t byteidx = 0;

  while (charidx >= 0 && byteidx < len) {
    if (charidx == 0) {
      rettv->vval.v_number = utf_ptr2char((const char_u *)str + byteidx);
      break;
    }
    charidx--;
    byteidx += utf_ptr2len((const char_u *)str + byteidx);
  }
}




static void f_stridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;

  char buf[NUMBUFLEN];
  const char *const needle = tv_get_string_chk(&argvars[1]);
  const char *haystack = tv_get_string_buf_chk(&argvars[0], buf);
  const char *const haystack_start = haystack;
  if (needle == 
# 10644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 10644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    || haystack == 
# 10644 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
# 10644 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ) {
    return;
  }

  if (argvars[2].v_type != VAR_UNKNOWN) {
    
# 10649 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 10649 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        error = 
# 10649 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                0
# 10649 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;

    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&argvars[2],
                                                             &error);
    if (error || start_idx >= (ptrdiff_t)strlen(haystack)) {
      return;
    }
    if (start_idx >= 0) {
      haystack += start_idx;
    }
  }

  const char *pos = strstr(haystack, needle);
  if (pos != 
# 10662 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
# 10662 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ) {
    rettv->vval.v_number = (varnumber_T)(pos - haystack_start);
  }
}




void f_string(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)encode_tv2string(&argvars[0], 
# 10673 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                ((void *)0)
# 10673 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                    );
}




static void f_strlen(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = (varnumber_T)strlen(tv_get_string(&argvars[0]));
}




static void f_strchars(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *s = tv_get_string(&argvars[0]);
  int skipcc = 0;
  varnumber_T len = 0;
  int (*func_mb_ptr2char_adv)(const char_u **pp);

  if (argvars[1].v_type != VAR_UNKNOWN) {
    skipcc = tv_get_number_chk(&argvars[1], 
# 10695 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                           ((void *)0)
# 10695 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               );
  }
  if (skipcc < 0 || skipcc > 1) {
    emsg(
# 10698 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 10698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 10698 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 10698 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
  } else {
    func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;
    while (*s != '\000') {
      func_mb_ptr2char_adv((const char_u **)&s);
      len++;
    }
    rettv->vval.v_number = len;
  }
}




static void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const s = tv_get_string(&argvars[0]);
  int col = 0;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    col = tv_get_number(&argvars[1]);
  }

  rettv->vval.v_number = (varnumber_T)(linetabsize_col(col, (char_u *)s) - col);
}




static void f_strwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const s = tv_get_string(&argvars[0]);

  rettv->vval.v_number = (varnumber_T)mb_string2cells((const char_u *)s);
}


static void f_strcharpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const p = tv_get_string(&argvars[0]);
  const size_t slen = strlen((char *)(p));

  int nbyte = 0;
  
# 10741 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10741 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 10741 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 10741 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  varnumber_T nchar = tv_get_number_chk(&argvars[1], &error);
  if (!error) {
    if (nchar > 0) {
      while (nchar > 0 && (size_t)nbyte < slen) {
        nbyte += utf_ptr2len((const char_u *)p + nbyte);
        nchar--;
      }
    } else {
      nbyte = nchar;
    }
  }
  int len = 0;
  if (argvars[2].v_type != VAR_UNKNOWN) {
    int charlen = tv_get_number(&argvars[2]);
    while (charlen > 0 && nbyte + len < (int)slen) {
      int off = nbyte + len;

      if (off < 0) {
        len += 1;
      } else {
        len += utf_ptr2len((const char_u *)p + off);
      }
      charlen--;
    }
  } else {
    len = slen - nbyte;
  }



  if (nbyte < 0) {
    len += nbyte;
    nbyte = 0;
  } else if ((size_t)nbyte > slen) {
    nbyte = slen;
  }
  if (len < 0) {
    len = 0;
  } else if (nbyte + len > (int)slen) {
    len = slen - nbyte;
  }

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)xstrndup(p + nbyte, (size_t)len);
}




static void f_strpart(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 10793 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10793 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 10793 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 10793 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;

  const char *const p = tv_get_string(&argvars[0]);
  const size_t slen = strlen(p);

  varnumber_T n = tv_get_number_chk(&argvars[1], &error);
  varnumber_T len;
  if (error) {
    len = 0;
  } else if (argvars[2].v_type != VAR_UNKNOWN) {
    len = tv_get_number(&argvars[2]);
  } else {
    len = slen - n;
  }



  if (n < 0) {
    len += n;
    n = 0;
  } else if (n > (varnumber_T)slen) {
    n = slen;
  }
  if (len < 0) {
    len = 0;
  } else if (n + len > (varnumber_T)slen) {
    len = slen - n;
  }

  if (argvars[2].v_type != VAR_UNKNOWN && argvars[3].v_type != VAR_UNKNOWN) {
    int off;


    for (off = n; off < (int)slen && len > 0; len--) {
      off += utfc_ptr2len((char_u *)p + off);
    }
    len = off - n;
  }

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)xmemdupz(p + n, (size_t)len);
}


static void f_strptime(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char fmt_buf[NUMBUFLEN];
  char str_buf[NUMBUFLEN];

  struct tm tmval = {
    .tm_isdst = -1,
  };
  char *fmt = (char *)tv_get_string_buf(&argvars[0], fmt_buf);
  char *str = (char *)tv_get_string_buf(&argvars[1], str_buf);

  vimconv_T conv = {
    .vc_type = CONV_NONE,
  };
  char_u *enc = enc_locale();
  convert_setup(&conv, p_enc, enc);
  if (conv.vc_type != CONV_NONE) {
    fmt = (char *)string_convert(&conv, (char_u *)fmt, 
# 10854 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 10854 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          );
  }
  if (fmt == 
# 10856 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
      
# 10857 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     || os_strptime(str, fmt, &tmval) == 
# 10857 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                         ((void *)0)
      
# 10858 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     || (rettv->vval.v_number = mktime(&tmval)) == -1) {
    rettv->vval.v_number = 0;
  }
  if (conv.vc_type != CONV_NONE) {
    xfree(fmt);
  }
  convert_setup(&conv, 
# 10864 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 10864 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , 
# 10864 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 10864 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                );
  xfree(enc);
}




static void f_strridx(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char buf[NUMBUFLEN];
  const char *const needle = tv_get_string_chk(&argvars[1]);
  const char *const haystack = tv_get_string_buf_chk(&argvars[0], buf);

  rettv->vval.v_number = -1;
  if (needle == 
# 10878 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0) 
# 10878 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    || haystack == 
# 10878 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                   ((void *)0)
# 10878 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                       ) {
    return;
  }

  const size_t haystack_len = strlen((char *)(haystack));
  ptrdiff_t end_idx;
  if (argvars[2].v_type != VAR_UNKNOWN) {

    end_idx = (ptrdiff_t)tv_get_number_chk(&argvars[2], 
# 10886 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       ((void *)0)
# 10886 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           );
    if (end_idx < 0) {
      return;
    }
  } else {
    end_idx = (ptrdiff_t)haystack_len;
  }

  const char *lastmatch = 
# 10894 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         ((void *)0)
# 10894 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
  if (*needle == '\000') {

    lastmatch = haystack + end_idx;
  } else {
    for (const char *rest = haystack; *rest != '\000'; rest++) {
      rest = strstr(rest, needle);
      if (rest == 
# 10901 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0) 
# 10901 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      || rest > haystack + end_idx) {
        break;
      }
      lastmatch = rest;
    }
  }

  if (lastmatch != 
# 10908 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 10908 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ) {
    rettv->vval.v_number = (varnumber_T)(lastmatch - haystack);
  }
}




static void f_strtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)transstr(tv_get_string(&argvars[0]), 
# 10919 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                       1
# 10919 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                           );
}




static void f_submatch(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  
# 10927 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 10927 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      error = 
# 10927 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              0
# 10927 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  int no = (int)tv_get_number_chk(&argvars[0], &error);
  if (error) {
    return;
  }

  if (no < 0 || no >= 10) {
    semsg(
# 10934 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 10934 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E935: invalid submatch number: %d")
# 10934 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 10934 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               , no);
    return;
  }
  int retList = 0;

  if (argvars[1].v_type != VAR_UNKNOWN) {
    retList = tv_get_number_chk(&argvars[1], &error);
    if (error) {
      return;
    }
  }

  if (retList == 0) {
    rettv->v_type = VAR_STRING;
    rettv->vval.v_string = reg_submatch(no);
  } else {
    rettv->v_type = VAR_LIST;
    rettv->vval.v_list = reg_submatch_list(no);
  }
}




static void f_substitute(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char patbuf[NUMBUFLEN];
  char subbuf[NUMBUFLEN];
  char flagsbuf[NUMBUFLEN];

  const char *const str = tv_get_string_chk(&argvars[0]);
  const char *const pat = tv_get_string_buf_chk(&argvars[1], patbuf);
  const char *sub = 
# 10966 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   ((void *)0)
# 10966 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  const char *const flg = tv_get_string_buf_chk(&argvars[3], flagsbuf);

  typval_T *expr = 
# 10969 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  ((void *)0)
# 10969 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  if (tv_is_func(argvars[2])) {
    expr = &argvars[2];
  } else {
    sub = tv_get_string_buf_chk(&argvars[2], subbuf);
  }

  rettv->v_type = VAR_STRING;
  if (str == 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0) 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 || pat == 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0) 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                || (sub == 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                           ((void *)0) 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                && expr == 
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                           ((void *)0)
# 10977 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                               )
      || flg == 
# 10978 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 10978 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {
    rettv->vval.v_string = 
# 10979 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 10979 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    rettv->vval.v_string = do_string_sub((char_u *)str, (char_u *)pat,
                                         (char_u *)sub, expr, (char_u *)flg);
  }
}


static void f_swapinfo(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);
  get_b0_dict(tv_get_string(argvars), rettv->vval.v_dict);
}


static void f_swapname(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  buf_T *buf = tv_get_buf(&argvars[0], 
# 10997 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      0
# 10997 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           );
  if (buf == 
# 10998 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
            ((void *)0)
      
# 10999 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     || buf->b_ml.ml_mfp == 
# 10999 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
      
# 11000 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
     || buf->b_ml.ml_mfp->mf_fname == 
# 11000 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                      ((void *)0)
# 11000 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          ) {
    rettv->vval.v_string = 
# 11001 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 11001 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    rettv->vval.v_string = vim_strsave(buf->b_ml.ml_mfp->mf_fname);
  }
}


static void f_synID(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{

  const linenr_T lnum = tv_get_lnum(argvars);
  const colnr_T col = (colnr_T)tv_get_number(&argvars[1]) - 1;

  
# 11014 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 11014 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      transerr = 
# 11014 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 0
# 11014 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  const int trans = tv_get_number_chk(&argvars[2], &transerr);

  int id = 0;
  if (!transerr && lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count
      && col >= 0 && (size_t)col < strlen((char *)(ml_get(lnum)))) {
    id = syn_get_id(curwin, lnum, col, trans, 
# 11020 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             ((void *)0)
# 11020 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , 
# 11020 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   0
# 11020 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );
  }

  rettv->vval.v_number = id;
}




static void f_synIDattr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const int id = (int)tv_get_number(&argvars[0]);
  const char *const what = tv_get_string(&argvars[1]);
  int modec;
  if (argvars[2].v_type != VAR_UNKNOWN) {
    char modebuf[NUMBUFLEN];
    const char *const mode = tv_get_string_buf(&argvars[2], modebuf);
    modec = (((mode[0]) < 'A' || (mode[0]) > 'Z') ? (mode[0]) : (mode[0]) + ('a' - 'A'));
    if (modec != 'c' && modec != 'g') {
      modec = 0;
    }
  } else if (ui_rgb_attached()) {
    modec = 'g';
  } else {
    modec = 'c';
  }


  const char *p = 
# 11048 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 11048 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ;
  switch ((((what[0]) < 'A' || (what[0]) > 'Z') ? (what[0]) : (what[0]) + ('a' - 'A'))) {
  case 'b':
    if ((((what[1]) < 'A' || (what[1]) > 'Z') ? (what[1]) : (what[1]) + ('a' - 'A')) == 'g') {
      p = highlight_color(id, what, modec);
    } else {
      p = highlight_has_attr(id, HL_BOLD, modec);
    }
    break;
  case 'f':
    p = highlight_color(id, what, modec);
    break;
  case 'i':
    if ((((what[1]) < 'A' || (what[1]) > 'Z') ? (what[1]) : (what[1]) + ('a' - 'A')) == 'n') {
      p = highlight_has_attr(id, HL_INVERSE, modec);
    } else {
      p = highlight_has_attr(id, HL_ITALIC, modec);
    }
    break;
  case 'n':
    p = get_highlight_name_ext(
# 11068 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 11068 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  , id - 1, 
# 11068 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 11068 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
    break;
  case 'r':
    p = highlight_has_attr(id, HL_INVERSE, modec);
    break;
  case 's':
    if ((((what[1]) < 'A' || (what[1]) > 'Z') ? (what[1]) : (what[1]) + ('a' - 'A')) == 'p') {
      p = highlight_color(id, what, modec);
    } else if ((((what[1]) < 'A' || (what[1]) > 'Z') ? (what[1]) : (what[1]) + ('a' - 'A')) == 't'
               && (((what[2]) < 'A' || (what[2]) > 'Z') ? (what[2]) : (what[2]) + ('a' - 'A')) == 'r') {
      p = highlight_has_attr(id, HL_STRIKETHROUGH, modec);
    } else {
      p = highlight_has_attr(id, HL_STANDOUT, modec);
    }
    break;
  case 'u':
    if (strlen((char *)(what)) <= 5 || (((what[5]) < 'A' || (what[5]) > 'Z') ? (what[5]) : (what[5]) + ('a' - 'A')) != 'c') {
      p = highlight_has_attr(id, HL_UNDERLINE, modec);
    } else {
      p = highlight_has_attr(id, HL_UNDERCURL, modec);
    }
    break;
  }

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)(p == 
# 11093 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        ((void *)0) 
# 11093 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                             ? p : xstrdup(p));
}




static void f_synIDtrans(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int id = tv_get_number(&argvars[0]);

  if (id > 0) {
    id = syn_get_final_id(id);
  } else {
    id = 0;
  }

  rettv->vval.v_number = id;
}




static void f_synconcealed(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int syntax_flags = 0;
  int cchar;
  int matchid = 0;
  char_u str[NUMBUFLEN];

  tv_list_set_ret(rettv, 
# 11122 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11122 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            );


  const linenr_T lnum = tv_get_lnum(argvars);
  const colnr_T col = (colnr_T)tv_get_number(&argvars[1]) - 1;

  memset(str, '\000', sizeof(str));

  if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count && col >= 0
      && (size_t)col <= strlen((char *)(ml_get(lnum))) && curwin->w_onebuf_opt.wo_cole > 0) {
    (void)syn_get_id(curwin, lnum, col, 
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       0
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            , 
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , 
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    0
# 11132 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         );
    syntax_flags = get_syntax_info(&matchid);


    if ((syntax_flags & 0x20000) && curwin->w_onebuf_opt.wo_cole < 3) {
      cchar = syn_get_sub_char();
      if (cchar == '\000' && curwin->w_onebuf_opt.wo_cole == 1) {
        cchar = (curwin->w_p_lcs_chars.conceal == '\000')
          ? ' '
          : curwin->w_p_lcs_chars.conceal;
      }
      if (cchar != '\000') {
        utf_char2bytes(cchar, str);
      }
    }
  }

  tv_list_alloc_ret(rettv, 3);
  tv_list_append_number(rettv->vval.v_list, (syntax_flags & 0x20000) != 0);

  tv_list_append_string(rettv->vval.v_list, (const char *)str, -1);
  tv_list_append_number(rettv->vval.v_list, matchid);
}




static void f_synstack(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_set_ret(rettv, 
# 11161 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11161 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            );


  const linenr_T lnum = tv_get_lnum(argvars);
  const colnr_T col = (colnr_T)tv_get_number(&argvars[1]) - 1;

  if (lnum >= 1
      && lnum <= curbuf->b_ml.ml_line_count
      && col >= 0
      && (size_t)col <= strlen((char *)(ml_get(lnum)))) {
    tv_list_alloc_ret(rettv, kListLenMayKnow);
    (void)syn_get_id(curwin, lnum, col, 
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       0
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            , 
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                              ((void *)0)
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                  , 
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                    1
# 11172 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                        );

    int id;
    int i = 0;
    while ((id = syn_get_stack_item(i++)) >= 0) {
      tv_list_append_number(rettv->vval.v_list, id);
    }
  }
}


static void f_system(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_system_output_as_rettv(argvars, rettv, 
# 11185 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 11185 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 );
}

static void f_systemlist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  get_system_output_as_rettv(argvars, rettv, 
# 11190 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            1
# 11190 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                );
}





static void f_tabpagebuflist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = 
# 11199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 11199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ;

  if (argvars[0].v_type == VAR_UNKNOWN) {
    wp = firstwin;
  } else {
    tabpage_T *const tp = find_tabpage((int)tv_get_number(&argvars[0]));
    if (tp != 
# 11205 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 11205 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
    }
  }
  if (wp != 
# 11209 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 11209 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    tv_list_alloc_ret(rettv, kListLenMayKnow);
    while (wp != 
# 11211 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 11211 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      tv_list_append_number(rettv->vval.v_list, wp->w_buffer->handle);
      wp = wp->w_next;
    }
  }
}




static void f_tabpagenr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int nr = 1;

  if (argvars[0].v_type != VAR_UNKNOWN) {
    const char *const arg = tv_get_string_chk(&argvars[0]);
    nr = 0;
    if (arg != 
# 11228 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 11228 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      if (strcmp(arg, "$") == 0) {
        nr = tabpage_index(
# 11230 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 11230 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ) - 1;
      } else if (strcmp(arg, "#") == 0) {
        nr = valid_tabpage(lastused_tabpage)
             ? tabpage_index(lastused_tabpage)
             : nr;
      } else {
        semsg(
# 11236 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 11236 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invexpr2)
# 11236 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 11236 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          , arg);
      }
    }
  } else {
    nr = tabpage_index(curtab);
  }
  rettv->vval.v_number = nr;
}





static int get_winnr(tabpage_T *tp, typval_T *argvar)
{
  win_T *twin;
  int nr = 1;
  win_T *wp;

  twin = (tp == curtab) ? curwin : tp->tp_curwin;
  if (argvar->v_type != VAR_UNKNOWN) {
    
# 11257 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 11257 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        invalid_arg = 
# 11257 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      0
# 11257 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
    const char *const arg = tv_get_string_chk(argvar);
    if (arg == 
# 11259 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 11259 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
      nr = 0;
    } else if (strcmp(arg, "$") == 0) {
      twin = (tp == curtab) ? lastwin : tp->tp_lastwin;
    } else if (strcmp(arg, "#") == 0) {
      twin = (tp == curtab) ? prevwin : tp->tp_prevwin;
      if (twin == 
# 11265 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 11265 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
        nr = 0;
      }
    } else {

      char_u *endp;
      long count = strtol((char *)arg, (char **)&endp, 10);
      if (count <= 0) {

        count = 1;
      }
      if (endp != 
# 11276 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0) 
# 11276 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      && *endp != '\0') {
        if (strequal((char *)endp, "j")) {
          twin = win_vert_neighbor(tp, twin, 
# 11278 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 11278 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , count);
        } else if (strequal((char *)endp, "k")) {
          twin = win_vert_neighbor(tp, twin, 
# 11280 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            1
# 11280 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                , count);
        } else if (strequal((char *)endp, "h")) {
          twin = win_horz_neighbor(tp, twin, 
# 11282 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            1
# 11282 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                , count);
        } else if (strequal((char *)endp, "l")) {
          twin = win_horz_neighbor(tp, twin, 
# 11284 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 11284 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , count);
        } else {
          invalid_arg = 
# 11286 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       1
# 11286 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;
        }
      } else {
        invalid_arg = 
# 11289 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     1
# 11289 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
      }
    }

    if (invalid_arg) {
      semsg(
# 11294 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 11294 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invexpr2)
# 11294 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 11294 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        , arg);
      nr = 0;
    }
  }

  if (nr > 0) {
    for (wp = (tp == curtab) ? firstwin : tp->tp_firstwin;
         wp != twin; wp = wp->w_next) {
      if (wp == 
# 11302 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 11302 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ) {

        nr = 0;
        break;
      }
      ++nr;
    }
  }
  return nr;
}




static void f_tabpagewinnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int nr = 1;
  tabpage_T *const tp = find_tabpage((int)tv_get_number(&argvars[0]));
  if (tp == 
# 11320 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 11320 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    nr = 0;
  } else {
    nr = get_winnr(tp, &argvars[1]);
  }
  rettv->vval.v_number = nr;
}




static void f_tagfiles(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char *fname;
  tagname_T tn;

  tv_list_alloc_ret(rettv, kListLenUnknown);
  fname = xmalloc(4096);

  
# 11339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 11339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      first = 
# 11339 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 11339 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  while (get_tagfname(&tn, first, (char_u *)fname) == 1) {
    tv_list_append_string(rettv->vval.v_list, fname, -1);
    first = 
# 11342 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           0
# 11342 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                ;
  }

  tagname_free(&tn);
  xfree(fname);
}




static void f_taglist(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  const char *const tag_pattern = tv_get_string(&argvars[0]);

  rettv->vval.v_number = 
# 11356 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        0
# 11356 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             ;
  if (*tag_pattern == '\000') {
    return;
  }

  const char *fname = 
# 11361 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     ((void *)0)
# 11361 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         ;
  if (argvars[1].v_type != VAR_UNKNOWN) {
    fname = tv_get_string(&argvars[1]);
  }
  (void)get_tags(tv_list_alloc_ret(rettv, kListLenUnknown),
                 (char_u *)tag_pattern, (char_u *)fname);
}




static void f_tempname(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = vim_tempname();
}


static void f_termopen(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (check_secure()) {
    return;
  }

  if (curbuf->b_changed) {
    emsg(
# 11386 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 11386 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("Can only call this function in an unmodified buffer")
# 11386 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 11386 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                );
    return;
  }

  const char *cmd;
  
# 11391 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 11391 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      executable = 
# 11391 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   1
# 11391 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  char **argv = tv_to_argv(&argvars[0], &cmd, &executable);
  if (!argv) {
    rettv->vval.v_number = executable ? 0 : -1;
    return;
  }

  if (argvars[1].v_type != VAR_DICT && argvars[1].v_type != VAR_UNKNOWN) {

    semsg(
# 11400 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 11400 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 11400 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 11400 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     , "expected dictionary");
    shell_free_argv(argv);
    return;
  }

  CallbackReader on_stdout = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .buffer = { 0, 0, 0, 1, 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }, .buffered = 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            0
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .type = 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 11405 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }),
                 on_stderr = ((CallbackReader){ .cb = ((Callback){ .type = kCallbackNone }), .self = 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .buffer = { 0, 0, 0, 1, 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            }, .buffered = 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            0
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , .type = 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0) 
# 11406 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            });
  Callback on_exit = ((Callback){ .type = kCallbackNone });
  dict_T *job_opts = 
# 11408 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                    ((void *)0)
# 11408 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  const char *cwd = ".";
  dict_T *env = 
# 11410 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               ((void *)0)
# 11410 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   ;
  const 
# 11411 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 11411 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            pty = 
# 11411 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  1
# 11411 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ;
  
# 11412 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 11412 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      clear_env = 
# 11412 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 11412 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  dictitem_T *job_env = 
# 11413 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ((void *)0)
# 11413 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                           ;

  if (argvars[1].v_type == VAR_DICT) {
    job_opts = argvars[1].vval.v_dict;

    const char *const new_cwd = tv_dict_get_string(job_opts, "cwd", 
# 11418 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                   0
# 11418 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        );
    if (new_cwd && *new_cwd != '\000') {
      cwd = new_cwd;

      if (!os_isdir_executable(cwd)) {
        semsg(
# 11423 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 11423 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 11423 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 11423 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , "expected valid directory");
        shell_free_argv(argv);
        return;
      }
    }

    job_env = tv_dict_find(job_opts, ("env"), (sizeof("env") - 1));
    if (job_env && job_env->di_tv.v_type != VAR_DICT) {
      semsg(
# 11431 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 11431 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 11431 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 11431 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , "env");
      shell_free_argv(argv);
      return;
    }

    clear_env = tv_dict_get_number(job_opts, "clear_env") != 0;

    if (!common_job_callbacks(job_opts, &on_stdout, &on_stderr, &on_exit)) {
      shell_free_argv(argv);
      return;
    }
  }

  env = create_environment(job_env, clear_env, pty, "xterm-256color");

  const 
# 11446 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 11446 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            rpc = 
# 11446 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 11446 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;
  const 
# 11447 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 11447 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            overlapped = 
# 11447 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         0
# 11447 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  const 
# 11448 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       _Bool 
# 11448 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
            detach = 
# 11448 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                     0
# 11448 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  ChannelStdinMode stdin_mode = kChannelStdinPipe;
  uint16_t term_width = 
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       (((
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       0
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       )>(
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       curwin->w_width_inner - win_col_off(curwin)
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ))?(
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       0
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ):(
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       curwin->w_width_inner - win_col_off(curwin)
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                       ))
# 11450 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                          ;
  Channel *chan = channel_job_start(argv, on_stdout, on_stderr, on_exit,
                                    pty, rpc, overlapped, detach, stdin_mode,
                                    cwd, term_width, curwin->w_height_inner,
                                    env, &rettv->vval.v_number);
  if (rettv->vval.v_number <= 0) {
    return;
  }

  int pid = chan->stream.pty.process.pid;


  vim_FullName(cwd, (char *)NameBuff, sizeof(NameBuff), 
# 11462 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       0
# 11462 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                            );

  size_t len = home_replace(
# 11464 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                           ((void *)0)
# 11464 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                               , NameBuff, IObuff, sizeof(IObuff), 
# 11464 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                   1
# 11464 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                       );

  if (IObuff[len - 1] == '\\' || IObuff[len - 1] == '/') {
    IObuff[len - 1] = '\0';
  }


  snprintf((char *)NameBuff, sizeof(NameBuff), "term://%s//%d:%s",
           (char *)IObuff, pid, cmd);


  curbuf->b_p_swf = 
# 11475 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                   0
# 11475 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                        ;
  (void)setfname(curbuf, NameBuff, 
# 11476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                  ((void *)0)
# 11476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                      , 
# 11476 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                        1
# 11476 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            );

  Error err = { .type = kErrorTypeNone, .msg = 
# 11478 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0) 
# 11478 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             };

  dict_set_var(curbuf->b_vars, cstr_as_string("terminal_job_id"),
               ((Object) { .type = kObjectTypeInteger, .data.integer = chan->id }), 
# 11481 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                     0
# 11481 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                          , 
# 11481 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                            0
# 11481 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 , &err);
  api_clear_error(&err);
  dict_set_var(curbuf->b_vars, cstr_as_string("terminal_job_pid"),
               ((Object) { .type = kObjectTypeInteger, .data.integer = pid }), 
# 11484 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                0
# 11484 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     , 
# 11484 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       0
# 11484 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                            , &err);
  api_clear_error(&err);

  channel_terminal_open(curbuf, chan);
  channel_create_event(chan, 
# 11488 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                            ((void *)0)
# 11488 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                );
}


static void f_test_garbagecollect_now(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{


  garbage_collect(
# 11496 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 1
# 11496 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     );
}


static void f_test_write_list_log(typval_T *const argvars, typval_T *const rettv, FunPtr fptr)
{
  const char *const fname = tv_get_string_chk(&argvars[0]);
  if (fname == 
# 11503 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 11503 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }
  ;
}


static void f_timer_info(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_UNKNOWN) {
    if (argvars[0].v_type != VAR_NUMBER) {
      emsg(
# 11514 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          dcgettext (((void *)0), 
# 11514 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          (char *)(e_number_exp)
# 11514 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
          , 5)
# 11514 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         );
      return;
    }
    tv_list_alloc_ret(rettv, 1);
    timer_T *timer = find_timer_by_nr(tv_get_number(&argvars[0]));
    if (timer != 
# 11519 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 11519 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     && !timer->stopped) {
      add_timer_info(rettv, timer);
    }
  } else {
    add_timer_info_all(rettv);
  }
}


static void f_timer_pause(typval_T *argvars, typval_T *unused, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_NUMBER) {
    emsg(
# 11531 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 11531 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_number_exp)
# 11531 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 11531 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
    return;
  }
  int paused = (
# 11534 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               _Bool
# 11534 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   )tv_get_number(&argvars[1]);
  timer_T *timer = find_timer_by_nr(tv_get_number(&argvars[0]));
  if (timer != 
# 11536 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 11536 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    if (!timer->paused && paused) {
      time_watcher_stop(&timer->tw);
    } else if (timer->paused && !paused) {
      time_watcher_start(&timer->tw, timer_due_cb, timer->timeout,
                         timer->timeout);
    }
    timer->paused = paused;
  }
}


static void f_timer_start(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int repeat = 1;
  dict_T *dict;

  rettv->vval.v_number = -1;

  if (argvars[2].v_type != VAR_UNKNOWN) {
    if (argvars[2].v_type != VAR_DICT
        || (dict = argvars[2].vval.v_dict) == 
# 11557 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                             ((void *)0)
# 11557 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                 ) {
      semsg(
# 11558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 11558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)(e_invarg2)
# 11558 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 11558 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       , tv_get_string(&argvars[2]));
      return;
    }
    dictitem_T *const di = tv_dict_find(dict, ("repeat"), (sizeof("repeat") - 1));
    if (di != 
# 11562 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 11562 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      repeat = tv_get_number(&di->di_tv);
      if (repeat == 0) {
        repeat = 1;
      }
    }
  }

  Callback callback;
  if (!callback_from_typval(&callback, &argvars[1])) {
    return;
  }
  rettv->vval.v_number =
    timer_start(tv_get_number(&argvars[0]), repeat, &callback);
}



static void f_timer_stop(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (argvars[0].v_type != VAR_NUMBER) {
    emsg(
# 11583 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 11583 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_number_exp)
# 11583 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 11583 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       );
    return;
  }

  timer_T *timer = find_timer_by_nr(tv_get_number(&argvars[0]));
  if (timer == 
# 11588 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 11588 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }

  timer_stop(timer);
}

static void f_timer_stopall(typval_T *argvars, typval_T *unused, FunPtr fptr)
{
  timer_stop_all();
}




static void f_tolower(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)strcase_save(tv_get_string(&argvars[0]),
                                                
# 11607 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               0
# 11607 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                    );
}




static void f_toupper(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)strcase_save(tv_get_string(&argvars[0]),
                                                
# 11617 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                               1
# 11617 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   );
}




static void f_tr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char buf[NUMBUFLEN];
  char buf2[NUMBUFLEN];

  const char *in_str = tv_get_string(&argvars[0]);
  const char *fromstr = tv_get_string_buf_chk(&argvars[1], buf);
  const char *tostr = tv_get_string_buf_chk(&argvars[2], buf2);


  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 11634 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11634 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (fromstr == 
# 11635 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0) 
# 11635 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     || tostr == 
# 11635 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                 ((void *)0)
# 11635 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                     ) {
    return;
  }
  garray_T ga;
  ga_init(&ga, (int)sizeof(char), 80);


  
# 11642 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 11642 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      first = 
# 11642 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              1
# 11642 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
  while (*in_str != '\000') {
    const char *cpstr = in_str;
    const int inlen = utfc_ptr2len((const char_u *)in_str);
    int cplen = inlen;
    int idx = 0;
    int fromlen;
    for (const char *p = fromstr; *p != '\000'; p += fromlen) {
      fromlen = utfc_ptr2len((const char_u *)p);
      if (fromlen == inlen && strncmp((char *)(in_str), (char *)(p), (size_t)(inlen)) == 0) {
        int tolen;
        for (p = tostr; *p != '\000'; p += tolen) {
          tolen = utfc_ptr2len((const char_u *)p);
          if (idx-- == 0) {
            cplen = tolen;
            cpstr = (char *)p;
            break;
          }
        }
        if (*p == '\000') {
          goto error;
        }
        break;
      }
      idx++;
    }

    if (first && cpstr == in_str) {



      first = 
# 11673 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             0
# 11673 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ;
      int tolen;
      for (const char *p = tostr; *p != '\000'; p += tolen) {
        tolen = utfc_ptr2len((const char_u *)p);
        idx--;
      }
      if (idx != 0) {
        goto error;
      }
    }

    ga_grow(&ga, cplen);
    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);
    ga.ga_len += cplen;

    in_str += inlen;
  }


  ga_append(&ga, '\000');

  rettv->vval.v_string = ga.ga_data;
  return;
error:
  semsg(
# 11697 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       dcgettext (((void *)0), 
# 11697 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
       (char *)(e_invarg2)
# 11697 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
       , 5)
# 11697 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   , fromstr);
  ga_clear(&ga);
  return;
}


static void f_trim(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char buf1[NUMBUFLEN];
  char buf2[NUMBUFLEN];
  const char_u *head = (const char_u *)tv_get_string_buf_chk(&argvars[0], buf1);
  const char_u *mask = 
# 11708 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                      ((void *)0)
# 11708 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                          ;
  const char_u *tail;
  const char_u *prev;
  const char_u *p;
  int c1;
  int dir = 0;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 11716 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11716 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (head == 
# 11717 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 11717 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
    return;
  }

  if (argvars[1].v_type == VAR_STRING) {
    mask = (const char_u *)tv_get_string_buf_chk(&argvars[1], buf2);
    if (argvars[2].v_type != VAR_UNKNOWN) {
      
# 11724 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
     _Bool 
# 11724 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
          error = 
# 11724 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 11724 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ;

      dir = (int)tv_get_number_chk(&argvars[2], &error);
      if (error) {
        return;
      }
      if (dir < 0 || dir > 2) {
        semsg(
# 11731 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 11731 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)(e_invarg2)
# 11731 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 11731 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                         , tv_get_string(&argvars[2]));
        return;
      }
    }
  }

  if (dir == 0 || dir == 1) {

    while (*head != '\000') {
      c1 = utf_ptr2char(head);
      if (mask == 
# 11741 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 11741 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
        if (c1 > ' ' && c1 != 0xa0) {
          break;
        }
      } else {
        for (p = mask; *p != '\000'; (p += utfc_ptr2len((char_u *)p))) {
          if (c1 == utf_ptr2char(p)) {
            break;
          }
        }
        if (*p == '\000') {
          break;
        }
      }
      (head += utfc_ptr2len((char_u *)head));
    }
  }

  tail = head + strlen((char *)(head));
  if (dir == 0 || dir == 2) {

    for (; tail > head; tail = prev) {
      prev = tail;
      (prev -= utf_head_off((char_u *)head, (char_u *)prev - 1) + 1);
      c1 = utf_ptr2char(prev);
      if (mask == 
# 11766 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 11766 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
        if (c1 > ' ' && c1 != 0xa0) {
          break;
        }
      } else {
        for (p = mask; *p != '\000'; (p += utfc_ptr2len((char_u *)p))) {
          if (c1 == utf_ptr2char(p)) {
            break;
          }
        }
        if (*p == '\000') {
          break;
        }
      }
    }
  }
  rettv->vval.v_string = vim_strnsave(head, tail - head);
}




static void f_type(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int n = -1;

  switch (argvars[0].v_type) {
  case VAR_NUMBER:
    n = 0; break;
  case VAR_STRING:
    n = 1; break;
  case VAR_PARTIAL:
  case VAR_FUNC:
    n = 2; break;
  case VAR_LIST:
    n = 3; break;
  case VAR_DICT:
    n = 4; break;
  case VAR_FLOAT:
    n = 5; break;
  case VAR_BOOL:
    n = 6; break;
  case VAR_SPECIAL:
    n = 7; break;
  case VAR_BLOB:
    n = 10; break;
  case VAR_UNKNOWN:
    internal_error("f_type(UNKNOWN)");
    break;
  }
  rettv->vval.v_number = n;
}




static void f_undofile(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  const char *const fname = tv_get_string(&argvars[0]);

  if (*fname == '\000') {

    rettv->vval.v_string = 
# 11829 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                          ((void *)0)
# 11829 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                              ;
  } else {
    char *ffname = FullName_save(fname, 
# 11831 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                       1
# 11831 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                           );

    if (ffname != 
# 11833 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                 ((void *)0)
# 11833 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ) {
      rettv->vval.v_string = (char_u *)u_get_undo_file_name(ffname, 
# 11834 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                   0
# 11834 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                        );
    }
    xfree(ffname);
  }
}




static void f_undotree(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);

  dict_T *dict = rettv->vval.v_dict;

  tv_dict_add_nr(dict, ("synced"), (sizeof("synced") - 1), (varnumber_T)curbuf->b_u_synced);
  tv_dict_add_nr(dict, ("seq_last"), (sizeof("seq_last") - 1), (varnumber_T)curbuf->b_u_seq_last);
  tv_dict_add_nr(dict, ("save_last"), (sizeof("save_last") - 1),
                 (varnumber_T)curbuf->b_u_save_nr_last);
  tv_dict_add_nr(dict, ("seq_cur"), (sizeof("seq_cur") - 1), (varnumber_T)curbuf->b_u_seq_cur);
  tv_dict_add_nr(dict, ("time_cur"), (sizeof("time_cur") - 1), (varnumber_T)curbuf->b_u_time_cur);
  tv_dict_add_nr(dict, ("save_cur"), (sizeof("save_cur") - 1), (varnumber_T)curbuf->b_u_save_nr_cur);

  tv_dict_add_list(dict, ("entries"), (sizeof("entries") - 1), u_eval_tree(curbuf->b_u_oldhead));
}




static void f_values(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_list(argvars, rettv, 1);
}




static void f_virtcol(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  colnr_T vcol = 0;
  pos_T *fp;
  int fnum = curbuf->handle;

  fp = var2fpos(&argvars[0], 0, &fnum);
  if (fp != 
# 11878 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0) 
# 11878 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                && fp->lnum <= curbuf->b_ml.ml_line_count
      && fnum == curbuf->handle) {

    if (fp->col < 0) {
      fp->col = 0;
    } else {
      const size_t len = strlen((char *)(ml_get(fp->lnum)));
      if (fp->col > (colnr_T)len) {
        fp->col = (colnr_T)len;
      }
    }
    getvvcol(curwin, fp, 
# 11889 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11889 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            , 
# 11889 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              ((void *)0)
# 11889 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                  , &vcol);
    ++vcol;
  }

  rettv->vval.v_number = vcol;
}




static void f_visualmode(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  char_u str[2];

  rettv->v_type = VAR_STRING;
  str[0] = curbuf->b_visual_mode_eval;
  str[1] = '\000';
  rettv->vval.v_string = vim_strsave(str);


  if (non_zero_arg(&argvars[0])) {
    curbuf->b_visual_mode_eval = '\000';
  }
}




static void f_wildmenumode(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  if (wild_menu_showing || ((State & 0x08) && pum_visible())) {
    rettv->vval.v_number = 1;
  }
}


static void f_win_findbuf(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_list_alloc_ret(rettv, kListLenMayKnow);
  win_findbuf(argvars, rettv->vval.v_list);
}


static void f_win_getid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = win_getid(argvars);
}


static void f_win_gettype(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = curwin;

  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = 
# 11943 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                        ((void *)0)
# 11943 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                            ;
  if (argvars[0].v_type != VAR_UNKNOWN) {
    wp = find_win_by_nr_or_id(&argvars[0]);
    if (wp == 
# 11946 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 11946 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      rettv->vval.v_string = vim_strsave((char_u *)"unknown");
      return;
    }
  }
  if (wp == aucmd_win) {
    rettv->vval.v_string = vim_strsave((char_u *)"autocmd");
  } else if (wp->w_onebuf_opt.wo_pvw) {
    rettv->vval.v_string = vim_strsave((char_u *)"preview");
  } else if (wp->w_floating) {
    rettv->vval.v_string = vim_strsave((char_u *)"popup");
  } else if (wp == curwin && cmdwin_type != 0) {
    rettv->vval.v_string = vim_strsave((char_u *)"command");
  } else if (bt_quickfix(wp->w_buffer)) {
    rettv->vval.v_string = vim_strsave((char_u *)(wp->w_llist_ref != 
# 11960 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                                    ((void *)0) 
# 11960 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                         ?
                                                  "loclist" : "quickfix"));
  }
}


static void f_win_gotoid(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = win_gotoid(argvars);
}


static void f_win_id2tabwin(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_id2tabwin(argvars, rettv);
}


static void f_win_id2win(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = win_id2win(argvars);
}


static void f_winbufnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = find_win_by_nr_or_id(&argvars[0]);
  if (wp == 
# 11987 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 11987 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = wp->w_buffer->handle;
  }
}




static void f_wincol(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  validate_cursor();
  rettv->vval.v_number = curwin->w_wcol + 1;
}


static void f_winheight(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = find_win_by_nr_or_id(&argvars[0]);
  if (wp == 
# 12007 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 12007 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = wp->w_height;
  }
}


static void f_winlayout(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tabpage_T *tp;

  tv_list_alloc_ret(rettv, 2);

  if (argvars[0].v_type == VAR_UNKNOWN) {
    tp = curtab;
  } else {
    tp = find_tabpage((int)tv_get_number(&argvars[0]));
    if (tp == 
# 12025 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             ((void *)0)
# 12025 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                 ) {
      return;
    }
  }

  get_framelayout(tp->tp_topframe, rettv->vval.v_list, 
# 12030 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      1
# 12030 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          );
}




static void f_winline(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  validate_cursor();
  rettv->vval.v_number = curwin->w_wrow + 1;
}




static void f_winnr(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  int nr = 1;

  nr = get_winnr(curtab, &argvars[0]);
  rettv->vval.v_number = nr;
}




static void f_winrestcmd(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  garray_T ga;
  char_u buf[50];

  ga_init(&ga, (int)sizeof(char), 70);


  for (int i = 0; i < 2; i++) {
    int winnr = 1;
    for (win_T *wp = ((curtab) == curtab) ? firstwin : (curtab)->tp_firstwin; wp != 
# 12066 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 12066 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; wp = wp->w_next) {
      snprintf((char *)buf, sizeof(buf), "%dresize %d|", winnr,
               wp->w_height);
      ga_concat(&ga, (char *)buf);
      snprintf((char *)buf, sizeof(buf), "vert %dresize %d|", winnr,
               wp->w_width);
      ga_concat(&ga, (char *)buf);
      winnr++;
    }
  }
  ga_append(&ga, '\000');

  rettv->vval.v_string = ga.ga_data;
  rettv->v_type = VAR_STRING;
}




static void f_winrestview(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *dict;

  if (argvars[0].v_type != VAR_DICT
      || (dict = argvars[0].vval.v_dict) == 
# 12090 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                           ((void *)0)
# 12090 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                               ) {
    emsg(
# 12091 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 12091 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)(e_invarg)
# 12091 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 12091 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                   );
  } else {
    dictitem_T *di;
    if ((di = tv_dict_find(dict, ("lnum"), (sizeof("lnum") - 1))) != 
# 12094 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                   ((void *)0)
# 12094 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                       ) {
      curwin->w_cursor.lnum = tv_get_number(&di->di_tv);
    }
    if ((di = tv_dict_find(dict, ("col"), (sizeof("col") - 1))) != 
# 12097 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                  ((void *)0)
# 12097 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      ) {
      curwin->w_cursor.col = tv_get_number(&di->di_tv);
    }
    if ((di = tv_dict_find(dict, ("coladd"), (sizeof("coladd") - 1))) != 
# 12100 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                     ((void *)0)
# 12100 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                         ) {
      curwin->w_cursor.coladd = tv_get_number(&di->di_tv);
    }
    if ((di = tv_dict_find(dict, ("curswant"), (sizeof("curswant") - 1))) != 
# 12103 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       ((void *)0)
# 12103 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           ) {
      curwin->w_curswant = tv_get_number(&di->di_tv);
      curwin->w_set_curswant = 
# 12105 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                              0
# 12105 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                   ;
    }
    if ((di = tv_dict_find(dict, ("topline"), (sizeof("topline") - 1))) != 
# 12107 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 12107 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          ) {
      set_topline(curwin, tv_get_number(&di->di_tv));
    }
    if ((di = tv_dict_find(dict, ("topfill"), (sizeof("topfill") - 1))) != 
# 12110 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 12110 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          ) {
      curwin->w_topfill = tv_get_number(&di->di_tv);
    }
    if ((di = tv_dict_find(dict, ("leftcol"), (sizeof("leftcol") - 1))) != 
# 12113 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 12113 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          ) {
      curwin->w_leftcol = tv_get_number(&di->di_tv);
    }
    if ((di = tv_dict_find(dict, ("skipcol"), (sizeof("skipcol") - 1))) != 
# 12116 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                      ((void *)0)
# 12116 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                          ) {
      curwin->w_skipcol = tv_get_number(&di->di_tv);
    }

    check_cursor();
    win_new_height(curwin, curwin->w_height);
    win_new_width(curwin, curwin->w_width);
    changed_window_setting();

    if (curwin->w_topline <= 0) {
      curwin->w_topline = 1;
    }
    if (curwin->w_topline > curbuf->b_ml.ml_line_count) {
      curwin->w_topline = curbuf->b_ml.ml_line_count;
    }
    check_topfill(curwin, 
# 12131 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                         1
# 12131 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                             );
  }
}




static void f_winsaveview(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  dict_T *dict;

  tv_dict_alloc_ret(rettv);
  dict = rettv->vval.v_dict;

  tv_dict_add_nr(dict, ("lnum"), (sizeof("lnum") - 1), (varnumber_T)curwin->w_cursor.lnum);
  tv_dict_add_nr(dict, ("col"), (sizeof("col") - 1), (varnumber_T)curwin->w_cursor.col);
  tv_dict_add_nr(dict, ("coladd"), (sizeof("coladd") - 1), (varnumber_T)curwin->w_cursor.coladd);
  update_curswant();
  tv_dict_add_nr(dict, ("curswant"), (sizeof("curswant") - 1), (varnumber_T)curwin->w_curswant);

  tv_dict_add_nr(dict, ("topline"), (sizeof("topline") - 1), (varnumber_T)curwin->w_topline);
  tv_dict_add_nr(dict, ("topfill"), (sizeof("topfill") - 1), (varnumber_T)curwin->w_topfill);
  tv_dict_add_nr(dict, ("leftcol"), (sizeof("leftcol") - 1), (varnumber_T)curwin->w_leftcol);
  tv_dict_add_nr(dict, ("skipcol"), (sizeof("skipcol") - 1), (varnumber_T)curwin->w_skipcol);
}


static void f_winwidth(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  win_T *wp = find_win_by_nr_or_id(&argvars[0]);
  if (wp == 
# 12161 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           ((void *)0)
# 12161 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
               ) {
    rettv->vval.v_number = -1;
  } else {
    rettv->vval.v_number = wp->w_width;
  }
}


static void f_windowsversion(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->v_type = VAR_STRING;
  rettv->vval.v_string = (char_u *)xstrdup(windowsVersion);
}


static void f_wordcount(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  tv_dict_alloc_ret(rettv);
  cursor_pos_info(rettv->vval.v_dict);
}


static void f_writefile(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = -1;

  if (check_secure()) {
    return;
  }

  if (argvars[0].v_type == VAR_LIST) {
    do { const list_T *const l_ = (argvars[0].vval.v_list); ; if (l_ != 
# 12192 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 12192 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ) { for (const listitem_T *li = l_->lv_first; li != 
# 12192 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   ((void *)0)
# 12192 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
   ; li = li->li_next) { { if (!tv_check_str_or_nr((&(li)->li_tv))) { return; } } } } } while (0)



      ;
  } else if (argvars[0].v_type != VAR_BLOB) {
    semsg(
# 12198 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 12198 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)(e_invarg2)
# 12198 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 12198 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                     ,
          
# 12199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 12199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("writefile() first argument must be a List or a Blob")
# 12199 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 12199 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                                 );
    return;
  }

  
# 12203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 12203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      binary = 
# 12203 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 12203 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  
# 12204 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 12204 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      append = 
# 12204 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
               0
# 12204 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ;
  
# 12205 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
 _Bool 
# 12205 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
      do_fsync = !!p_fs;
  if (argvars[2].v_type != VAR_UNKNOWN) {
    const char *const flags = tv_get_string_chk(&argvars[2]);
    if (flags == 
# 12208 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                ((void *)0)
# 12208 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ) {
      return;
    }
    for (const char *p = flags; *p; p++) {
      switch (*p) {
      case 'b':
        binary = 
# 12214 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                1
# 12214 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ; break;
      case 'a':
        append = 
# 12216 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                1
# 12216 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                    ; break;
      case 's':
        do_fsync = 
# 12218 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  1
# 12218 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                      ; break;
      case 'S':
        do_fsync = 
# 12220 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                  0
# 12220 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                       ; break;
      default:

        semsg(
# 12223 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             dcgettext (((void *)0), 
# 12223 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
             (char *)("E5060: Unknown flag: %s")
# 12223 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
             , 5)
# 12223 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                         , p);
        return;
      }
    }
  }

  char buf[NUMBUFLEN];
  const char *const fname = tv_get_string_buf_chk(&argvars[1], buf);
  if (fname == 
# 12231 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
              ((void *)0)
# 12231 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                  ) {
    return;
  }
  FileDescriptor fp;
  int error;
  if (*fname == '\000') {
    emsg(
# 12237 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        dcgettext (((void *)0), 
# 12237 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        (char *)("E482: Can't open file with an empty name")
# 12237 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
        , 5)
# 12237 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                     );
  } else if ((error = file_open(&fp, fname,
                                ((append ? kFileAppend : kFileTruncate)
                                 | kFileCreate), 0666)) != 0) {
    semsg(
# 12241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         dcgettext (((void *)0), 
# 12241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
         (char *)("E482: Can't open file %s for writing: %s")
# 12241 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
         , 5)
# 12241 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                      ,
          fname, uv_strerror(error));
  } else {
    
# 12244 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
   _Bool 
# 12244 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
        write_ok;
    if (argvars[0].v_type == VAR_BLOB) {
      write_ok = write_blob(&fp, argvars[0].vval.v_blob);
    } else {
      write_ok = write_list(&fp, argvars[0].vval.v_list, binary);
    }
    if (write_ok) {
      rettv->vval.v_number = 0;
    }
    if ((error = file_close(&fp, do_fsync)) != 0) {
      semsg(
# 12254 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           dcgettext (((void *)0), 
# 12254 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
           (char *)("E80: Error when closing file %s: %s")
# 12254 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
           , 5)
# 12254 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                   ,
            fname, uv_strerror(error));
    }
  }
}



static void f_xor(typval_T *argvars, typval_T *rettv, FunPtr fptr)
{
  rettv->vval.v_number = tv_get_number_chk(&argvars[0], 
# 12264 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                       ((void *)0)
# 12264 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                           )
                         ^ tv_get_number_chk(&argvars[1], 
# 12265 "/home/jesmith/neovim/src/nvim/eval/funcs.c" 3 4
                                                         ((void *)0)
# 12265 "/home/jesmith/neovim/src/nvim/eval/funcs.c"
                                                             );
}
